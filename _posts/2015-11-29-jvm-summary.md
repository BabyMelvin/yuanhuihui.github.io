# 虚拟机执行子系统


汇报人：袁辉辉
日期：2015/11/27


> Java编译过程是将Java文件转换为Class文件，从而实现了跨平台的功能.

本文主要分以下三大块：

- Part 1: Class文件结构
- Part 2: 类加载机制
- Part 3: 字节码执行引擎



----------
#Part 1    Class文件结构

# 一、 概述
计算机只能识别0和1，所以大家编写的程序都需要经过编译器，转换为由0和1组成的二进制本地机器码(Native Code)。随着虚拟机的不断发展，很多程序语言开始选择与操作系统和机器指令集无关的格式作为编译后的存储格式（Class文件），从而实现"Write Once, Run Anywhere"。  
Java设计之初，考虑后期能让Java虚拟机运行其他语言，目前有越来越多的其他语言都可以直接需要在Java虚拟机，虚拟机只能识别Class文件，至于是由何种语言编译而来的，虚拟机并不关心，如下图：

![jvm](http://i.imgur.com/Y55s3c6.jpg)

故发布规范文档时，Java规范拆分为Java语言规范和Java虚拟机规范。  

Java语法中定义各种变量、关键字、运算符的语义最终由多个字节码命令组合而成。因此字节码命令所能提供的语义描述能力必然要比Java语言本身更加强大。


# 二、Class类文件结构
 Class文件是一组以8位字节为单位的二进制流，中间没有任何分隔符，非常紧凑。 当需要占用8位以上的数据时，会按照Big-endian顺序，高位在前，低位在后的方式来分割成多个8位字节来存储。  

- 任何一个Class文件都对应着唯一的类或接口的定义信息；
- 类或接口并不一定定义在文件里，也可以通过类加载器直接生成。

Java虚拟机规范规定：Class文件格式采用伪结构来存储数据，伪结构中只有无符号数和表这两种数据类型。

- 无符号数：是基本数据类型，以u1、u2、u4、u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数。无符号数用于描述数字、索引引用、数量值、字符串值。
- 表：是由多个无符号数或者子表作为数据项构成的符合数据类型。用于描述有层次关系的复合结构的数据。整个Class其实就是一张表。

## 2.1 相关概念

下面介绍几个概述：

**(1)全限定名**  
是指把类全名中的“.”号，用“/”号替换，并且在最后加入一个“；”分号后生成的名称。比如`java.lang.Object`对应的全限定名为`java/lang/Object;` 。

**(2)简单名**  
这个比较好理解，就是直接的方法名或者字段。比如`toString()`方法，不需要包名作为前缀了。

**(3)字段描述符**  
用于描述字段的数据类型。  

规则如下：

| 基本类型字符   | 对应类型        |
| --------   | :-----  | 
|B|	byte|
|C|	char|
|D|	double|
|F|	float|
|I|	int|
|S|	short|
|J|	long
|Z|	boolean|
|V|void|
|L+classname +;| 对象类型|
|[|	数组类型|

例如：
 
- 基本类型：int    ==>  I
- 对象类型：String ==>  Ljava/lang/String;
- 数组类型：long[] ==>  [J

**(3)方法描述符**   
用来描述方法的参数列表(数量、类型以及顺序)和返回值。 

格式：(参数描述符列表)返回值描述符。  
例如：`Object m(int i, double d, Thread t) {..}`  ==>  `IDLjava/lang/Thread;)Ljava/lang/Object;`

## 2.2 ClassFile结构
一个Class类文件是由一个ClassFile结构组成：

	ClassFile {
	    u4             magic;               //魔数，固定值0xCAFEBABE
	    u2             minor_version;       //次版本号
	    u2             major_version;       //主版本号
	    u2             constant_pool_count; //常量的个数
	    cp_info        constant_pool[constant_pool_count-1];  //具体的常量池内容
	    u2             access_flags;        //访问标识
	    u2             this_class;          //当前类索引
	    u2             super_class;         //父类索引
	    u2             interfaces_count;    //接口的个数
	    u2             interfaces[interfaces_count];          //具体的接口内容
	    u2             fields_count;        //字段的个数
	    field_info     fields[fields_count];                  //具体的字段内容
	    u2             methods_count;       //方法的个数
	    method_info    methods[methods_count];                //具体的方法内容
	    u2             attributes_count;    //属性的个数
	    attribute_info attributes[attributes_count];          //具体的属性内容
	}

一个Class文件的大小：26 + cp_info[] + u2[] + field_info[] + method_info[] + attribute_info[]

下面具体来分析Class文件的组成部分：

### 2.2.1 魔数 
每个Class文件头4个字节称为魔数(Magic Number),作用是用于确定这个Class文件是否能被虚拟机所接受，魔数固定值0xCAFEBABE。这是身份识别，比如jpeg等图片文件头也会有魔数。

### 2.2.2 版本号 
紧跟魔数，也占用4个字节。从第5字节到第8字节存储的分别是 次版本号，主版本号。

### 2.2.3 常量池  
常量池是Class文件空间最大的数据项之一，长度不固定。

a. 常量池长度  
用u2类型代表常量池容量计数值，u2紧跟版本号。u2的大小等于常量池的常量个数+1。对于u2=0的特殊情况，代表没有使用常量池。

b. 常量池内容,格式如下：

	cp_info {
	    u1 tag;
	    u1 info[];
	}

包括两个类常量，字面量和符号引用：

- 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。
- 符号引用：编译语言层面的概念，包括以下3类：
	- 类和接口的全限定名
	- 字段的名称和描述符
	- 方法的名称和描述符

常量池中每一项常量都是一个表结构，每个表的开始第一位是u1类型的标志位tag, 代表当前这个常量的类型。在JDK 1.7.中共有14种不同的表结构的类型，如下：

![常量池的类型](http://i.imgur.com/mxYskCo.png)

Class文件都是二进制格式，可通过`Jdk/bin/javap.exe`工具，分析Class文件字节码。【进行演示】

### 2.2.4 访问标识 
2个字节代表，标示用于识别一些类或者接口层次的访问信息.

| 标识名   |  标识值        | 解释|
| --------   | :-----  |  ----|
|ACC_PUBLIC|	0x0001|	声明为public;可以从包外部访问|
|ACC_FINAL|	0x0010|	被声明为final;不允许子类修改|
|ACC_SUPER|	0x0020|	当被invokespecial指令调用时，将特殊对待父类的方法|
|ACC_INTERFACE|	0x0200|	接口标识符|
|ACC_ABSTRACT|	0x0400|	声明为abstract;不能被实例化|
|ACC_SYNTHETIC|	0x1000|	声明为synthetic;不存在于源代码，由编译器生成|
|ACC_ANNOTATION|	0x2000|声明为注释类型|
|ACC_ENUM|	0x4000|	声明为枚举类型|

### 2.2.5 类/父类索引

当前类索引和父类索引占用大小都为u2类型，由于一个类只能继承一个父类，故父类索引只有一个。除了java.lang.Object对象的父类索引为0，其他所有类都有父类。

### 2.2.6 接口索引

一个类可以实现多个接口，故利用interfaces_count来记录该类所实现的接口个数，interfaces[interfaces_count]来记录所有实现的接口内容。

### 2.2.7 字段表

字段表用于描述类或接口中声明的变量，格式如下：

	field_info {
	    u2             access_flags; //访问标识
	    u2             name_index;  //名称索引
	    u2             descriptor_index; //描述符索引
	    u2             attributes_count; //属性个数
	    attribute_info attributes[attributes_count];  //属性表的具体内容
	}

字段访问标识如下：(表中加粗项是字段独有的)

| 标识名   |  标识值        | 解释|
| --------   | :-----  |  ----|
|ACC_PUBLIC|	0x0001|	声明为 public; 可以从包外部访问|
|ACC_PRIVATE|	0x0002|	声明为 private; 只有定义的类可以访问|
|ACC_PROTECTED|	0x0004|	声明为 protected;只有子类和相同package的类可访问|
|ACC_STATIC|	0x0008|	声明为 static；属于类变量|
|ACC_FINAL|	0x0010|	声明为 final; 对象构造后无法直接修改值|
|**ACC_VOLATILE**|	0x0040|	声明为 volatile; 不会被缓存,直接刷新到主屏幕|
|**ACC_TRANSIENT**|	0x0080|	声明为 transient; 不能被序列化|
|ACC_SYNTHETIC|	0x1000|	声明为 synthetic; 不存在于源代码，由编译器生成|
|ACC_ENUM|	0x4000|	声明为enum|

Java语法中，接口中的字段默认包含ACC_PUBLIC, ACC_STATIC, ACC_FINAL标识。ACC_FINAL，ACC_VOLATILE不能同时选择等规则。

紧跟其后的name_index和descriptor_index是对常量池的引用，分别代表着字段的简单名和方法的描述符。

### 2.2.8 方法表

方法表用于描述类或接口中声明的方法，格式如下：

	method_info {
	    u2             access_flags; //访问标识
	    u2             name_index;  //名称索引
	    u2             descriptor_index;  //描述符索引
	    u2             attributes_count;  //属性个数
	    attribute_info attributes[attributes_count]; //属性表的具体内容
	}

方法访问标识如下：(表中加粗项是方法独有的)

| 标识名   |  标识值        | 解释|
| --------   | :-----  |  ----|
|ACC_PUBLIC|	0x0001|	声明为 public; 可以从包外部访问|
|ACC_PRIVATE|	0x0002|	声明为 private; 只有定义的类可以访问|
|ACC_PROTECTED|	0x0004|	声明为 protected;只有子类和相同package的类可访问|
|ACC_STATIC|	0x0008|	声明为 static；属于类变量|
|ACC_FINAL|	0x0010|	声明为 final; 不能被覆写|
|**ACC_SYNCHRONIZED**|	0x0020|	声明为 synchronized; 同步锁包裹|
|ACC_BRIDGE|	0x0040|	桥接方法, 由编译器生成|
|**ACC_VARARGS**|	0x0080|	声明为 接收不定长参数|
|**ACC_NATIVE**|	0x0100|	声明为 native; 由非Java语言来实现|
|**ACC_ABSTRACT**|	0x0400|	声明为 abstract; 没有提供实现|
|**ACC_STRICT**|	0x0800|	声明为 strictfp; 浮点模式是FP-strict|
|ACC_SYNTHETIC|	0x1000|	声明为 synthetic; 不存在于源代码，由编译器生成|

- 对于方法里的Java代码，进过编译器编译成字节码指令后，存放在方法属性表集合中“code”的属性内。  
- 当子类没有覆写父类方法，则方法集合中不会出现父类的方法信息。
- Java语言中重载方法，必须与原方法同名，且特征签名不同。特征签名是指方法中各个参数在常量池的字段符号引用的集合，不包括返回值。当时Class文件格式中，特征签名范围更广，允许方法名和特征签名都相同，但返回值不同的方法，合法地共存子啊同一个Class文件中。


### 2.2.9 属性表

属性表格式：

	attribute_info {
	    u2 attribute_name_index;   //属性名索引
	    u4 attribute_length;       //属性长度
	    u1 info[attribute_length]; //属性的具体内容
	}

属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。  
关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。

| 属性名   |  使用位置        | 解释|
| --------   | :-----  |  ----|
|Code|	方法表| 方法体的内容|
|ConstantValue|	字段表|	final关键字定义的常量值|
|Deprecated|	类、方法表、字段表|声明为deprecated|
|InnerClasses| 类文件|内部类的列表|
|LineNumberTable| Code属性| Java源码的行号与字节码指令的对应关系|
|LocalVariableTable|Code属性|方法的局部变量描述|
|Signature|类、方法表、字段表|用于支持泛型的方法签名，由于Java的泛型采用擦除法，避免类型信息被擦除后导致签名混乱，Signature记录相关信息|


**Code属性**  
java程序方法体中的代码，经编译后得到的字节码指令存储在Code属性内，Code属性位于方法表的属性集合中。但与native或者abstract的方法则不会存在Code属性中。

Code属性的格式如下：

	Code_attribute {
	    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“
	    u4 attribute_length; //属性值长度，为整个属性表长度-6
	    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值佩服栈帧
	    u2 max_locals;  //局部变量表最大存储空间，单位是slot
	    u4 code_length; // 字节码指令的个数
	    u1 code[code_length]; // 具体的字节码指令
	    u2 exception_table_length; //异常的个数
	    {   u2 start_pc; 
	        u2 end_pc;
	        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。
	        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理
	    } exception_table[exception_table_length]; //具体的异常内容
	    u2 attributes_count;     //属性的个数
	    attribute_info attributes[attributes_count]; //具体的属性内容
	}

- slot是虚拟机未局部变量分配内存使用的最小单位。对于byte/char/float/int/short/boolean/returnAddress等长度不超过32位的局部变量，每个占用1个Slot；对于long和double这两种64位的数据类型则需要2个Slot来存放。
- 实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。
- max_locals，不是所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。
- 虚拟机规范限制严格方法不允许超过65535个字节码，否则拒绝编译。

Code属性是Class文件中最重要的属性，Java程序的幸福课分为代码(方法体中的Java代码)和元数据(包含类、接口、字段、方法定义以及其他信息)两部分。


**ConstantValue属性**  
ConstantValue属性是指被static关键字修饰的变量（也称为类变量）。

- 类变量:  在类构造器<clinit>方法或者使用ConstantValue属性来赋值
- 实例变量：在实例构造器<init>方法进行赋值


## 1.3 字节码

Java虚拟机的指令由操作码和操作数组成。  

- 操作码：一个字节长度(0~255)，意味着指令集的操作码个数不能操作256条。
- 操作数：一条指令可以有零或者多个操作数，同时操作数可以是1个或者多个字节。编译后的代码没有采用操作数长度对齐方式，比如16位无符号整数需使用两个字节储存(假设为byte1和byte2)，那么真实值是 `(byte1 << 8) | byte2`。

放弃操作数对齐方案：

- 优势：可以省略很多填充和间隔符号，从而减少数据量，具有更高的传输效率；Java起初就是为了面向网络、智能家具而设计的，故更加注重传输效率。
- 劣势：运行时从构建出具体数据结构，导致解释执行字节码会损失部分性能。

不考虑异常处理，Java虚拟机的解释器的执行模型如下：

	do {
	    atomically calculate pc and fetch opcode at pc;
	    if (operands) fetch operands;
	    execute the action for the opcode;
	} while (there is more to do);




----------

----------
#Part 2    类加载机制


## 一、概述
本文主要讲述虚拟机如何把 Class文件加载到内存的过程。校验、转换解析和初始化，最终形成可被虚拟机使用的Java类型，这就是虚拟机的类加载机制。 

类型的加载、连接和初始化都是在程序运行期间完成，该策略：

- 优势：提高Java程序的灵活性，Java动态扩展的语言特性就是依赖运行期动态加载和动态连接。当面向接口的应用程序，可以等到运行时指定实现类；可以通过类加载器，让程序运行时加载一个二进制流作为程序一部分。
- 劣势：增加类加载的性能开销。

## 二、 类加载的生命周期
类的生命周期是指把Class字节码从文件中加载到内存，直到卸载内存整个过程，分为7个步骤。

![class_loading](http://i.imgur.com/d17jvdM.jpg)

解析阶段不一定要在初始化之前， 也可以在初始化之后再解析，这种情况称为动态绑定或晚期绑定。

### 1. 加载
虚拟机在加载阶段，主要工作如下：

- （1） 通过类的全限定名来获取定义此类的二进制字节流；字节流的来源有
	- 压缩包，例如jar/war等格式;
	- 网络，典型场景applet;
	- 运行时计算生成，例如动态代理技术，在java.lang.reflect.Proxy中，利用ProxyGenerator.generateProxyClass来为特定接口生成形如“*$Proxy"的代理类的二进制字节流；
	- 数据库，例如中间件服务器(SAP Netweaver)。
	
- （2）将这个字节流所有代表的静态存储结构转化为方法区的运行时数据结构；
- （3）生成一个代表这个类的java.lang.Class对象，存放在内存的方法区，作为方法区这个类的各种数据的访问入口。

注：对于数组类，不通过类加载器创建，而是由虚拟机直接创建的。另外加载阶段尚未完成，连接阶段可能已经开始。

这里提到方法区，方法区是运行时内存数据区的一部分，如下：


![memory1](http://i.imgur.com/a4u4kvK.jpg)

进一步细化堆上分区：

![memory2](http://i.imgur.com/7nYkL31.jpg)

关于栈的细化，再后面会详细介绍。

### 2. 验证
验证是连接阶段(Linking)的第一步，目的是为了确保Class文件的字节流符合虚拟机规范，不会危害虚拟机自身安全。比如：访问数组越界问题，将对象转型为未实现的类型，跳转到不存在的代码区等情绪编译器都会拒绝编译，也就是无法生成Class文件，既然如此，为什么还要验证呢？原因是Class文件不一定都是由java源码编译而成，可以是任何途径，所以验证还是很有必要的，尽可能保证系统能承受住恶意代码攻击。

验证主要工作分4阶段：文件格式验证，元数据验证，字节码验证，符号引用验证。

**文件格式验证**  (是否符合Class文件格式规范)  
验证点有比如是否魔数0xCAFEBABE开头；主、次版本号是否范围之内；常量池中常量tag标示是否正确等等，只有通过全部的验证，才能把字节流存储到内存的方法区。

**元数据验证**  (是否符合Java语言规范)
经过文件格式验证，字节流已加载到方法区，这个阶段工作是对方法区的字节码进行语义分析，保证符合Java语言规范。
验证点比如：

- 该类是否有父类(除Object之外，所有类都应该有父类)
- 该类是否继承不允许继承的类(final类)
- 非抽象类，是否都实现其父类的抽象方法或接口中的方法
- 类的字段、方法是否与父类矛盾(例如覆盖父类的final字段，或重载不符合规则)
- ...
除上面列举外，还有很多。经过元数据验证，能确保元数据都是符合规范。

**字节码验证**  (数据流和控制流分析)
比如操作数栈的数据类型和指令代码序列配合，跳转指令不会跳到方法体之外等。HotSpot虚拟机提供 -XX:-UseSplitVerifier选项来关闭这项优化。

**符号引用验证** (符号引用转化为直接引用	)  
校验点：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类；
- 在指定类是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；
- 符号引用中的类、字段、方法的访问权限检查。
- ...等等

对于虚拟机的类加载机制来说，验证阶段非常重要的，但不是一定必要的。如果所运行的全部代码(包含自己编写以及第三方包的代码)都已经被反复使用和验证过，那么可以考虑使用 -Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 3. 准备
主要工作：为static变量分配内存并设置类变量的初始值的阶段。该阶段仅对类变量进行内存分配，不包括实例变量，实例变量的初始化会随着对象实例化时在Java堆上分配内存。

（1）类变量  
例如：  

	public static int value = 10;

在准备阶段，会为变量value在方法区分配内存，并初始化为0，而不是10。 因为对于value的赋值10，是由putstatic指令完成。该指令是在java程序被编译后，存放在类构造器`<clinit>`方法之中。所以 value = 10的操作是在类初始化的时候才发生。 故类变量在准备期间，value = 0;

准备阶段，只把所有的类变量都赋予零值。

零值表：

|数据类型|零值|
|---|---|
|int|0|
|long|0L|
|float|0.0f|
|double|0.0d|
|short|(short)0|
|byte|(byte)0|
|char|'\u0000'|
|boolean|false|
|reference|null|

（2）常量  
例如：  

	public static final int value = 10;

对于常量，准备阶段，会把类字段的字段属性表中的ConstantValue属性所指定的值（此处是10），赋给常量（value）。故常量在准备期间，value =10;

### 4. 解析
主工作：虚拟机将常量池内的符号引用替换为直接引用的阶段。

- 符号引用(Symbolic Reference)：以一组符号来描述引用目标，符号可以是任意形式的字面量。只能要准确定位到目标即可。符号引用与虚拟机的内存布局无关，引用的目标也不一定存在内存。这样兼容性强，各种虚拟机只需要能接受符号引用即可。
- 直接引用(Direct Reference)：直接引用就是指向目标的指针、相对偏移量或者能简介定位到目标的句柄。直接引用和虚拟机内存布局息息相关。直接引用的目标必然存在与内存中。

同一个符号引用 在不同的虚拟机中解析出来的直接引用地址一般都是不相同的。  
同一个符号引用，在同一个虚拟机下，多次解析时，会对第一次解析结果进行缓存（常量池记录直接引用，并标记已解析状态），从而避免多次解析。
  
特殊情形，对于invokedynamic指令，不会进行缓存过程，每次使用前都会进行解析。

### 5. 初始化
类初始化阶段是类加载的最后一个阶段。在前面过程中，用户可控的地方只有通过自定义类加载器参与，其余都是虚拟机主导和控制。

到了初始化，开始真正的执行类中定义的Java程序代码。初始化阶段，主要是执行类构造器方法`<clinit>`，类构造方法是由编译器自动收集生成的：

- `<clinit>`方法包括类变量赋值操作和静态语句块合并而成，收集顺序是有语句在源文件的顺序所决定。故静态语句块只能访问定义之前的静态变量；对于定义之后的变量可以赋值，但不能访问。【7.5】
- `<clinit>`方法与类的实例构造方法`init`不同，`<clinit>`方法不需要显式调用父类构造器，虚拟机会保证子类的`<clinit>`方法执行之前，福来的`<clinit>`方法已经执行完毕。故第一个被执行的`<clinit>`方法的类肯定是java.lang.Object。  
- `<clinit>`方法不是必需的，对于没有静态块和类变量赋值操作，编译器不会生成`<clinit>`方法。
- 父类静态语句和静态变量赋值优先于子类；
- interface中不能有静态语句块，但仍可以有变量初始化的赋值操作，也可以生成`<clinit>`方法。但接口和类的不同是，执行接口的`<clinit>`方法不需要先执行父接口的`<clinit>`方法。只有当父接口中定义的变量使用时，父接口才会初始化。
- 虚拟机保证一个类的`<clinit>`方法可以多线程正确执行，会加锁、同步的操作。 一个线程执行`<clinit>`方法，其他线程阻塞等待，当`<clinit>`方法有耗时操作，会造成多进程的阻塞，往往比较隐蔽。


虚拟机规范中，严格规定有且只有5种情况下，当类没有初始化，必须立即对类进行初始化：

- 遇到new、getstatic、putstatic或invokeStatic这4条字节码指令时。常见场景：使用new关键字实例化对象、读取或设置类的静态字段(final字段，在编译器已把结果放入常量池的静态字段除外)以及调用类的静态方法；
- 使用java.lang.reflect包中的方法对类进行反射调用时；
- 初始化一个类时，当其父类没有初始化，则需要先触发其父类的初始化；
- 虚拟机启动时，需指定一个要执行的主类(含有main()的类)，虚拟机会先初始化该类；
- 当java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，且该句柄所对应的类没有进行过初始化；

上述的5种场景的行为都是对类的一个主动引用过程。除此之外，还有被动引用，并不会除非类的初始化过程。（下面code角度说明）【待】



## 三、类加载器
把类的加载阶段的动作，“通过类的全限定名来获取定义此类的二进制字节流”放到Java虚拟机外部去实现，让应用程序自己决定如何获取所需要的类，这是动作模块称为类加载器。
类加载器是Java语言的创新，也是Java语言流行的因素之一。优势：

- 类加载器在类层次划分、OSGi、热部署、代码加载等领域大放异彩，成为Java技术的基石。
- 两个类来自同一个Class文件，被同一个虚拟机加载，只要类加载器不同，类也是不同的。

经典应用场景：

- Tomcat，类加载器架构，自己定义了多个类加载器，
	- 保证了同一个服务器的两个Web应用程序的Java类库隔离；
	- 保证了同一个服务器的两个Web应用程序的Java类库又可以相互共享；比如多个Spring组织的应用程序不能共享，会造成资源浪费；
	- 保证了服务器尽可能保证自身的安全不受不受部署Web应用程序影响；
	- 支持JSP应用的服务器，大多需要支持热替换(HotSwap)功能。

- OSGi(Open Service GateWay Initiative)，是基于Java语言的动态模块化规范。已成为Java世界的“事实上”的模块化标准，最为熟悉的案例的Eclipse IDE。



----------

----------
# Part 3: 字节码执行引擎

## 一、概述
执行引擎是Java虚拟机非常最核心的部分，对于物理即的执行引擎是直接建立在处理器、硬件、指令集合操作系统层面，而虚拟机执行引擎则是由自行定制的指令集与执行引擎的结构体系。执行引擎在执行Java会有解释执行(通过解释器)和编译执行(通过JIT生成的本地代码)两种选择，对于Android ART又多了一种提前编译器。

### 运行时栈帧
栈帧(Stack Frame)是用于支持虚拟机进行防腐调用和方法执行的数据结构，是属性运行时数据区的虚拟机站的栈元素。
栈帧包括：

1. **局部变量表** (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位。
2. **操作栈**(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配
3. **动态连接**， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。
	1. 前面的解析过程其实是静态解析；
	2. 对于运行期转化为直接引用，称为动态解析。
4. **方法返回地址**
	1. 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者
	2. 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。
5. **额外附加信息**，虚拟机规范没有明确规定，由具体虚拟机实现。

因此，一个栈帧的大小不会受到

### 运行时内存
Java堆是jvm所管理的内存最大的一块。随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术会使得部分对象分配在堆上。GC堆主要是针对java堆。

![memory3](http://i.imgur.com/o3sMnZD.jpg)

在堆上分配着实例对象，那么实例对象的具体结构如下：

![memory4](http://i.imgur.com/XmoCIZs.jpg)

## 1. 对象的创建过程：
这里的对象创建，不包括数组和Class对象，例如  
`Person person = new Person()`，

当虚拟机遇到new指令时：

- 在常量池中查找“Person”，看能否定位到Person类的符号引用；如果能，则继续执行。
- 再检查Person类是否已经加载、解析和初始化；如果没有初始化，则先执行类加载过程。
- 类加载后，虚拟机为新生成的person对象在堆上分配相应大小的内存。（对象大小在类加载后确定）
- 内存分配后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量不赋初值也能使用对应的零值。
- 设置对象头信息，比如对象的哈希值，gc分代年龄等。

从虚拟机角度，到此一个新的对象已经创建完成。但从Java视角，对象才刚刚开始，init构造方法还没有执行，所有字段还是零。执行完init方法，按java程序的构造方法进行初始化后，对象便是彻底创建完成。

另外，关于在堆上内存分配，是并发进行的，虚拟机采用CAS加失败重试保证原子操作。还有一种方案是每个线程预先分配内存，称为本地线程分配缓冲。

##字节码执行实例

对于如下Java代码：

	public int calc(){
	int a = 10;
	int b = 20;
	int c = 30;
	return (a+b)*c;

经过javac编译，生成的字节码：

     stack=2, locals=4, args_size=1
      0: bipush        10
      2: istore_1
      3: bipush        20
      5: istore_2
      6: bipush        30
      8: istore_3
      9: iload_1
     10: iload_2
     11: iadd
     12: iload_3
     13: imul
     14: ireturn

可以看出，栈大小为2（运算过程中只需要2个slot空间），局部变量表大小为4(分别用来存放this, a, b, c)， args_size =1指的就是方法所在对象。

具体过程每一帧的情况，演讲中已展示，整个执行结束后的，最后栈帧情况如下：

![jvm_sub](http://i.imgur.com/1RS9WRI.jpg)


## 后续
- Jvm编译机制
- 编译器的优化策略
- 如何编写对编译器友好的指导方案



## 参考文献

- <https://docs.oracle.com/javase/specs/jvms/se7/html/>
- Java语言规范《The Java Language Specification》
- Java虚拟机规范《The Java Virtual Machine Specification》
- 《深入理解Java虚拟机》
