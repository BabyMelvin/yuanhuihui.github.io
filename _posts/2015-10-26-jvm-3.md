---
layout: post
title:  "字节码执行引擎"
date:   2015-10-26 19:16:10
categories: Java
excerpt:  字节码执行引擎
---

* content
{:toc}



---


## 一、概述
执行引擎是Java虚拟机非常最核心的部分，对于物理即的执行引擎是直接建立在处理器、硬件、指令集合操作系统层面，而虚拟机执行引擎则是由自行定制的指令集与执行引擎的结构体系。执行引擎在执行Java会有解释执行(通过解释器)和编译执行(通过JIT生成的本地代码)两种选择，对于Android ART又多了一种提前编译器。

### 运行时栈帧
栈帧(Stack Frame)是用于支持虚拟机进行防腐调用和方法执行的数据结构，是属性运行时数据区的虚拟机站的栈元素。
栈帧包括：

1. **局部变量表** (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位。
2. **操作栈**(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配
3. **动态连接**， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。
	1. 前面的解析过程其实是静态解析；
	2. 对于运行期转化为直接引用，称为动态解析。
4. **方法返回地址**
	1. 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者
	2. 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。
5. **额外附加信息**，虚拟机规范没有明确规定，由具体虚拟机实现。

因此，一个栈帧的大小不会受到

### 运行时内存
Java堆是jvm所管理的内存最大的一块。随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术会使得部分对象分配在堆上。GC堆主要是针对java堆。

![memory3](http://i.imgur.com/o3sMnZD.jpg)

在堆上分配着实例对象，那么实例对象的具体结构如下：

![memory4](http://i.imgur.com/XmoCIZs.jpg)

## 1. 对象的创建过程：
这里的对象创建，不包括数组和Class对象，例如  
`Person person = new Person()`，

当虚拟机遇到new指令时：

- 在常量池中查找“Person”，看能否定位到Person类的符号引用；如果能，则继续执行。
- 再检查Person类是否已经加载、解析和初始化；如果没有初始化，则先执行类加载过程。
- 类加载后，虚拟机为新生成的person对象在堆上分配相应大小的内存。（对象大小在类加载后确定）
- 内存分配后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量不赋初值也能使用对应的零值。
- 设置对象头信息，比如对象的哈希值，gc分代年龄等。

从虚拟机角度，到此一个新的对象已经创建完成。但从Java视角，对象才刚刚开始，init构造方法还没有执行，所有字段还是零。执行完init方法，按java程序的构造方法进行初始化后，对象便是彻底创建完成。

另外，关于在堆上内存分配，是并发进行的，虚拟机采用CAS加失败重试保证原子操作。还有一种方案是每个线程预先分配内存，称为本地线程分配缓冲。


注意：
Java 动态类型语言：类型检查在运行期
C/C++ 静态类型语言：类型检查在编译期
























https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf