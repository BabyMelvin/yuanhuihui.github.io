---
layout: post
title:  "虚拟机系列2-Class加载机制"
date:   2015-10-25 19:16:10
categories: Java
excerpt:  虚拟机系列2-Class加载机制
---

* content
{:toc}



---


## 一、概述
本文主要讲述虚拟机如何把 Class文件加载到内存的过程。校验、转换解析和初始化，最终形成可被虚拟机使用的Java类型，这就是虚拟机的类加载机制。 

类型的加载、连接和初始化都是在程序运行期间完成，该策略：

- 优势：提高Java程序的灵活性，Java动态扩展的语言特性就是依赖运行期动态加载和动态连接。当面向接口的应用程序，可以等到运行时指定实现类；可以通过类加载器，让程序运行时加载一个二进制流作为程序一部分。
- 劣势：增加类加载的性能开销。

## 二、 类加载的生命周期
类的生命周期是指把Class字节码从文件中加载到内存，直到卸载内存整个过程，分为7个步骤。

![class_loading](http://i.imgur.com/d17jvdM.jpg)

解析阶段不一定要在初始化之前， 也可以在初始化之后再解析，这种情况称为动态绑定或晚期绑定。

### 1. 加载
虚拟机在加载阶段，主要工作如下：

- （1） 通过类的全限定名来获取定义此类的二进制字节流；字节流的来源有
	- 压缩包，例如jar/war等格式;
	- 网络，典型场景applet;
	- 运行时计算生成，例如动态代理技术，在java.lang.reflect.Proxy中，利用ProxyGenerator.generateProxyClass来为特定接口生成形如“*$Proxy"的代理类的二进制字节流；
	- 数据库，例如中间件服务器(SAP Netweaver)。
	
- （2）将这个字节流所有代表的静态存储结构转化为方法区的运行时数据结构；
- （3）生成一个代表这个类的java.lang.Class对象，存放在内存的方法区，作为方法区这个类的各种数据的访问入口。

注：对于数组类，不通过类加载器创建，而是由虚拟机直接创建的。另外加载阶段尚未完成，连接阶段可能已经开始。

这里提到方法区，方法区是运行时内存数据区的一部分，如下：


![memory1](http://i.imgur.com/a4u4kvK.jpg)

进一步细化堆上分区：

![memory2](http://i.imgur.com/7nYkL31.jpg)

关于栈的细化，再后面会详细介绍。

### 2. 验证
验证是连接阶段(Linking)的第一步，目的是为了确保Class文件的字节流符合虚拟机规范，不会危害虚拟机自身安全。比如：访问数组越界问题，将对象转型为未实现的类型，跳转到不存在的代码区等情绪编译器都会拒绝编译，也就是无法生成Class文件，既然如此，为什么还要验证呢？原因是Class文件不一定都是由java源码编译而成，可以是任何途径，所以验证还是很有必要的，尽可能保证系统能承受住恶意代码攻击。

验证主要工作分4阶段：文件格式验证，元数据验证，字节码验证，符号引用验证。

**文件格式验证**  (是否符合Class文件格式规范)  
验证点有比如是否魔数0xCAFEBABE开头；主、次版本号是否范围之内；常量池中常量tag标示是否正确等等，只有通过全部的验证，才能把字节流存储到内存的方法区。

**元数据验证**  (是否符合Java语言规范)
经过文件格式验证，字节流已加载到方法区，这个阶段工作是对方法区的字节码进行语义分析，保证符合Java语言规范。
验证点比如：

- 该类是否有父类(除Object之外，所有类都应该有父类)
- 该类是否继承不允许继承的类(final类)
- 非抽象类，是否都实现其父类的抽象方法或接口中的方法
- 类的字段、方法是否与父类矛盾(例如覆盖父类的final字段，或重载不符合规则)
- ...
除上面列举外，还有很多。经过元数据验证，能确保元数据都是符合规范。

**字节码验证**  (数据流和控制流分析)
比如操作数栈的数据类型和指令代码序列配合，跳转指令不会跳到方法体之外等。HotSpot虚拟机提供 -XX:-UseSplitVerifier选项来关闭这项优化。

**符号引用验证** (符号引用转化为直接引用	)  
校验点：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类；
- 在指定类是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；
- 符号引用中的类、字段、方法的访问权限检查。
- ...等等

对于虚拟机的类加载机制来说，验证阶段非常重要的，但不是一定必要的。如果所运行的全部代码(包含自己编写以及第三方包的代码)都已经被反复使用和验证过，那么可以考虑使用 -Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 3. 准备
主要工作：为static变量分配内存并设置类变量的初始值的阶段。该阶段仅对类变量进行内存分配，不包括实例变量，实例变量的初始化会随着对象实例化时在Java堆上分配内存。

（1）类变量  
例如：  

	public static int value = 10;

在准备阶段，会为变量value在方法区分配内存，并初始化为0，而不是10。 因为对于value的赋值10，是由putstatic指令完成。该指令是在java程序被编译后，存放在类构造器`<clinit>`方法之中。所以 value = 10的操作是在类初始化的时候才发生。 故类变量在准备期间，value = 0;

准备阶段，只把所有的类变量都赋予零值。

零值表：

|数据类型|零值|
|---|---|
|int|0|
|long|0L|
|float|0.0f|
|double|0.0d|
|short|(short)0|
|byte|(byte)0|
|char|'\u0000'|
|boolean|false|
|reference|null|

（2）常量  
例如：  

	public static int value = 10;

对于常量，准备阶段，会把类字段的字段属性表中的ConstantValue属性所指定的值（此处是10），赋给常量（value）。故常量在准备期间，value =10;

### 4. 解析
主工作：虚拟机将常量池内的符号引用替换为直接引用的阶段。

- 符号引用(Symbolic Reference)：以一组符号来描述引用目标，符号可以是任意形式的字面量。只能要准确定位到目标即可。符号引用与虚拟机的内存布局无关，引用的目标也不一定存在内存。这样兼容性强，各种虚拟机只需要能接受符号引用即可。
- 直接引用(Direct Reference)：直接引用就是指向目标的指针、相对偏移量或者能简介定位到目标的句柄。直接引用和虚拟机内存布局息息相关。直接引用的目标必然存在与内存中。

同一个符号引用 在不同的虚拟机中解析出来的直接引用地址一般都是不相同的。  
同一个符号引用，在同一个虚拟机下，多次解析时，会对第一次解析结果进行缓存（常量池记录直接引用，并标记已解析状态），从而避免多次解析。
  
特殊情形，对于invokedynamic指令，不会进行缓存过程，每次使用前都会进行解析。

### 5. 初始化
类初始化阶段是类加载的最后一个阶段。在前面过程中，用户可控的地方只有通过自定义类加载器参与，其余都是虚拟机主导和控制。

到了初始化，开始真正的执行类中定义的Java程序代码。初始化阶段，主要是执行类构造器方法`<clinit>`，类构造方法是由编译器自动收集生成的：

- `<clinit>`方法包括类变量赋值操作和静态语句块合并而成，收集顺序是有语句在源文件的顺序所决定。故静态语句块只能访问定义之前的静态变量；对于定义之后的变量可以赋值，但不能访问。【7.5】
- `<clinit>`方法与类的实例构造方法`init`不同，`<clinit>`方法不需要显式调用父类构造器，虚拟机会保证子类的`<clinit>`方法执行之前，福来的`<clinit>`方法已经执行完毕。故第一个被执行的`<clinit>`方法的类肯定是java.lang.Object。  
- `<clinit>`方法不是必需的，对于没有静态块和类变量赋值操作，编译器不会生成`<clinit>`方法。
- 父类静态语句和静态变量赋值优先于子类；
- interface中不能有静态语句块，但仍可以有变量初始化的赋值操作，也可以生成`<clinit>`方法。但接口和类的不同是，执行接口的`<clinit>`方法不需要先执行父接口的`<clinit>`方法。只有当父接口中定义的变量使用时，父接口才会初始化。
- 虚拟机保证一个类的`<clinit>`方法可以多线程正确执行，会加锁、同步的操作。 一个线程执行`<clinit>`方法，其他线程阻塞等待，当`<clinit>`方法有耗时操作，会造成多进程的阻塞，往往比较隐蔽。


虚拟机规范中，严格规定有且只有5种情况下，当类没有初始化，必须立即对类进行初始化：

- 遇到new、getstatic、putstatic或invokeStatic这4条字节码指令时。常见场景：使用new关键字实例化对象、读取或设置类的静态字段(final字段，在编译器已把结果放入常量池的静态字段除外)以及调用类的静态方法；
- 使用java.lang.reflect包中的方法对类进行反射调用时；
- 初始化一个类时，当其父类没有初始化，则需要先触发其父类的初始化；
- 虚拟机启动时，需指定一个要执行的主类(含有main()的类)，虚拟机会先初始化该类；
- 当java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，且该句柄所对应的类没有进行过初始化；

上述的5种场景的行为都是对类的一个主动引用过程。除此之外，还有被动引用，并不会除非类的初始化过程。（下面code角度说明）【待】



## 三、类加载器
把类的加载阶段的动作，“通过类的全限定名来获取定义此类的二进制字节流”放到Java虚拟机外部去实现，让应用程序自己决定如何获取所需要的类，这是动作模块称为类加载器。
类加载器是Java语言的创新，也是Java语言流行的因素之一。优势：

- 类加载器在类层次划分、OSGi、热部署、代码加载等领域大放异彩，成为Java技术的基石。
- 两个类来自同一个Class文件，被同一个虚拟机加载，只要类加载器不同，类也是不同的。

经典应用场景：

- Tomcat，类加载器架构，自己定义了多个类加载器，
	- 保证了同一个服务器的两个Web应用程序的Java类库隔离；
	- 保证了同一个服务器的两个Web应用程序的Java类库又可以相互共享；比如多个Spring组织的应用程序不能共享，会造成资源浪费；
	- 保证了服务器尽可能保证自身的安全不受不受部署Web应用程序影响；
	- 支持JSP应用的服务器，大多需要支持热替换(HotSwap)功能。

- OSGi(Open Service GateWay Initiative)，是基于Java语言的动态模块化规范。已成为Java世界的“事实上”的模块化标准，最为熟悉的案例的Eclipse IDE。