---
layout: post
title:  "守护进程之installd"
date:   2016-02-05 20:15:40
catalog:  true
tags:
    - android

---

> 基于Android 6.0的源码剖析

		system/core/adb/commandline.c
		frameworks/base/cmds/installd/installd.c
		frameworks/base/cmds/installd/commands.c

## 一、 启动

init.rc 启动过程。

## 二. installer
[-> SystemServer.java]

    private void startBootstrapServices() {
        //启动installer服务【见小节3.0】
        Installer installer = mSystemServiceManager.startService(Installer.class);
        ...

    }
    
## 三. 启动Installer

[-> Installer.java]

    public Installer(Context context) {
        super(context);
        //创建InstallerConnection对象
        mInstaller = new InstallerConnection();
    }

    public void onStart() {
      Slog.i(TAG, "Waiting for installd to be ready.");
      //【见小节3.1】
      mInstaller.waitForConnection();
    }

先创建Installer对象，再调用onStart()方法，该方法中主要工作是等待socket通道建立完成。

### 3.1 waitForConnection
[-> InstallerConnection.java]

    public void waitForConnection() {
        for (;;) {
            //【见小节3.2】
            if (execute("ping") >= 0) {
                return;
            }
            Slog.w(TAG, "installd not ready");
            SystemClock.sleep(1000);
        }
    }

通过循环地方式，每次休眠1s

### 3.2 execute
[-> InstallerConnection.java]

    public int execute(String cmd) {
        //【见小节3.3】
        String res = transact(cmd);
        try {
            return Integer.parseInt(res);
        } catch (NumberFormatException ex) {
            return -1;
        }
    }

### 3.3 transact
[-> InstallerConnection.java]

    public synchronized String transact(String cmd) {
        //【见小节3.3.1】
        if (!connect()) {
            return "-1";
        }

        //【见小节3.3.2】
        if (!writeCommand(cmd)) {
            if (!connect() || !writeCommand(cmd)) {
                return "-1";
            }
        }

        //读取应答消息【3.3.3】
        final int replyLength = readReply();
        if (replyLength > 0) {
            String s = new String(buf, 0, replyLength);
            return s;
        } else {
            return "-1";
        }
    }

#### 3.3.1 connect

    private boolean connect() {
        if (mSocket != null) {
            return true;
        }
        Slog.i(TAG, "connecting...");
        try {
            mSocket = new LocalSocket();

            LocalSocketAddress address = new LocalSocketAddress("installd",
                    LocalSocketAddress.Namespace.RESERVED);

            mSocket.connect(address);

            mIn = mSocket.getInputStream();
            mOut = mSocket.getOutputStream();
        } catch (IOException ex) {
            disconnect();
            return false;
        }
        return true;
    }

#### 3.3.2 writeCommand

    private boolean writeCommand(String cmdString) {
        final byte[] cmd = cmdString.getBytes();
        final int len = cmd.length;
        if ((len < 1) || (len > buf.length)) {
            return false;
        }

        buf[0] = (byte) (len & 0xff);
        buf[1] = (byte) ((len >> 8) & 0xff);
        try {
            mOut.write(buf, 0, 2); //写入长度
            mOut.write(cmd, 0, len); //写入具体命令
        } catch (IOException ex) {
            disconnect();
            return false;
        }
        return true;
    }

#### 3.3.3 readReply

    private int readReply() {
        //【见小节3.3.4】
        if (!readFully(buf, 2)) {
            return -1;
        }

        final int len = (((int) buf[0]) & 0xff) | ((((int) buf[1]) & 0xff) << 8);
        if ((len < 1) || (len > buf.length)) {
            disconnect();
            return -1;
        }

        if (!readFully(buf, len)) {
            return -1;
        }

        return len;
    }    

#### 3.3.4 readFully

    private boolean readFully(byte[] buffer, int len) {
         try {
             Streams.readFully(mIn, buffer, 0, len);
         } catch (IOException ioe) {
             disconnect();
             return false;
         }
         return true;
     }

 可见，一次transact过程为先connect()来判断是否建立socket连接，如果已连接则通过writeCommand()
 将命令写入socket的mOut管道，等待从管道的mIn中readFully()读取应答消息。
