<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="gityuan">
    <meta name="keyword"  content="Android,gityuan,Android技术博客,Android源码分析,袁辉辉">
    <meta name="description" content="Android,gityuan,Android技术博客,Android源码分析,袁辉辉">
    <meta name="baidu-site-verification" content="tgshRgudx0" />
    <link rel="shortcut icon" href="/images/favicon.ico"/>
    <title>理解Android进程创建流程 - Gityuan博客</title>

    <link rel="canonical" href="http://gityuan.com/2016/03/27/app-process-create/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Gityuan</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Category</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#android" title="android">android</a>
                        
                        <a class="tag" href="/tags/#boot" title="boot">boot</a>
                        
                        <a class="tag" href="/tags/#process" title="process">process</a>
                        
                    </div>
                    <h1>理解Android进程创建流程</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by Gityuan on March 27, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<blockquote>
  <p>基于Android 6.0的源码剖析， 分析Android进程是如何一步步创建的，本文涉及到的源码：</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>/frameworks/base/core/java/android/os/Process.java
/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java
/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java

/frameworks/base/core/java/com/android/internal/os/Zygote.java
/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp

/frameworks/base/cmds/app_process/App_main.cpp （内含AppRuntime类）
/frameworks/base/core/jni/AndroidRuntime.cpp

/libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
/art/runtime/native/dalvik_system_ZygoteHooks.cc
/art/runtime/Runtime.cc
/art/runtime/Thread.cc
/art/runtime/signal_catcher.cc
</code></pre>
</div>

<h3 id="section">概述</h3>

<p>本文要介绍的是进程的创建，先简单说说进程与线程的区别。</p>

<p><strong>进程：</strong>每个<code class="highlighter-rouge">App</code>在启动前必须先创建一个进程，该进程是由<code class="highlighter-rouge">Zygote</code> fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个<code class="highlighter-rouge">App</code>就运行在一个进程中，除非在AndroidManifest.xml中配置<code class="highlighter-rouge">Android:process</code>属性，或通过native代码fork进程。</p>

<p><strong>线程：</strong>线程对应用开发者来说非常熟悉，比如每次<code class="highlighter-rouge">new Thread().start()</code>都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从Linux角度来说进程与线程都是一个task_struct结构体，除了是否共享资源外，并没有其他本质的区别。</p>

<p>对于大多数的应用开发者来说创建线程比较熟悉，而对于创建进程并没有太多的概念。对于系统工程师或者高级开发者，还是有很必要了解Android系统是如何一步步地创建出一个进程的。先来看一张进程创建过程的简要图：</p>

<p><img src="/images/android-process/start_app_process.jpg" alt="start_app_process" /></p>

<p>图解：</p>

<ol>
  <li><strong>App发起进程</strong>：当从桌面启动应用，则发起进程便是Launcher所在进程；当从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过binder发送消息给system_server进程；</li>
  <li><strong>system_server进程</strong>：调用Process.start()方法，通过socket向zygote进程发送创建新进程的请求；</li>
  <li><strong>zygote进程</strong>：在执行<code class="highlighter-rouge">ZygoteInit.main()</code>后便进入<code class="highlighter-rouge">runSelectLoop()</code>循环体内，当有客户端连接时便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程；</li>
  <li><strong>新进程</strong>：执行handleChildProc方法，最后调用ActivityThread.main()方法。</li>
</ol>

<p>可能朋友不是很了解system_server进程和Zygote进程，下面简要说说：</p>

<ul>
  <li><code class="highlighter-rouge">system_server</code>进程：是用于管理整个Java framework层，包含ActivityManager，PowerManager等各种系统服务;</li>
  <li><code class="highlighter-rouge">Zygote</code>进程：是Android系统的首个Java进程，Zygote是所有Java进程的父进程，包括 <code class="highlighter-rouge">system_server</code>进程以及所有的App进程都是Zygote的子进程，注意这里说的是子进程，而非子线程。</li>
</ul>

<p>如果想更进一步了解system_server进程和Zygote进程在整个Android系统所处的地位，可查看我的另一个文章<a href="http://gityuan.com/2016/01/30/android-boot/">Android系统-开篇</a>。</p>

<p>接下来从Android 6.0源码，展开讲解进程创建是一个怎样的过程。</p>

<h3 id="processstart">1. Process.start</h3>

<p>[-&gt; Process.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static final ProcessStartResult start(final String processClass,
                          final String niceName,
                          int uid, int gid, int[] gids,
                          int debugFlags, int mountExternal,
                          int targetSdkVersion,
                          String seInfo,
                          String abi,
                          String instructionSet,
                          String appDataDir,
                          String[] zygoteArgs) {
    try {
         //【见流程2】
        return startViaZygote(processClass, niceName, uid, gid, gids,
                debugFlags, mountExternal, targetSdkVersion, seInfo,
                abi, instructionSet, appDataDir, zygoteArgs);
    } catch (ZygoteStartFailedEx ex) {
        throw new RuntimeException("");
    }
}
</code></pre>
</div>

<h3 id="startviazygote">2. startViaZygote</h3>

<p>[-&gt; Process.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static ProcessStartResult startViaZygote(final String processClass,
                              final String niceName,
                              final int uid, final int gid,
                              final int[] gids,
                              int debugFlags, int mountExternal,
                              int targetSdkVersion,
                              String seInfo,
                              String abi,
                              String instructionSet,
                              String appDataDir,
                              String[] extraArgs)
                              throws ZygoteStartFailedEx {
    synchronized(Process.class) {
        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();

        argsForZygote.add("--runtime-args");
        argsForZygote.add("--setuid=" + uid);
        argsForZygote.add("--setgid=" + gid);
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);

        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
        if (appDataDir != null) {
            argsForZygote.add("--app-data-dir=" + appDataDir);
        }
        argsForZygote.add(processClass);

        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
         //【见流程3】
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
</code></pre>
</div>

<p>该过程主要工作是生成<code class="highlighter-rouge">argsForZygote</code>数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。</p>

<h3 id="zygotesendargsandgetresult">3. zygoteSendArgsAndGetResult</h3>
<p>[-&gt; Process.java]</p>

<p><strong>Step 3-1.</strong> openZygoteSocketIfNeeded</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
    }

    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }

    //当主zygote没能匹配成功，则尝试第二个zygote
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
    }

    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }

    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
</code></pre>
</div>

<p><code class="highlighter-rouge">openZygoteSocketIfNeeded(abi)</code>方法是根据当前的abi来选择与zygote还是zygote64来进行通信。</p>

<p><strong>Step 3-2.</strong> zygoteSendArgsAndGetResult</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static ProcessStartResult zygoteSendArgsAndGetResult(
        ZygoteState zygoteState, ArrayList&lt;String&gt; args)
        throws ZygoteStartFailedEx {
    try {
        //
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;

        writer.write(Integer.toString(args.size()));
        writer.newLine();

        int sz = args.size();
        for (int i = 0; i &lt; sz; i++) {
            String arg = args.get(i);
            if (arg.indexOf('\n') &gt;= 0) {
                throw new ZygoteStartFailedEx(
                        "embedded newlines not allowed");
            }
            writer.write(arg);
            writer.newLine();
        }

        writer.flush();

        ProcessStartResult result = new ProcessStartResult();
        //等待socket服务端（即zygote）返回新创建的进程pid;
        //对于等待时长问题，Google正在考虑此处是否应该有一个timeout，但目前是没有的。
        result.pid = inputStream.readInt();
        if (result.pid &lt; 0) {
            throw new ZygoteStartFailedEx("fork() failed");
        }
        result.usingWrapper = inputStream.readBoolean();
        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
</code></pre>
</div>

<p>这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。</p>

<p>既然system_server进程通过socket向Zygote进程发送消息，这是便会唤醒Zygote进程，来响应socket客户端的请求（即system_server端），接下来的操作便是在Zygote进程中执行。</p>

<h3 id="runselectloop">4. runSelectLoop</h3>

<p>[–&gt;ZygoteInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static void main(String argv[]) {
    try {
        runSelectLoop(abiList);
        ....
    } catch (MethodAndArgsCaller caller) {
        caller.run(); //【见流程13】
    } catch (RuntimeException ex) {
        closeServerSocket();
        throw ex;
    }
}
</code></pre>
</div>

<p>后续会讲到runSelectLoop()方法会抛出异常<code class="highlighter-rouge">MethodAndArgsCaller</code>，从而进入caller.run()方法。</p>

<p>[-&gt; ZygoteInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {
    ...

    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();
    while (true) {
        for (int i = pollFds.length - 1; i &gt;= 0; --i) {
            //采用I/O多路复用机制，当客户端发出连接请求或者数据处理请求时，跳过continue，执行后面的代码
            if ((pollFds[i].revents &amp; POLLIN) == 0) {
                continue;
            }
            if (i == 0) {
                //创建客户端连接
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                //处理客户端数据事务 【见流程5】
                boolean done = peers.get(i).runOnce();
                if (done) {
                    peers.remove(i);
                    fds.remove(i);
                }
            }
        }
    }
}
</code></pre>
</div>

<p>没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒Zygote进程，创建Socket通道ZygoteConnection，然后执行ZygoteConnection的runOnce()方法。</p>

<h3 id="runonce">5. runOnce</h3>

<p>[-&gt; ZygoteConnection.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {

    String args[];
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;

    try {
        //读取socket客户端发送过来的参数列表
        args = readArgumentList(); 
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        closeSocket();
        return true;
    }

    PrintStream newStderr = null;
    if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) {
        newStderr = new PrintStream(new FileOutputStream(descriptors[2]));
    }

    int pid = -1;
    FileDescriptor childPipeFd = null;
    FileDescriptor serverPipeFd = null;

    try {
        //将binder客户端传递过来的参数，解析成Arguments对象格式
        parsedArgs = new Arguments(args);
        ...

        int [] fdsToClose = { -1, -1 };

        FileDescriptor fd = mSocket.getFileDescriptor();
        if (fd != null) {
            fdsToClose[0] = fd.getInt$();
        }

        fd = ZygoteInit.getServerSocketFileDescriptor();
        if (fd != null) {
            fdsToClose[1] = fd.getInt$();
        }
        fd = null;
        //【见流程6】
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,
                parsedArgs.appDataDir);
    } catch (Exception e) {
        ...
    }

    try {
        if (pid == 0) {
            //子进程执行
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            //【见流程7】
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);

            // 不应到达此处，子进程预期的是抛出异常ZygoteInit.MethodAndArgsCaller或者执行exec().
            return true;
        } else {
            //父进程执行
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
</code></pre>
</div>

<h3 id="forkandspecialize">6. forkAndSpecialize</h3>

<p>[-&gt; Zygote.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,
      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
      String instructionSet, String appDataDir) {
    VM_HOOKS.preFork(); //【见流程6-1】
    int pid = nativeForkAndSpecialize(
              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
              instructionSet, appDataDir); //【见流程6-2】
    ...
    VM_HOOKS.postForkCommon(); //【见流程6-3】
    return pid;
}
</code></pre>
</div>

<p>这里<code class="highlighter-rouge">VM_HOOKS</code>是做什么的呢？  这里的<code class="highlighter-rouge">VM_HOOKS = new ZygoteHooks()</code></p>

<p>先说说Zygote进程，如下图：
<img src="/images/android-process/zygote_sub_thread.png" alt="zygote_sub_thread" /></p>

<p>从图中可知Zygote进程有4个子线程，分别是<code class="highlighter-rouge">ReferenceQueueDaemon</code>、<code class="highlighter-rouge">FinalizerDaemon</code>、<code class="highlighter-rouge">FinalizerWatchdogDaemon</code>、<code class="highlighter-rouge">HeapTaskDaemon</code>，此处称为为Zygote的4个Daemon子线程。图中线程名显示的并不完整是由于底层的进程结构体<code class="highlighter-rouge">task_struct</code>是由长度为16的char型数组保存，超过15个字符便会截断。</p>

<p>可能有人会问zygote64进程不是还有system_server，com.android.phone等子线程，怎么会只有4个呢？那是因为这些并不是Zygote子线程，而是Zygote的子进程。在图中用红色圈起来的是进程的<a href="http://gityuan.com/2015/10/11/ps-command/">VSIZE，virtual size)</a>，代表的是进程虚拟地址空间大小。线程与进程的最为本质的区别便是是否共享内存空间，图中VSIZE和Zygote进程相同的才是Zygote的子线程，否则就是Zygote的子进程。</p>

<h4 id="prefork">6-1 preFork</h4>

<p>[-&gt; ZygoteHooks.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code> public void preFork() {
    Daemons.stop(); //停止4个Daemon子线程【见流程6-1-1】
    waitUntilAllThreadsStopped(); //等待所有子线程结束【见流程6-1-2】
    token = nativePreFork(); //完成gc堆的初始化工作【见流程6-1-3】
}
</code></pre>
</div>

<p><strong>Step 6-1-1.</strong> Daemons.stop</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static void stop() {
    HeapTaskDaemon.INSTANCE.stop(); //Java堆整理线程
    ReferenceQueueDaemon.INSTANCE.stop(); //引用队列线程
    FinalizerDaemon.INSTANCE.stop(); //析构线程
    FinalizerWatchdogDaemon.INSTANCE.stop(); //析构监控线程
}
</code></pre>
</div>

<p>此处守护线程Stop方式是先调用目标线程interrrupt()方法，然后再调用目标线程join()方法，等待线程执行完成。</p>

<p><strong>Step 6-1-2.</strong> waitUntilAllThreadsStopped</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static void waitUntilAllThreadsStopped() {
    File tasks = new File("/proc/self/task");
    // 当/proc中线程数大于1，就出让CPU直到只有一个线程，才退出循环
    while (tasks.list().length &gt; 1) {
        Thread.yield(); 
    }
}
</code></pre>
</div>

<p><strong>Step 6-1-3.</strong> nativePreFork</p>

<p>nativePreFork通过JNI最终调用的是dalvik_system_ZygoteHooks.cc中的ZygoteHooks_nativePreFork()方法，如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {
    Runtime* runtime = Runtime::Current();
    CHECK(runtime-&gt;IsZygote()) &lt;&lt; "runtime instance not started with -Xzygote";
    runtime-&gt;PreZygoteFork(); //【见流程6-1-3-1】
    if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {
      Trace::Pause();
    }
    //将线程转换为long型并保存到token，该过程是非安全的
    return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));
}
</code></pre>
</div>

<p><strong>Step 6-1-3-1.</strong> PreZygoteFork</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void Runtime::PreZygoteFork() {
    // 堆的初始化工作。这里就不继续再往下追了，等后续有空专门谢谢关于art虚拟机
    heap_-&gt;PreZygoteFork(); 
}
</code></pre>
</div>

<p>VM_HOOKS.preFork()的主要功能便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），并等待这些线程的停止，初始化gc堆的工作。</p>

<h4 id="nativeforkandspecialize">6-2 nativeForkAndSpecialize</h4>

<p>nativeForkAndSpecialize()通过JNI最终调用的是com_android_internal_os_Zygote.cpp中的
com_android_internal_os_Zygote_nativeForkAndSpecialize()方法，如下：</p>

<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(
    JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,
    jint debug_flags, jobjectArray rlimits,
    jint mount_external, jstring se_info, jstring se_name,
    jintArray fdsToClose, jstring instructionSet, jstring appDataDir) {
    // 将CAP_WAKE_ALARM赋予蓝牙进程
    jlong capabilities = 0;
    if (uid == AID_BLUETOOTH) {
        capabilities |= (1LL &lt;&lt; CAP_WAKE_ALARM);
    }
    //【见流程6-2-1】
    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,
            rlimits, capabilities, capabilities, mount_external, se_info,
            se_name, false, fdsToClose, instructionSet, appDataDir);
}
</code></pre>
</div>

<p><strong>Step 6-2-1.</strong>ForkAndSpecializeCommon</p>

<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,
                                     jint debug_flags, jobjectArray javaRlimits,
                                     jlong permittedCapabilities, jlong effectiveCapabilities,
                                     jint mount_external,
                                     jstring java_se_info, jstring java_se_name,
                                     bool is_system_server, jintArray fdsToClose,
                                     jstring instructionSet, jstring dataDir) {
  //设置子进程的signal信号处理函数
  SetSigChldHandler(); 
  //fork子进程 【见流程6-2-1-1】
  pid_t pid = fork(); 
  if (pid == 0) {
    //进入子进程
    DetachDescriptors(env, fdsToClose); //关闭并清除文件描述符

    if (!is_system_server) {
        //对于非system_server子进程，则创建进程组
        int rc = createProcessGroup(uid, getpid());
    }
    SetGids(env, javaGids); //设置设置group
    SetRLimits(env, javaRlimits); //设置资源limit

    int rc = setresgid(gid, gid, gid);
    rc = setresuid(uid, uid, uid);

    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);
    SetSchedulerPolicy(env); //设置调度策略

     //selinux上下文
    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);

    if (se_info_c_str == NULL &amp;&amp; is_system_server) {
      se_name_c_str = "system_server";
    }
    if (se_info_c_str != NULL) {
      SetThreadName(se_name_c_str); //设置线程名为system_server，方便调试
    }
    //在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为
    UnsetSigChldHandler(); 
    //等价于调用zygote.callPostForkChildHooks() 【见流程6-2-2-1】
    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,
                              is_system_server ? NULL : instructionSet);
    ...

  } else if (pid &gt; 0) {
    //进入父进程，即Zygote进程
  }
  return pid;
}
</code></pre>
</div>

<p><strong>Step 6-2-1-1.</strong> fork()</p>

<p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。</p>

<ul>
  <li>父进程中，fork返回新创建的子进程的pid;</li>
  <li>子进程中，fork返回0；</li>
  <li>当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</li>
</ul>

<p>fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段空间等，当然也包含拷贝fork()代码之后的要执行的代码到新的进程。</p>

<p>下面，说说zygote的fork()过程：</p>

<p><img src="/images/boot/zygote/zygote_fork.jpg" alt="zygote_fork" /></p>

<p>Zygote进程是所有Android进程的母体，包括system_server进程以及App进程都是由Zygote进程孵化而来。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。何为copy on write(写时复制)？当进程A执行修改某个内存数据时（这便是on write时机），才发生缺页中断，从而分配新的内存地址空间（这便是copy操作），对于copy on write是基于内存页，而不是基于进程的。关于Zygote进程的libc、vm、preloaded classes、preloaded resources是如何生成的，可查看另一个文章<a href="http://gityuan.com/2016/02/13/android-zygote/#preload">Android系统启动-zygote篇</a>。</p>

<p><strong>Step 6-2-2-1.</strong> Zygote.callPostForkChildHooks</p>

<p>[-&gt; Zygote.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer,
        String instructionSet) {
    //【见下文】
    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);
}
</code></pre>
</div>

<p>[-&gt; ZygoteHooks.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void postForkChild(int debugFlags, String instructionSet) {
    //【见流程6-2-2-1-1】
    nativePostForkChild(token, debugFlags, instructionSet);
    Math.setRandomSeedInternal(System.currentTimeMillis());
}
</code></pre>
</div>

<p>在这里，设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。</p>

<p><strong>Step 6-2-2-1-1.</strong> nativePostForkChild</p>

<p>最终调用dalvik_system_ZygoteHooks的ZygoteHooks_nativePostForkChild</p>

<p>[-&gt; dalvik_system_ZygoteHooks.cc]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags,
                                            jstring instruction_set) {
    Thread* thread = reinterpret_cast&lt;Thread*&gt;(token);
    //设置新进程的主线程id
    thread-&gt;InitAfterFork();
    ..
    if (instruction_set != nullptr) {
      ScopedUtfChars isa_string(env, instruction_set);
      InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());
      Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;
      if (isa != kNone &amp;&amp; isa != kRuntimeISA) {
        action = Runtime::NativeBridgeAction::kInitialize;
      }
      //【见流程6-2-2-1-1-1】
      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());
    } else {
      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);
    }
}
</code></pre>
</div>

<p><strong>Step 6-2-2-1-1-1.</strong> DidForkFromZygote</p>

<p>[-&gt; Runtime.cc]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) {
  is_zygote_ = false;
  if (is_native_bridge_loaded_) {
    switch (action) {
      case NativeBridgeAction::kUnload:
        UnloadNativeBridge(); //卸载用于跨平台的桥连库
        is_native_bridge_loaded_ = false;
        break;
      case NativeBridgeAction::kInitialize:
        InitializeNativeBridge(env, isa);//初始化用于跨平台的桥连库
        break;
    }
  }
  //创建Java堆处理的线程池
  heap_-&gt;CreateThreadPool();
  //重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。
  heap_-&gt;ResetGcPerformanceInfo();
  if (jit_.get() == nullptr &amp;&amp; jit_options_-&gt;UseJIT()) {
    //当flag被设置，并且还没有创建JIT时，则创建JIT
    CreateJit();
  }
  //设置信号处理函数
  StartSignalCatcher();
  //启动JDWP线程，当命令debuger的flags指定"suspend=y"时，则暂停runtime
  Dbg::StartJdwp();
}
</code></pre>
</div>

<p>关于信号处理过程，其代码位于signal_catcher.cc文件中，后续会单独讲解。</p>

<h4 id="postforkcommon">6-3 postForkCommon</h4>

<p>[-&gt; ZygoteHooks.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void postForkCommon() {
    Daemons.start(); //【见流程6-3-1】
}
</code></pre>
</div>

<p><strong>Step 6-3-1.</strong> Daemons.start</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static void start() {
    ReferenceQueueDaemon.INSTANCE.start();
    FinalizerDaemon.INSTANCE.start();
    FinalizerWatchdogDaemon.INSTANCE.start();
    HeapTaskDaemon.INSTANCE.start();
}
</code></pre>
</div>

<p>VM_HOOKS.postForkCommon的主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。</p>

<h4 id="forkandspecialize-1">forkAndSpecialize小结</h4>

<p>调用关系链：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Zygote.forkAndSpecialize
	ZygoteHooks.preFork
		Daemons.stop
		ZygoteHooks.nativePreFork
			dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork
				Runtime::PreZygoteFork
					heap_-&gt;PreZygoteFork()
	Zygote.nativeForkAndSpecialize
		com_android_internal_os_Zygote.ForkAndSpecializeCommon
			fork()
			Zygote.callPostForkChildHooks
				ZygoteHooks.postForkChild
					dalvik_system_ZygoteHooks.nativePostForkChild
						Runtime::DidForkFromZygote
	ZygoteHooks.postForkCommon
		Daemons.start
</code></pre>
</div>

<p><strong>时序图：</strong></p>

<p>点击查看<a href="http://gityuan.com/images/android-process/fork_and_specialize.jpg">大图</a></p>

<p><img src="/images/android-process/fork_and_specialize.jpg" alt="fork_and_specialize" /></p>

<p>到此App进程已完成了创建的所有工作，接下来开始新创建的App进程的工作。在前面ZygoteConnection.runOnce方法中，zygote进程执行完<code class="highlighter-rouge">forkAndSpecialize()</code>后，新创建的App进程便进入<code class="highlighter-rouge">handleChildProc()</code>方法，下面的操作运行在App进程。</p>

<h3 id="handlechildproc">7. handleChildProc</h3>

<p>[-&gt; ZygoteConnection.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private void handleChildProc(Arguments parsedArgs,
        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)
        throws ZygoteInit.MethodAndArgsCaller {

    //关闭Zygote的socket两端的连接
    closeSocket();
    ZygoteInit.closeServerSocket();

    if (descriptors != null) {
        try {
            Os.dup2(descriptors[0], STDIN_FILENO);
            Os.dup2(descriptors[1], STDOUT_FILENO);
            Os.dup2(descriptors[2], STDERR_FILENO);
            for (FileDescriptor fd: descriptors) {
                IoUtils.closeQuietly(fd);
            }
            newStderr = System.err;
        } catch (ErrnoException ex) {
            Log.e(TAG, "Error reopening stdio", ex);
        }
    }

    if (parsedArgs.niceName != null) {
        //设置进程名
        Process.setArgV0(parsedArgs.niceName);
    }

    if (parsedArgs.invokeWith != null) {
        //据说这是用于检测进程内存泄露或溢出时场景而设计，后续还需要进一步分析。
        WrapperInit.execApplication(parsedArgs.invokeWith,
                parsedArgs.niceName, parsedArgs.targetSdkVersion,
                VMRuntime.getCurrentInstructionSet(),
                pipeFd, parsedArgs.remainingArgs);
    } else {
        //执行目标类的main()方法 【见流程8】
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,
                parsedArgs.remainingArgs, null);
    }
}
</code></pre>
</div>

<h3 id="zygoteinit">8. zygoteInit</h3>

<p>[–&gt;RuntimeInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {

    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "RuntimeInit");
    redirectLogStreams(); //重定向log输出

    commonInit(); // 通用的一些初始化【见流程9】
    nativeZygoteInit(); // zygote初始化 【见流程10】
    applicationInit(targetSdkVersion, argv, classLoader); // 应用初始化【见流程11】
}
</code></pre>
</div>

<h3 id="commoninit">9. commonInit</h3>

<p>[–&gt;RuntimeInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static final void commonInit() {
    // 设置默认的未捕捉异常处理方法
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());

    // 设置市区，中国时区为"Asia/Shanghai"
    TimezoneGetter.setInstance(new TimezoneGetter() {
        @Override
        public String getId() {
            return SystemProperties.get("persist.sys.timezone");
        }
    });
    TimeZone.setDefault(null);

    //重置log配置
    LogManager.getLogManager().reset(); 
    new AndroidConfig(); 

    // 设置默认的HTTP User-agent格式,用于 HttpURLConnection。
    String userAgent = getDefaultUserAgent();
    System.setProperty("http.agent", userAgent);

    // 设置socket的tag，用于网络流量统计
    NetworkManagementSocketTagger.install();
}
</code></pre>
</div>

<p>默认的HTTP User-agent格式，例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code> "Dalvik/1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build/LMY47V)".
</code></pre>
</div>

<h3 id="nativezygoteinit">10. nativeZygoteInit</h3>

<p>nativeZygoteInit()方法在AndroidRuntime.cpp中，进行了jni映射，对应下面的方法。</p>

<p>[–&gt;AndroidRuntime.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime-&gt;onZygoteInit(); //此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的
}
</code></pre>
</div>

<p>[–&gt;app_main.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>virtual void onZygoteInit()
{
    sp&lt;ProcessState&gt; proc = ProcessState::self();
    proc-&gt;startThreadPool(); //启动新binder线程
}
</code></pre>
</div>

<p>ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()，在binder系列文章中的<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>详细这两个方法的执行原理。</p>

<h3 id="applicationinit">11. applicationInit</h3>

<p>[–&gt;RuntimeInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {
    //true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用
    nativeSetExitWithoutCleanup(true);

    //设置虚拟机的内存利用率参数值为0.75
    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);
    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);

    final Arguments args;
    try {
        args = new Arguments(argv); //解析参数
    } catch (IllegalArgumentException ex) {
        Slog.e(TAG, ex.getMessage());
        return;
    }

    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);

    //调用startClass的static方法 main() 【见流程12】
    invokeStaticMain(args.startClass, args.startArgs, classLoader);
}
</code></pre>
</div>

<p>此处args.startClass为”android.app.ActivityThread”。</p>

<h3 id="invokestaticmain">12. invokeStaticMain</h3>

<p>[–&gt;RuntimeInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {
    Class&lt;?&gt; cl;

    try {
        cl = Class.forName(className, true, classLoader);
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
                "Missing class when invoking static main " + className, ex);
    }

    Method m;
    try {
        m = cl.getMethod("main", new Class[] { String[].class });
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException( "Missing static main on " + className, ex);
    } catch (SecurityException ex) {
        throw new RuntimeException(
                "Problem getting static main on " + className, ex);
    }

    int modifiers = m.getModifiers();
    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {
        throw new RuntimeException(
                "Main method is not public and static on " + className);
    }

    //通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。【见流程13】
    throw new ZygoteInit.MethodAndArgsCaller(m, argv);
}
</code></pre>
</div>

<p>invokeStaticMain()方法中抛出的异常<code class="highlighter-rouge">MethodAndArgsCaller</code>，根据前面的【流程4】中可知，下一步进入caller.run()方法。</p>

<h3 id="methodandargscaller">13. MethodAndArgsCaller</h3>

<p>[–&gt;ZygoteInit.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static class MethodAndArgsCaller extends Exception
        implements Runnable {

    public void run() {
        try {
            //根据传递过来的参数，可知此处通过反射机制调用的是ActivityThread.main()方法
            mMethod.invoke(null, new Object[] { mArgs }); 
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            Throwable cause = ex.getCause();
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            } else if (cause instanceof Error) {
                throw (Error) cause;
            }
            throw new RuntimeException(ex);
        }
    }
}
</code></pre>
</div>

<p>到此，总算是进入到了ActivityThread类的main()方法。</p>

<hr />

<h3 id="section-1">总结</h3>

<p>当App第一次启动时或者启动远程Service，即AndroidManifest.xml文件中定义了process:remote属性时，都需要创建进程。比如当用户点击桌面的某个App图标，桌面本身是一个app（即Launcher App），那么Launcher所在进程便是这次创建新进程的发起进程，该通过binder发送消息给system_server进程，该进程承载着整个java framework的核心服务。system_server进程从Process.start开始，执行创建进程，流程图（以进程的视角）如下：</p>

<p>点击查看<a href="http://gityuan.com/images/android-process/process-create.jpg">大图</a></p>

<p><img src="/images/android-process/process-create.jpg" alt="process-create" /></p>

<p>上图中，<code class="highlighter-rouge">system_server</code>进程通过socket IPC通道向<code class="highlighter-rouge">zygote</code>进程通信，<code class="highlighter-rouge">zygote</code>在fork出新进程后由于fork<strong>调用一次，返回两次</strong>，即在zygote进程中调用一次，在zygote进程和子进程中各返回一次，从而能进入子进程来执行代码。该调用流程图的过程：</p>

<ol>
  <li><strong>system_server进程</strong>（<code class="highlighter-rouge">即流程1~3</code>）：通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；</li>
  <li><strong>zygote进程</strong>（<code class="highlighter-rouge">即流程4~6</code>）：接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节（<a href="http://gityuan.com/2016/03/26/app-process-create/#forkandspecialize-1">详见流程6</a>），其具体工作是依次执行下面的3个方法：
    <ul>
      <li>preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；</li>
      <li>nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；</li>
      <li>postForkCommon()：在启动之前被暂停的4个Daemon子线程。</li>
    </ul>
  </li>
  <li><strong>新进程</strong>（<code class="highlighter-rouge">即流程7~13</code>）：进入handleChildProc()方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即Activity.main()方法。</li>
</ol>

<p>再之后的流程，如果是startActivity则将要进入Activity的onCreate/onStart/onResume等生命周期；如果是startService则将要进入Service的onCreate等生命周期。</p>

<hr />

<p>欢迎关注我的<strong><a href="http://weibo.com/gityuan">微博：Gityuan</a></strong>，微信公众号：gityuan，后面会持续分享更多原创技术干货。</p>


                <hr>

                
                <!-- 多说 Share start -->
                </style>
                <div class="ds-share"
                    style="text-align: right"
                    data-thread-key="/2016/03/27/app-process-create"
                    data-title="理解Android进程创建流程"
                    data-url="http://gityuan.com/2016/03/27/app-process-create/"
                    data-images="http://gityuan.com/img/home-bg.jpg"
                    data-content="
  基于Android 6.0的源码剖析， 分析Android进程是如何一步步创建的，本文涉及到的源码：


/frameworks/base/core... | Gityuan博客 " >
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">
                        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                        <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                        <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- 多说 Share end-->
                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/03/20/android-build/" data-toggle="tooltip" data-placement="top" title="理解Android编译命令">
                        Previous<br>
                        <span>理解Android编译命令</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/04/16/kill-signal/" data-toggle="tooltip" data-placement="top" title="理解杀进程的实现原理">
                        Next<br>
                        <span>理解杀进程的实现原理</span>
                        </a>
                    </li>
                    
                </ul>


                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                        data-thread-key="/2016/03/27/app-process-create"
                        data-title="理解Android进程创建流程"
                        data-url="http://gityuan.com/2016/03/27/app-process-create/" >
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#android" title="android" rel="55">
                                    android
                                </a>
                            
        				
                            
                				<a href="/tags/#activity" title="activity" rel="2">
                                    activity
                                </a>
                            
        				
                            
                				<a href="/tags/#service" title="service" rel="2">
                                    service
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#permission" title="permission" rel="2">
                                    permission
                                </a>
                            
        				
                            
                				<a href="/tags/#algorithm" title="algorithm" rel="3">
                                    algorithm
                                </a>
                            
        				
                            
                				<a href="/tags/#web" title="web" rel="2">
                                    web
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#adb" title="adb" rel="2">
                                    adb
                                </a>
                            
        				
                            
                				<a href="/tags/#java" title="java" rel="11">
                                    java
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#反射" title="反射" rel="2">
                                    反射
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#android studio" title="android studio" rel="2">
                                    android studio
                                </a>
                            
        				
                            
                				<a href="/tags/#app" title="app" rel="3">
                                    app
                                </a>
                            
        				
                            
                				<a href="/tags/#performance" title="performance" rel="6">
                                    performance
                                </a>
                            
        				
                            
                				<a href="/tags/#tool" title="tool" rel="6">
                                    tool
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#process" title="process" rel="7">
                                    process
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#memory" title="memory" rel="4">
                                    memory
                                </a>
                            
        				
                            
                				<a href="/tags/#command" title="command" rel="4">
                                    command
                                </a>
                            
        				
                            
                				<a href="/tags/#jvm" title="jvm" rel="6">
                                    jvm
                                </a>
                            
        				
                            
                				<a href="/tags/#binder" title="binder" rel="12">
                                    binder
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#handler" title="handler" rel="3">
                                    handler
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#thread" title="thread" rel="2">
                                    thread
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#boot" title="boot" rel="9">
                                    boot
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#SystemServer" title="SystemServer" rel="2">
                                    SystemServer
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                <!-- 
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://qianduan.guru/">前端外刊评论</a></li>
                    
                        <li><a href="http://lingyu.wang/">天镶的博客</a></li>
                    
                        <li><a href="http://hmqk1995.github.io">Luke的自留地</a></li>
                    
                        <li><a href="http://ebnbin.com/">Ebn's Blog</a></li>
                    
                        <li><a href="http://blog.smdcn.net">SmdCn's Blog</a></li>
                    
                        <li><a href="http://xieminis.me/">解旻的博客</a></li>
                    
                        <li><a href="http://dhong.co">DHong Say</a></li>
                    
                        <li><a href="http://ingf.github.io/">尹峰以为</a></li>
                    
                        <li><a href="http://wepiaofei.github.io/blog/">前端神盾局</a></li>
                    
                </ul>
                 -->
            </div>
        </div>
    </div>
</article>



<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User
    var _user = 'gityuan';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user };
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; <a href="http://gityuan.com">Gityuan</a>  2016
                    <br>
                    Theme by <a href="https://github.com/Huxpro/huxpro.github.io">Hux</a> | Powered by <a href="http://jekyllcn.com/">Jekyll</a>
                </p>
                <!-- 流量统计 -->
								<div style="display:none">
									<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000098804'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000098804%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
								</div>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/ 
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers   
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
