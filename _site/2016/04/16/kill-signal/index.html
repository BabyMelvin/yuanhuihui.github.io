<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="gityuan">
    <meta name="keyword"  content="Android,gityuan,Android技术博客,Android源码分析,袁辉辉">
    <meta name="description" content="Android,gityuan,Android技术博客,Android源码分析,袁辉辉">
    <meta name="baidu-site-verification" content="tgshRgudx0" />
    <link rel="shortcut icon" href="/images/favicon.ico"/>
    <title>理解杀进程的实现原理 - Gityuan博客</title>

    <link rel="canonical" href="http://gityuan.com/2016/04/16/kill-signal/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Gityuan</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Category</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#android" title="android">android</a>
                        
                        <a class="tag" href="/tags/#process" title="process">process</a>
                        
                        <a class="tag" href="/tags/#kill" title="kill">kill</a>
                        
                    </div>
                    <h1>理解杀进程的实现原理</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by Gityuan on April 16, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<blockquote>
  <p>基于Android 6.0的源码剖析， 分析kill进程的实现原理，以及讲讲系统调用(syscall)过程，涉及源码：</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>/framework/base/core/java/android/os/Process.java
/framework/base/core/jni/android_util_Process.cpp
/system/core/libprocessgroup/processgroup.cpp
/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp

/kernel/kernel/signal.c
/Kernel/include/linux/syscalls.h
/kernel/include/uapi/asm-generic/unistd.h(内核空间的系统调用号)
/bionic/libc/kernel/uapi/asm-generic/unistd.h (用户空间的系统调用号)

/art/runtime/Runtime.cc
/art/runtime/signal_catcher.h
/art/runtime/signal_catcher.cc
</code></pre>
</div>

<h3 id="section">概述</h3>

<p>文章<a href="http://gityuan.com/2016/03/26/app-process-create">理解Android进程创建流程</a>，介绍了Android进程创建过程是如何从framework一步步走到虚拟机。本文正好相反则是说说进程是如何被kill的过程。简单说，kill进程其实是通过<strong>发送signal</strong>信号的方式来完成的。创建进程从Process.start开始说起，那么杀进程则相应从Process.killProcess开始讲起。</p>

<h2 id="kill">一、用户态Kill</h2>

<p>在<code class="highlighter-rouge">Process.java</code>文件有3个方法用于杀进程，下面说说这3个方法的具体工作</p>

<div class="highlighter-rouge"><pre class="highlight"><code> Process.killProcess(int pid)
 Process.killProcessQuiet(int pid)
 Process.killProcessGroup(int uid, int pid)
</code></pre>
</div>

<h3 id="killprocess">1.1 killProcess</h3>

<p><strong>Step 1-1-1.  killProcess</strong></p>

<p>[-&gt; Process.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static final void killProcess(int pid) {
    sendSignal(pid, SIGNAL_KILL); //【见Step 1-1-2】
}
</code></pre>
</div>

<p>其中<code class="highlighter-rouge">SIGNAL_KILL = 9</code>，这里的<code class="highlighter-rouge">sendSignal</code>是一个Native方法。在Android系统启动过程中，虚拟机会注册各种framework所需的JNI方法，很多时候查询Java层的native方法所对应的native方法，可在路径<code class="highlighter-rouge">/framework/base/core/jni</code>中找到，在<a href="http://gityuan.com/2016/02/13/android-zygote/#jnistartreg">Zygote篇</a>有介绍JNI方法查看方法。</p>

<p>这里的<code class="highlighter-rouge">sendSignal</code>所对应的JNI方法在android_util_Process.cpp文件的<code class="highlighter-rouge">android_os_Process_SendSignal</code>方法，接下来进入见流程2.</p>

<p><strong>Step 1-1-2.  android_os_Process_sendSignal</strong></p>

<p>[- &gt;android_util_Process.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void android_os_Process_sendSignal(JNIEnv* env, jobject clazz, jint pid, jint sig)
{
    if (pid &gt; 0) {
        //打印Signal信息
        ALOGI("Sending signal. PID: %" PRId32 " SIG: %" PRId32, pid, sig);
        kill(pid, sig);
    }
}
</code></pre>
</div>

<p><code class="highlighter-rouge">sendSignal</code>和<code class="highlighter-rouge">sendSignalQuiet</code>的唯一区别就是在于是否有ALOGI()这一行代码。最终杀进程的实现方法都是调用<code class="highlighter-rouge">kill(pid, sig)</code>方法。</p>

<h3 id="killprocessquiet">1.2 killProcessQuiet</h3>

<p><strong>Step 1-2-1.  killProcessQuiet</strong></p>

<p>[-&gt; Process.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static final void killProcessQuiet(int pid) {
    sendSignalQuiet(pid, SIGNAL_KILL); //【见Step 1-2-2】
}
</code></pre>
</div>

<p><strong>Step 1-2-2.  android_os_Process_sendSignalQuiet</strong></p>

<p>[- &gt;android_util_Process.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void android_os_Process_sendSignalQuiet(JNIEnv* env, jobject clazz, jint pid, jint sig)
{
    if (pid &gt; 0) {
        kill(pid, sig); 
    }
}
</code></pre>
</div>

<p>可见<code class="highlighter-rouge">killProcess</code>和<code class="highlighter-rouge">killProcessQuiet</code>的唯一区别在于是否输出log。最终杀进程的实现方法都是调用<code class="highlighter-rouge">kill(pid, sig)</code>方法。</p>

<p>流程图：</p>

<p><img src="/images/android-process/process-kill-quiet.jpg" alt="process-kill-quiet" /></p>

<h3 id="killprocessgroup">1.3 killProcessGroup</h3>

<p><strong>Step 1-3-1.  killProcessGroup</strong></p>

<p>[-&gt; Process.java]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static final native int killProcessGroup(int uid, int pid);
</code></pre>
</div>

<p>该Native方法所对应的Jni方法如下：</p>

<p><strong>Step 1-3-2.  android_os_Process_killProcessGroup</strong></p>

<p>[- &gt;android_util_Process.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jint android_os_Process_killProcessGroup(JNIEnv* env, jobject clazz, jint uid, jint pid)
{
    return killProcessGroup(uid, pid, SIGKILL);  //【见Step 1-3-3】
}
</code></pre>
</div>

<p><strong>Step 1-3-3.  killProcessGroup</strong></p>

<p>[-&gt; processgroup.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int killProcessGroup(uid_t uid, int initialPid, int signal)
{
    int processes;
    const int sleep_us = 5 * 1000;  // 5ms
    int64_t startTime = android::uptimeMillis();
    int retry = 40;
    // 【见Step 1-3-3-1】
    while ((processes = killProcessGroupOnce(uid, initialPid, signal)) &gt; 0) {
        //当还有进程未被杀死，则重试，最多40次
        if (retry &gt; 0) {
            usleep(sleep_us);
            --retry;
        } else {
            break; //重试40次，仍然没有杀死进程，代表杀进程失败
        }
    }
    if (processes == 0) {
        //移除进程组相应的目录 【见Step 1-3-3-2】
        return removeProcessGroup(uid, initialPid);
    } else {
        return -1;
    }
}
</code></pre>
</div>

<p><strong>Step 1-3-3-1.  killProcessGroupOnce</strong></p>

<p>[-&gt; processgroup.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int killProcessGroupOnce(uid_t uid, int initialPid, int signal)
{
    int processes = 0;
    struct ctx ctx;
    pid_t pid;
    ctx.initialized = false;
    while ((pid = getOneAppProcess(uid, initialPid, &amp;ctx)) &gt;= 0) {
        processes++;
        if (pid == 0) {
            continue; //不应该进入该分支
        }
        int ret = kill(pid, signal); //杀进程组中的进程pid
    }
    if (ctx.initialized) {
        close(ctx.fd);
    }
    //processes代表总共杀死了进程组中的进程个数
    return processes; 
}
</code></pre>
</div>

<p>其中<code class="highlighter-rouge">getOneAppProcess</code>方法的作用是从节点<code class="highlighter-rouge">/acct/uid_&lt;uid&gt;/pid_&lt;pid&gt;/cgroup.procs</code>中获取相应pid，这里是进程，而非线程。故<code class="highlighter-rouge">killProcessGroupOnce</code>的功能是杀掉uid下，跟initialPid同一个进程组的所有进程。也就意味着通过<code class="highlighter-rouge">kill &lt;pid&gt;</code> ，当pid是某个进程的子线程时，那么最终杀的仍是进程。</p>

<p>最终杀进程的实现方法都是调用<code class="highlighter-rouge">kill(pid, sig)</code>方法。</p>

<p><strong>Step 1-3-3-2.  removeProcessGroup</strong></p>

<p>[-&gt; processgroup.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int removeProcessGroup(uid_t uid, int pid)
{
    int ret;
    char path[PROCESSGROUP_MAX_PATH_LEN] = {0};

    //删除目录 /acct/uid_&lt;uid&gt;/pid_&lt;pid&gt;/
    convertUidPidToPath(path, sizeof(path), uid, pid);
    ret = rmdir(path);

    //删除目录 /acct/uid_&lt;uid&gt;/
    convertUidToPath(path, sizeof(path), uid);
    rmdir(path);
    return ret;
}
</code></pre>
</div>

<p>流程图：</p>

<p><img src="/images/android-process/process-kill-group.jpg" alt="process-kill-group" /></p>

<h3 id="section-1">1.4 小结</h3>

<ul>
  <li>Process.killProcess(int pid): 杀pid进程</li>
  <li>Process.killProcessQuiet(int pid)：杀pid进程，且不输出log信息</li>
  <li>Process.killProcessGroup(int uid, int pid)：杀同一个uid下同一进程组下的所有进程</li>
</ul>

<p>以上3个方法，最终杀进程的实现方法都是调用<code class="highlighter-rouge">kill(pid, sig)</code>方法，该方法位于用户空间的Native层，经过系统调用进入到Linux内核的<code class="highlighter-rouge">sys_kill方法</code>。对于杀进程此处的sig=9，其实与大家平时在adb里输入的 <code class="highlighter-rouge">kill -9 &lt;pid&gt;</code> 作用一样。</p>

<p>接下来，进入内核态，看看杀进程的过程。</p>

<h2 id="kill-1">二、内核态Kill</h2>

<h3 id="section-2">2.1. 系统调用</h3>

<p>[-&gt; syscalls.h]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>asmlinkage long sys_kill(int pid, int sig);
</code></pre>
</div>

<p><code class="highlighter-rouge">sys_kill()</code>方法在linux内核中没有直接定义，而是通过宏定义<code class="highlighter-rouge">SYSCALL_DEFINE2</code>的方式来实现的。Android内核（Linux）会为每个syscall分配唯一的系统调用号，当执行系统调用时会根据系统调用号从系统调用表中来查看目标函数的入口地址，在calls.S文件中声明了入口地址信息(这里已经追溯到汇编语言了，就不再介绍)。另外，其中asmlinkage是gcc标签，表明该函数读取的参数位于栈中，而不是寄存器。</p>

<p>那如何查找<code class="highlighter-rouge">sys_kill()</code>所在路径呢？可通过内核空间的<code class="highlighter-rouge">/kernel/include/uapi/asm-generic/unistd.h</code>，会记录</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/* kernel/signal.c */
#define __NR_kill 129
__SYSCALL(__NR_kill, sys_kill)
</code></pre>
</div>

<p>从这里可以推测<code class="highlighter-rouge">sys_kill()</code>的定义在kernel/signal.c文件中，事实也的确如此，接下来进入下面的方法。</p>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_USER;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
	return kill_something_info(sig, &amp;info, pid); //【见流程2.2】
}
</code></pre>
</div>

<p><code class="highlighter-rouge">SYSCALL_DEFINE2</code>是系统调用的宏定义，方法在此处经层层展开，等价于<code class="highlighter-rouge">asmlinkage long sys_kill(int pid, int sig)</code>。关于宏展开细节就不多说了，就说一点<code class="highlighter-rouge">SYSCALL_DEFINE2</code>中的2是指sys_kill方法有两个参数。</p>

<p>关于系统调用流程比较复杂，涉及汇编语言，可以不用知道整个过程，<strong>只需要知道一点：</strong> 用户空间的<code class="highlighter-rouge">kill()</code>最终调用到内核空间signal.c的<code class="highlighter-rouge">kill_something_info()</code>方法就可以。</p>

<h3 id="killsomethinginfo">2.2 kill_something_info</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
{
	int ret;
	if (pid &gt; 0) {
		rcu_read_lock();
		//当pid&gt;0时，则发送给pid所对应的进程【见流程2.3】
		ret = kill_pid_info(sig, info, find_vpid(pid));
		rcu_read_unlock();
		return ret;
	}
	read_lock(&amp;tasklist_lock);
	if (pid != -1) {
		//当pid=0时，则发送给当前进程组；
		//当pid&lt;-1时，则发送给-pid所对应的进程。
		ret = __kill_pgrp_info(sig, info,
				pid ? find_vpid(-pid) : task_pgrp(current));
	} else {
		//当pid=-1时，则发送给所有进程
		int retval = 0, count = 0;
		struct task_struct * p;
		for_each_process(p) {
			if (task_pid_vnr(p) &gt; 1 &amp;&amp;
					!same_thread_group(p, current)) {
				int err = group_send_sig_info(sig, info, p);
				++count;
				if (err != -EPERM)
					retval = err;
			}
		}
		ret = count ? retval : -ESRCH;
	}
	read_unlock(&amp;tasklist_lock);
	return ret;
}
</code></pre>
</div>

<p>功能：</p>

<ul>
  <li>当pid&gt;0 时，则发送给pid所对应的进程；</li>
  <li>当pid=0 时，则发送给当前进程组；</li>
  <li>当pid=-1时，则发送给所有进程；</li>
  <li>当pid&lt;-1时，则发送给-pid所对应的进程。</li>
</ul>

<h3 id="killpidinfo">2.3 kill_pid_info</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)
{
	int error = -ESRCH;
	struct task_struct *p;
	rcu_read_lock();
retry:
	//根据pid查询到task结构体
	p = pid_task(pid, PIDTYPE_PID);
	if (p) {
		error = group_send_sig_info(sig, info, p); //【见流程2.4】
		if (unlikely(error == -ESRCH))
			goto retry;
	}
	rcu_read_unlock();
	return error;
}
</code></pre>
</div>

<h3 id="groupsendsiginfo">2.4 group_send_sig_info</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
{
	int ret;
	rcu_read_lock();
	//检查sig是否合法以及隐私等权限问题
	ret = check_kill_permission(sig, info, p);
	rcu_read_unlock();
	if (!ret &amp;&amp; sig)
		ret = do_send_sig_info(sig, info, p, true); //【见流程2.5】
	return ret;
}
</code></pre>
</div>

<h3 id="dosendsiginfo">2.5 do_send_sig_info</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,
			bool group)
{
	unsigned long flags;
	int ret = -ESRCH;
	if (lock_task_sighand(p, &amp;flags)) {
		ret = send_signal(sig, info, p, group); //【见流程2.6】
		unlock_task_sighand(p, &amp;flags);
	}
	return ret;
}
</code></pre>
</div>

<h3 id="sendsignal">2.6 send_signal</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
			int group)
{
	int from_ancestor_ns = 0;
#ifdef CONFIG_PID_NS
	from_ancestor_ns = si_fromuser(info) &amp;&amp;
			   !task_pid_nr_ns(current, task_active_pid_ns(t));
#endif
	return __send_signal(sig, info, t, group, from_ancestor_ns); //【见流程2.7】
}
</code></pre>
</div>

<h3 id="sendsignal-1">2.7 __send_signal</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,
			int group, int from_ancestor_ns)
{
	struct sigpending *pending;
	struct sigqueue *q;
	int override_rlimit;
	int ret = 0, result;
	assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);
	result = TRACE_SIGNAL_IGNORED;
	if (!prepare_signal(sig, t,
			from_ancestor_ns || (info == SEND_SIG_FORCED)))
		goto ret;
	pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;
	
	result = TRACE_SIGNAL_ALREADY_PENDING;
	if (legacy_queue(pending, sig))
		goto ret;
	result = TRACE_SIGNAL_DELIVERED;
	
	if (info == SEND_SIG_FORCED)
		goto out_set;
	
	if (sig &lt; SIGRTMIN)
		override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= 0);
	else
		override_rlimit = 0;
	q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,
		override_rlimit);
	if (q) {
		list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);
		switch ((unsigned long) info) {
		case (unsigned long) SEND_SIG_NOINFO:
			q-&gt;info.si_signo = sig;
			q-&gt;info.si_errno = 0;
			q-&gt;info.si_code = SI_USER;
			q-&gt;info.si_pid = task_tgid_nr_ns(current,
							task_active_pid_ns(t));
			q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
			break;
		case (unsigned long) SEND_SIG_PRIV:
			q-&gt;info.si_signo = sig;
			q-&gt;info.si_errno = 0;
			q-&gt;info.si_code = SI_KERNEL;
			q-&gt;info.si_pid = 0;
			q-&gt;info.si_uid = 0;
			break;
		default:
			copy_siginfo(&amp;q-&gt;info, info);
			if (from_ancestor_ns)
				q-&gt;info.si_pid = 0;
			break;
		}
		userns_fixup_signal_uid(&amp;q-&gt;info, t);
	} else if (!is_si_special(info)) {
		if (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) {
			result = TRACE_SIGNAL_OVERFLOW_FAIL;
			ret = -EAGAIN;
			goto ret;
		} else {
			result = TRACE_SIGNAL_LOSE_INFO;
		}
	}
out_set:
	//将信号sig传递给正处于监听状态的signalfd
	signalfd_notify(t, sig);
	//向信号集中加入信号sig
	sigaddset(&amp;pending-&gt;signal, sig);
	//完成信号过程，【见流程2.8】
	complete_signal(sig, t, group);
ret:
	trace_signal_generate(sig, info, t, group, result);
	return ret;
}
</code></pre>
</div>

<h3 id="completesignal">2.8 complete_signal</h3>

<p>[-&gt; signal.c]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static void complete_signal(int sig, struct task_struct *p, int group)
{
	struct signal_struct *signal = p-&gt;signal;
	struct task_struct *t;

	//查找能处理该信号的线程
	if (wants_signal(sig, p))
		t = p;
	else if (!group || thread_group_empty(p))
		return;
	else {
		// 递归查找适合的线程
		t = signal-&gt;curr_target;
		while (!wants_signal(sig, t)) {
			t = next_thread(t);
			if (t == signal-&gt;curr_target)
				return;
		}
		signal-&gt;curr_target = t;
	}

	//找到一个能被杀掉的线程，如果这个信号是SIGKILL，则立刻干掉整个线程组
	if (sig_fatal(p, sig) &amp;&amp;
	    !(signal-&gt;flags &amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;&amp;
	    !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;
	    (sig == SIGKILL || !t-&gt;ptrace)) {
		//信号将终结整个线程组
		if (!sig_kernel_coredump(sig)) {
			signal-&gt;flags = SIGNAL_GROUP_EXIT;
			signal-&gt;group_exit_code = sig;
			signal-&gt;group_stop_count = 0;
			t = p;
			//遍历整个线程组，全部结束
			do {
				task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);
				//向信号集中加入信号SIGKILL
				sigaddset(&amp;t-&gt;pending.signal, SIGKILL);
				signal_wake_up(t, 1);
			} while_each_thread(p, t);
			return;
		}
	}

	//该信号处于共享队列里(即将要处理的)。唤醒已选中的目标线程，并将该信号移出队列。
	signal_wake_up(t, sig == SIGKILL);
	return;
}
</code></pre>
</div>

<h3 id="section-3">2.9 小结</h3>

<p>到此Signal信号已发送给目标线程，先用一副图来小结一下上述流程：</p>

<p><img src="/images/android-process/process-kill.jpg" alt="process-kill" /></p>

<p><strong>图解：</strong></p>

<p>流程分为用户空间(User Space)和内核空间（Kernel Space)。从用户空间进入内核空间需要向内核发出syscall，用户空间的程序通过各种syscall来调用用内核空间相应的服务。系统调用是为了让用户空间的程序陷入内核，该陷入动作是由软中断来完成的。用户态的进程进行系统调用后，CPU切换到内核态，开始执行内核函数。<code class="highlighter-rouge">unistd.h</code>文件中定义了所有的系统中断号，用户态程序通过不同的系统调用号来调用不同的内核服务，通过系统调用号从系统调用表中查看到相应的内核服务。</p>

<p>再回到信号，在Process.java中定义了如下3个信号：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static final int SIGNAL_QUIT = 3;  //用于输出线程trace
public static final int SIGNAL_KILL = 9;  //用于杀进程/线程
public static final int SIGNAL_USR1 = 10; //用于强制执行GC
</code></pre>
</div>

<p>对于<code class="highlighter-rouge">kill -9</code>，信号SIGKILL的处理过程，这是因为SIGKILL是不能被忽略同时也不能被捕获，故不会由目标线程的signal Catcher线程来处理，而是由内核直接处理，到此便完成。</p>

<p>但对于信号3和10，则是交由目标进程(art虚拟机)的SignalCatcher线程来捕获完成相应操作的，接下来进入目标线程来处理相应的信号。</p>

<h2 id="signal-catcher">三、Signal Catcher</h2>

<p><strong>实例：</strong></p>

<ul>
  <li><code class="highlighter-rouge">kill -3 &lt;pid&gt;</code>：该pid所在进程的SignalCatcher接收到信号SIGNAL_QUIT，则挂起进程中的所有线程并dump所有线程的状态。</li>
  <li><code class="highlighter-rouge">kill -10 &lt;pid&gt;</code>： 该pid所在进程的SignalCatcher接收到信号SIGNAL_USR1，则触发进程强制执行GC操作。</li>
</ul>

<p>信号SIGNAL_QUIT、SIGNAL_USR1的发送流程由上一节已介绍，对于信号捕获则是由SignalCatcher线程来捕获完成相应操作的。在上一篇文章<a href="http://gityuan.com/2016/03/26/app-process-create/#nativeforkandspecialize">理解Android进程创建流程</a>的【Step 6-2-1】中的<code class="highlighter-rouge">ForkAndSpecializeCommon</code>有涉及到signal相关的操作，接下来说说应用进程在创建过程为信号处理做了哪些准备呢？</p>

<h3 id="forkandspecializecommon">3.1 ForkAndSpecializeCommon</h3>

<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static pid_t ForkAndSpecializeCommon(...) {
    //设置子进程的signal信号处理函数 //【见流程3.2】
    SetSigChldHandler(); 
    pid_t pid = fork(); //fork子进程
    if (pid == 0) {
        //设置子进程的signal信号处理函数为默认函数 //【见流程3.3】
        UnsetSigChldHandler(); 
        //进入虚拟机，执行相关操作【见流程3.4】
        env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,
                              is_system_server ? NULL : instructionSet);
        ...
    } else if (pid &gt; 0) {
        //进入父进程Zygote
    }
    return pid;
}
</code></pre>
</div>

<h3 id="setsigchldhandler">3.2 SetSigChldHandler</h3>

<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static void SetSigChldHandler() {
  struct sigaction sa;
  memset(&amp;sa, 0, sizeof(sa)); //对sa地址内容进行清零操作
  sa.sa_handler = SigChldHandler;
  //安装信号
  int err = sigaction(SIGCHLD, &amp;sa, NULL);
  if (err &lt; 0) {
    ALOGW("Error setting SIGCHLD handler: %s", strerror(errno));
  }
}
</code></pre>
</div>

<p>进程处理某个信号前，需要先在进程中安装此信号，安装过程主要是建立信号值和进程对相应信息值的动作。此处
SIGCHLD=17，代表子进程退出时所相应的操作动作为<code class="highlighter-rouge">SigChldHandler</code>。</p>

<h3 id="unsetsigchldhandler">3.3 UnsetSigChldHandler</h3>

<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static void UnsetSigChldHandler() {
  struct sigaction sa;
  memset(&amp;sa, 0, sizeof(sa));
  sa.sa_handler = SIG_DFL;
  //在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为
  int err = sigaction(SIGCHLD, &amp;sa, NULL);
  if (err &lt; 0) {
    ALOGW("Error unsetting SIGCHLD handler: %s", strerror(errno));
  }
}
</code></pre>
</div>

<h3 id="didforkfromzygote">3.4 DidForkFromZygote</h3>

<p>在文章<a href="http://gityuan.com/2016/03/26/app-process-create/#nativeforkandspecialize">理解Android进程创建流程</a>已详细地说明了此过程，并在小节【Step 6-2-2-1-1-1】中说过后续会单独讲讲信号处理过程，那本文便是补充这个过程</p>

<p>[-&gt; Runtime.cc]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) {
    ...
    //创建Java堆处理的线程池
    heap_-&gt;CreateThreadPool();
    //重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。
    heap_-&gt;ResetGcPerformanceInfo();

    ...
    //启动信号捕获 【见流程3.5】
    StartSignalCatcher();
    //启动JDWP线程，当命令debuger的flags指定"suspend=y"时，则暂停runtime
    Dbg::StartJdwp();
}
</code></pre>
</div>

<h3 id="startsignalcatcher">3.5 StartSignalCatcher</h3>

<p>[-&gt; Runtime.cc]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void Runtime::StartSignalCatcher() {
  if (!is_zygote_) {
    //【见流程3.6】
    signal_catcher_ = new SignalCatcher(stack_trace_file_);
  }
}
</code></pre>
</div>

<p>对于非Zygote进程才会启动SignalCatcher线程。</p>

<h3 id="signalcatcher">3.6 SignalCatcher</h3>

<p>[-&gt; signal_catcher.cc]</p>

<p>创建SignalCatcher对象</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SignalCatcher::SignalCatcher(const std::string&amp; stack_trace_file)
    : stack_trace_file_(stack_trace_file),
      lock_("SignalCatcher lock"),
      cond_("SignalCatcher::cond_", lock_),
      thread_(nullptr) {
  SetHaltFlag(false);
  //通过pthread_create创建一个线程，线程名为"signal catcher thread"; 该线程的启动将关联到Android runtime。
  CHECK_PTHREAD_CALL(pthread_create, (&amp;pthread_, nullptr, &amp;Run, this), "signal catcher thread");
  Thread* self = Thread::Current();
  MutexLock mu(self, lock_);
  while (thread_ == nullptr) {
    cond_.Wait(self);
  }
}
</code></pre>
</div>

<p>SignalCatcher是一个守护线程，用于捕获SIGQUIT、SIGUSR1信号，并采取相应的行为。</p>

<p>Android系统中，由Zygote孵化而来的子进程，包含system_server进程和各种App进程都存在一个SignalCatcher线程，但是Zygote进程本身是没有这个线程的。</p>

<p><img src="/images/android-process/signal_catcher_thread.png" alt="signal_catcher_thread" /></p>

<p>上图是systemui所在进程的部分线程信息，可以看到其中有一个SignalCatcher线程，该线程具体是如何处理信号的呢，请往下继续看。</p>

<h3 id="run">3.7 Run</h3>

<p>[-&gt; signal_catcher.cc]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void* SignalCatcher::Run(void* arg) {
  SignalCatcher* signal_catcher = reinterpret_cast&lt;SignalCatcher*&gt;(arg);
  CHECK(signal_catcher != nullptr);
  Runtime* runtime = Runtime::Current();
  //检查当前线程是否依附到Android Runtime
  CHECK(runtime-&gt;AttachCurrentThread("Signal Catcher", true, runtime-&gt;GetSystemThreadGroup(), !runtime-&gt;IsAotCompiler()));

  Thread* self = Thread::Current();
  DCHECK_NE(self-&gt;GetState(), kRunnable);
  {
    MutexLock mu(self, signal_catcher-&gt;lock_);
    signal_catcher-&gt;thread_ = self;
    signal_catcher-&gt;cond_.Broadcast(self);
  }

  SignalSet signals;
  signals.Add(SIGQUIT); //添加对信号SIGQUIT的处理
  signals.Add(SIGUSR1); //添加对信号SIGUSR1的处理
  while (true) {
    //等待信号到来，这是个阻塞操作
    int signal_number = signal_catcher-&gt;WaitForSignal(self, signals);
    //当信号捕获需要停止时，则取消当前线程跟Android Runtime的关联。
    if (signal_catcher-&gt;ShouldHalt()) {
      runtime-&gt;DetachCurrentThread();
      return nullptr;
    }
    switch (signal_number) {
    case SIGQUIT:
      signal_catcher-&gt;HandleSigQuit(); //输出线程trace
      break;
    case SIGUSR1:
      signal_catcher-&gt;HandleSigUsr1(); //强制GC
      break;
    default:
      LOG(ERROR) &lt;&lt; "Unexpected signal %d" &lt;&lt; signal_number;
      break;
    }
  }
}
</code></pre>
</div>

<p>这个方法中，只有信号SIGQUIT和SIGUSR1的处理过程，并没有信号SIGKILL的处理过程，这是因为SIGKILL是不能被忽略同时也不能被捕获，所以不会出现在Signal Catcher线程。</p>

<h3 id="section-4">3.8 小结</h3>

<p>调用流程：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ForkAndSpecializeCommon
	SetSigChldHandler
	UnsetSigChldHandler
	DidForkFromZygote
		StartSignalCatcher
			SignalCatcher
</code></pre>
</div>

<p>另外，进程被杀后，对于binder的C/S架构，Binder的Server端挂了，Client会收到死亡通告，还会执行各种清理工作。下一篇文章会进一步说明。</p>

<h2 id="section-5">四、实例分析</h2>

<p>注：下面涉及的signal信号log是Gityuan在kernel.c中自行添加的，原生是没有的，仅用于查看和调试使用。</p>

<h3 id="kill--3">4.1  kill -3</h3>

<p>当adb终端输入:<code class="highlighter-rouge">adb -3 10562</code>，则signal信号传递过程如下：</p>

<p><img src="/images/linux/signal/kill_3.png" alt="kill_3" /></p>

<p>其中</p>

<ul>
  <li>9365：adb的终端sh所在进程pid;</li>
  <li>10562：桌面App的进程pid；</li>
  <li>10568：10562进程的子线程(SignalCatcher线程);</li>
  <li>上图由红框圈起来的线程都是进程10562的子线程；</li>
</ul>

<p>流程：</p>

<ol>
  <li>由adb所在进程<code class="highlighter-rouge">9365</code>向进程10562的子线程<code class="highlighter-rouge">10568</code>(SignalCatcher线程)，发送<code class="highlighter-rouge">signal=3</code>信号;该过程需要Art虚拟机参与。</li>
  <li>SignalCatcher线程收到信号3后，再向进程<code class="highlighter-rouge">10562</code>的子线程分别发送<code class="highlighter-rouge">signal=33</code>信号（大于31的signal都是实时信号），用于dump各个子线程的信息。</li>
</ol>

<h3 id="kill--10">4.2  kill -10</h3>

<p>当adb终端输入:<code class="highlighter-rouge">adb -10 10562</code>，则signal信号传递过程如下：</p>

<p><img src="/images/linux/signal/kill_10.png" alt="kill_10" /></p>

<p>其中</p>

<ul>
  <li>9365：adb的终端sh所在进程pid;</li>
  <li>10562：桌面App的进程pid；</li>
</ul>

<p>流程：由adb所在进程<code class="highlighter-rouge">9365</code>向进程<code class="highlighter-rouge">10562</code>，发送<code class="highlighter-rouge">signal=10</code>信号; 该过程需要Art虚拟机参与。</p>

<h3 id="kill--9">4.3  kill -9</h3>

<p>当adb终端输入:<code class="highlighter-rouge">adb -9 8707</code>，则signal信号传递过程如下：</p>

<p><img src="/images/linux/signal/kill_9.png" alt="kill_9" /></p>

<p>其中</p>

<ul>
  <li>7115：adb的终端sh所在进程pid;</li>
  <li>8707：浏览器的进程pid；</li>
  <li>上图由红框圈起来的线程都是进程8707的子线程；</li>
</ul>

<p>流程：由adb所在进程<code class="highlighter-rouge">7115</code>向进程<code class="highlighter-rouge">8707</code>，发送<code class="highlighter-rouge">signal=9</code>信号,判断是SIGKILL信号，则由内核直接处理。</p>

<h3 id="section-6">4.4 小结</h3>

<ul>
  <li>对于<code class="highlighter-rouge">kill -3</code>和<code class="highlighter-rouge">kill -10</code>流程由前面介绍的信号发送和信号处理两个过程，过程中由Art虚拟机来对信号进行相应的处理。</li>
  <li>对于<code class="highlighter-rouge"> kill -9</code>则不同，是由linux底层来完成杀进程的过程，也就是执行到前面讲到第一节中的<a href="http://gityuan.com/2016/04/16/kill-signal/#completesignal">complete_signal()</a>方法后，判断是SIGKILL信号，则由内核直接处理，Art虚拟机压根没机会来处理。</li>
</ul>



                <hr>

                
                <!-- 多说 Share start -->
                </style>
                <div class="ds-share"
                    style="text-align: right"
                    data-thread-key="/2016/04/16/kill-signal"
                    data-title="理解杀进程的实现原理"
                    data-url="http://gityuan.com/2016/04/16/kill-signal/"
                    data-images="http://gityuan.com/img/home-bg.jpg"
                    data-content="
  基于Android 6.0的源码剖析， 分析kill进程的实现原理，以及讲讲系统调用(syscall)过程，涉及源码：


/framework/b... | Gityuan博客 " >
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">
                        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                        <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                        <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- 多说 Share end-->
                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/04/01/android/" data-toggle="tooltip" data-placement="top" title=" Android开篇">
                        Previous<br>
                        <span> Android开篇</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/04/25/how-to-study-android/" data-toggle="tooltip" data-placement="top" title="如何自学Android">
                        Next<br>
                        <span>如何自学Android</span>
                        </a>
                    </li>
                    
                </ul>


                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                        data-thread-key="/2016/04/16/kill-signal"
                        data-title="理解杀进程的实现原理"
                        data-url="http://gityuan.com/2016/04/16/kill-signal/" >
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#android" title="android" rel="56">
                                    android
                                </a>
                            
        				
                            
                				<a href="/tags/#activity" title="activity" rel="2">
                                    activity
                                </a>
                            
        				
                            
                				<a href="/tags/#service" title="service" rel="2">
                                    service
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#permission" title="permission" rel="2">
                                    permission
                                </a>
                            
        				
                            
                				<a href="/tags/#algorithm" title="algorithm" rel="3">
                                    algorithm
                                </a>
                            
        				
                            
                				<a href="/tags/#web" title="web" rel="2">
                                    web
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#adb" title="adb" rel="2">
                                    adb
                                </a>
                            
        				
                            
                				<a href="/tags/#java" title="java" rel="11">
                                    java
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#反射" title="反射" rel="2">
                                    反射
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#android studio" title="android studio" rel="2">
                                    android studio
                                </a>
                            
        				
                            
                				<a href="/tags/#app" title="app" rel="3">
                                    app
                                </a>
                            
        				
                            
                				<a href="/tags/#performance" title="performance" rel="6">
                                    performance
                                </a>
                            
        				
                            
                				<a href="/tags/#tool" title="tool" rel="6">
                                    tool
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#process" title="process" rel="7">
                                    process
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#memory" title="memory" rel="4">
                                    memory
                                </a>
                            
        				
                            
                				<a href="/tags/#command" title="command" rel="4">
                                    command
                                </a>
                            
        				
                            
                				<a href="/tags/#jvm" title="jvm" rel="6">
                                    jvm
                                </a>
                            
        				
                            
                				<a href="/tags/#binder" title="binder" rel="12">
                                    binder
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#handler" title="handler" rel="3">
                                    handler
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#thread" title="thread" rel="2">
                                    thread
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#boot" title="boot" rel="9">
                                    boot
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#SystemServer" title="SystemServer" rel="2">
                                    SystemServer
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                <!-- 
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://qianduan.guru/">前端外刊评论</a></li>
                    
                        <li><a href="http://lingyu.wang/">天镶的博客</a></li>
                    
                        <li><a href="http://hmqk1995.github.io">Luke的自留地</a></li>
                    
                        <li><a href="http://ebnbin.com/">Ebn's Blog</a></li>
                    
                        <li><a href="http://blog.smdcn.net">SmdCn's Blog</a></li>
                    
                        <li><a href="http://xieminis.me/">解旻的博客</a></li>
                    
                        <li><a href="http://dhong.co">DHong Say</a></li>
                    
                        <li><a href="http://ingf.github.io/">尹峰以为</a></li>
                    
                        <li><a href="http://wepiaofei.github.io/blog/">前端神盾局</a></li>
                    
                </ul>
                 -->
            </div>
        </div>
    </div>
</article>



<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User
    var _user = 'gityuan';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user };
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; <a href="http://gityuan.com">Gityuan</a>  2016
                    <br>
                    Theme by <a href="https://github.com/Huxpro/huxpro.github.io">Hux</a> | Powered by <a href="http://jekyllcn.com/">Jekyll</a>
                </p>
                <!-- 流量统计 -->
								<div style="display:none">
									<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000098804'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000098804%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
								</div>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/ 
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers   
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
