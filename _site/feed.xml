<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gityuan</title>
    <description>Android,gityuan,Android技术博客,Android源码分析,袁辉辉</description>
    <link>http://gityuan.com/</link>
    <atom:link href="http://gityuan.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 07 May 2016 13:53:12 +0800</pubDate>
    <lastBuildDate>Sat, 07 May 2016 13:53:12 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>如何自学Android</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;引言：在知乎上回答了 &lt;a href=&quot;https://www.zhihu.com/question/41198536/answer/90560766?from=profile_answer_card&quot;&gt;自学编程一年，压力过大，该怎么办？ - Gityuan 的回答&lt;/a&gt;，之后有不少知乎朋友私信或email给我，希望能讲讲学习Android的心得。已有不少人士写过自学Android相关文章，那么本文则是Gityuan的学习经历，仅供大家参考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看到很多人提问&lt;strong&gt;非科班该如何学习编程&lt;/strong&gt;，其实科班也基本靠自学。有句话叫“师傅领进门修行靠个人”，再厉害的老师能教你的东西都是很有限的，真正的修行还是要靠自己。我本科是学数学的，虽然研究生是计算机专业，但研究生往往是做研究工作，并不会接触编程这么基本的东西，关于编程相关我都是靠自学。对于Android这一块，是参加工作还开始接触，开始自己学习的。&lt;/p&gt;

&lt;p&gt;学习级别，很多人都往往划分成入门、初级、中间..骨灰级等。这里就简单地划分为两级：基础篇和进阶篇。另外，本文涉及到的所有书籍都是&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;Gityuan&lt;/a&gt; 在学习过程中所读过的比较经典的一些书籍，才推荐给大家。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;一、基础篇&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;看书的姿态：&lt;/strong&gt;学习过程往往大家都需要看书，网上一搜，往往会有一大推的书推荐给大家去阅读，面对这么多书，该如何选择，如何阅读的呢，对于同一个层级的书籍选择一本精读，其余的粗读、略读即可，大同小异，对于精读的书籍需要反复的阅读。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;1.1 Java篇&lt;/h3&gt;

&lt;p&gt;Java是Android的基础，建议初学者一定要先学习Java基本知识，进而再学习Android，循序渐进，切莫心急，只有扎实的基础才能建造牢固的上层建筑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java书籍&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Thinking in Java&lt;/strong&gt;： 中文版《Java编程思想 》，这是一本非常经典的Java书籍，很多人都说这个书不适合初学者，我记得自己当初看的第一本Java书便是这本书。看完第一遍对Java有了整体的理解，但很多细节没有完全理解，查了资源又看了第二遍，对Java有了更深地理解。再后来一段时间后，能力也有所提升，再拿起这本书又看了第三遍，发现对面向对象有了更深一步的理解，这本书就是适合反复的阅读。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Effective Java&lt;/strong&gt;：Java进阶书，这本书采用“条目”的方式来展开的，总提出了78条Java具体的建议，对Java平台精妙之处的独到见解，还提供优秀的代码范例。作为Java进阶之书，对Java水平的提升大有裨益。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Java concurrency in Practice&lt;/strong&gt;：中文版《Java并发编程实战》，本书采用循序渐进的讲解方式，从并发编程的基本理论讲起，再讲述了结构化并发应用，性能与测试，最后将显式锁、原子变量、非阻塞算法这些高级主题。对于Java并发这一块算得上是一本很棒的书。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Java Performance&lt;/strong&gt;：中文版《Java性能优化权威指南》，Java之父James Gosling推荐的一本Java应用性能优化的经典之作，包含算法结构、内存、I/O、磁盘使用方式，内容通俗易懂，还介绍了大量的监控和测量工具。关于优化都是属于较深的领域，对Java有一定基础后，很有必要了解看看。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Java虚拟机&lt;/strong&gt;，这是作为进阶Java高手必需有所了解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/index.html&quot;&gt;The Java Language Specification&lt;/a&gt;，官方Java文档（英文版）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se7/html/&quot;&gt;The Java® Virtual Machine Specification&lt;/a&gt;，官方Jvm文档（英文版）&lt;/li&gt;
  &lt;li&gt;深入理解java虚拟机：这是国内关于Java虚拟机讲得非常全面的一本书，从Java GC到Java虚拟机内部实现以及优化策略，作为Java高手非常值得一看的书籍。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的重点是讲如何学习Android，所以姑且把Java基础与进阶的书都放到Android学习的基础篇里。作为Android开发者来说，完全没有必要一开始都对Java理解得那么深，只有要看一两本Java基本书，掌握Java面向对象的思想的核心要义即万物皆为对象，掌握Java基本语法，基本就可以开启Android的学习之路。在后续对Android也有一定理解后，再慢慢不断提升Java和Android水平。&lt;/p&gt;

&lt;p&gt;有朋友私信我觉着这个java书难度有点高，可能是本人在看Java书籍之前，还看过些许C和C++的入门书的缘故，所以看的第一本书《Java编程思想》。如果你真的是零基础，第一次接触编程，想以Java作为自己的入门语言，那么你可以先看看《Java语言程序设计》(基础篇) 或者《Java从入门到精通》，作为初学者险掌握Java基本语法，平时遇到不熟悉的方法，多查看API文档即可，慢慢地就熟悉了。&lt;/p&gt;

&lt;h3 id=&quot;android&quot;&gt;1.2 Android基础篇&lt;/h3&gt;

&lt;p&gt;有了一定的Java基础（不需要精通Java），就可以开始入门Android。建议初学Android者，一定要先搭建自己的开发环境，先准备jdk和Android Studio环境。再看书的过程，一边看知识点一边写示例程序，一来加深印象，二来提高动手能力。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《疯狂Android讲义》：作者李刚，这是我看过的第一个Android书籍，目前有第三版了，我当时看的是第二版基于Android 4.2，书中有大量的实例，记得当时每看完一个实例就跟着敲了一遍，大概花了一周时间把这本书看完并把大部分的实例代码都亲手敲了一遍。&lt;/li&gt;
  &lt;li&gt;《第一行代码》：作者郭霖，网上有不少人都推荐这本书作为Android入门书，但我当时没有看过。这是图灵系列图书，前段时间图灵的编辑看到我的博客gityuan.com，于是联系到我问是否有兴趣出书，便提到郭霖的《第一行代码》也是他们出版社推出的，然后就给我邮寄了一本。我大概扫了一扫这本书，内容的确比较基础，作者文笔不错，书中还穿插了不少打怪涨经验升级的片段，比较风趣，初学者可以看看。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Android的基本书籍，只需一两本即可，没有必要看太多基础书籍，不同能力就该有不同的追求，这里就不再介绍其他基础书籍。 另外，Android开发过程中总是需要各种开发环境、工具的下载，再这里推荐一个不错的网站 &lt;a href=&quot;http://www.androiddevtools.cn/&quot;&gt;AndroidDevTools.cn&lt;/a&gt;，收集整理了 Android开发、设计等相关的各种工具大集合，非常全面，而且速度也不错哦，最重要的不用翻墙就可下载到最新的工具。&lt;/p&gt;

&lt;p&gt;有朋友好奇私信我是否即将要出书了，目前没有相关计划，能力尚不及很多前辈，还需加深内功修为，自己的所学所悟写成博客，还请大家多多指点！&lt;/p&gt;

&lt;h3 id=&quot;android-1&quot;&gt;1.3 Android一手资料&lt;/h3&gt;

&lt;p&gt;何为Android一手资料？那就是&lt;strong&gt;Google官方给出的资料&lt;/strong&gt;，这里往往是英文版的，营养价值极高。其实你只要英文还凑合+翻墙工具，强烈建议你直接看Android官网的资料，千万别被英语所吓倒，因为很多专业名称，大家一看就明白比如Activity/Service等这些代码名称本身就是英语，剩下地都就非常基础语法，不懂可以随时翻译，我一般都是&lt;strong&gt;用Chrome浏览器+Google翻译插件&lt;/strong&gt;，哪里不会点哪里，妈妈再也不用担心我的英语了。&lt;/p&gt;

&lt;p&gt;言归正传，如果你能看完并理解下列的内容，那么你完全可以没有必要再看前面介绍的书籍，并且对于Android已有相当熟悉了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.android.com/intl/zh-cn/index.html&quot;&gt;developer.android.com&lt;/a&gt;：Android开发官网，下面列举常用的资料：
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://developer.android.com/training/index.html&quot;&gt;Android training&lt;/a&gt;：Android培训文档；
        &lt;ul&gt;
          &lt;li&gt;另外由胡凯发起了&lt;a href=&quot;http://hukai.me/android-training-course-in-chinese/index.html&quot;&gt;Android培训课程中文版&lt;/a&gt;；对官方文档进行翻译；&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://developer.android.com/guide/index.html&quot;&gt;Android API指南&lt;/a&gt;：Android组件、Manifest配置文件，动画/图像等相关介绍；&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://developer.android.com/tools/performance/index.html&quot;&gt;Android Tools&lt;/a&gt;：性能、测试、Android Studio等各种工具说明文档；&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://source.android.com/&quot;&gt;source.android.com&lt;/a&gt;：介绍Android开源码相关的内容；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&quot;&gt;Android Performance Patterns&lt;/a&gt;：2015年Google陆续在Youtube上发布的Android性能优化的视频，目前已更新第4季。
    &lt;ul&gt;
      &lt;li&gt;国内Google组织，优酷上发布了相应的 &lt;a href=&quot;http://v.youku.com/v_show/id_XMTUyMTM0MzgyNA==.html?f=26946827&quot;&gt;(中文)Android 性能模式 第四季&lt;/a&gt;；&lt;/li&gt;
      &lt;li&gt;另外由胡凯发起了&lt;a href=&quot;http://hukai.me&quot;&gt;Android性能优化典范中文版文档&lt;/a&gt;；对官方视频进行翻译并整理；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://android-developers.blogspot.com/&quot;&gt;android-developers.blogspot.com&lt;/a&gt;：Android官方博客，有一些比较不错的feature，博客会第一时间呈现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;android-2&quot;&gt;1.4 Android资源整理&lt;/h3&gt;

&lt;p&gt;到这里，那么你已经具备开发App的本领。平时需要自己动手多写写App，另外就是看看别人优秀的App是如何写的，下面列举一些开源库、工具以及App：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://android-arsenal.com/&quot;&gt;android-arsenal.com&lt;/a&gt;：作者&lt;a href=&quot;https://github.com/vbauer&quot;&gt;vbauer&lt;/a&gt;整理收集Github中各种开源库与工具，并提供搜索功能，是国外整理得最全面的库；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Trinea/android-open-project&quot;&gt;Android 开源项目汇总&lt;/a&gt;：作者&lt;a href=&quot;https://github.com/Trinea&quot;&gt;Trinea&lt;/a&gt;整理的各种开源库，是国内整理得最全面的库；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://a.codekk.com/&quot;&gt;codeKK 开源项目源码分析&lt;/a&gt;：从源码的角度，分析Android较流行的优秀开源框架；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.codota.com/&quot;&gt;codota.com&lt;/a&gt;：这是一个代码搜索引擎，收集的是各种API的优秀示例Java代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然还有很多优秀的博客和网站值得推荐… //TODO&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、进阶篇&lt;/h2&gt;

&lt;p&gt;作为程序员，不去阅读源码，仅仅看API文档，只是浮于表象，这是远远不够的。.真正最能锻炼能力的便是直接去阅读源码，不仅限于阅读Andoid系统源码，也包括阅读各种优秀的开源库。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.1 阅读源码的重要性&lt;/h3&gt;

&lt;p&gt;借用Linux之父Linus Torvalds的一句名言：&lt;strong&gt;Read the fucking source code&lt;/strong&gt;。不管是阅读Andoid系统源码还是优秀的开源框架，对能力那都会有一个巨大的提升；首先，能学习到优秀的代码风格和设计思想；能真正做到“知其然，还需知其所以然”；能指导自己更加灵活的使用API，能更加快速地找到系统bug的根源。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.2 阅读源码的准备&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Java基础：上层framework以及App层都是采用Java语法；&lt;/li&gt;
  &lt;li&gt;C/C++基础：Android的jni/native层代码采用C++，Linux 采用C；&lt;/li&gt;
  &lt;li&gt;Linux：Android内核基于Linux的，了解Linux相关知识对深入掌握Android还是很有必要。&lt;/li&gt;
  &lt;li&gt;Git：Android源码采用git和repo进行管理；&lt;/li&gt;
  &lt;li&gt;Make：Android源码采用Make系统编译，源码系统中会看到很多Android.mk之类的文件；&lt;/li&gt;
  &lt;li&gt;Source Insight：这绝对是看源码的神器；可以在Java、C++、C代码之间无缝衔接；&lt;/li&gt;
  &lt;li&gt;Eclipse：熟悉常用快捷键，工欲善其事必先利其器；虽然Source Insight很方便，但由于对Eclipse的熟悉感，对于framework Java层面的代码，我还是更习惯用Eclipse来看，对于Native代码以及linux代码则采用Source Insight来看；&lt;/li&gt;
  &lt;li&gt;Android Studio：这是Google官方支持的App开发环境，关于Android Studiod使用教程；&lt;/li&gt;
  &lt;li&gt;Google Drawings：这是画图工具，Gityuan博客中的文章都是采用Google Drawing完成，比如&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/#binder-1&quot;&gt;Binder开篇&lt;/a&gt;文中的图。&lt;/li&gt;
  &lt;li&gt;StarUML：这是类图，Gityuan博客文章的类图和流程图都是采用StarUML完成，比如&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create/#forkandspecialize-1&quot;&gt;理解Android进程创建流程&lt;/a&gt;文中时序图。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.3 阅读源码的姿态&lt;/h3&gt;

&lt;p&gt;阅读源码绝不是从源码工程按顺序一个个的文件，从首行看到尾行。正确而高效地阅读源码的姿态应该是以某一个主线为起点，从上层往底层，不断地追溯，在各个模块、文件、方法之间来回跳转，反复地阅读，理清整个流程的逻辑。同时带着思考去看源码，尝试去揣测作者的用意，去理解代码的精妙之处，去思考代码可能存在的缺陷，去总结优秀的代码设计思想。下面说说我在阅读Android源码过程常涉及的库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阅读Android源码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面是我以Android开机过程为主线，展开一系列的文章 &lt;a href=&quot;http://gityuan.com/android/&quot;&gt;Android开篇&lt;/a&gt;中的一副流程图，在公司内部分享时我曾多次以下图为流程整个Android架构，如下图：&lt;/p&gt;

&lt;p&gt;点击查看&lt;a href=&quot;http://gityuan.com/images/android-process/android-boot.jpg&quot;&gt;大图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/android-boot.jpg&quot; alt=&quot;process_status&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android系统源码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://android.googlesource.com/&quot;&gt;android.googlesource.com&lt;/a&gt;：Google官方源码，国内无法直接访问，需要翻墙，对于一个程序员来说具备翻墙的能力是非常有必要的。Android源码中包含的库非常之多，下面列举我在看Android源码过程中涉及较多，也是比较常看的一些库：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/packages/apps/&quot;&gt;android/platform/packages/apps&lt;/a&gt;：Android自带的app，比如Email,Camera, Music等，对于应用开发工程师主要关注的目录；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/packages/apps/&quot;&gt;android/platform/frameworks/base&lt;/a&gt;： Java framework，这是framework工程师看得最多的目录；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/native/&quot;&gt;android/platform/frameworks/native&lt;/a&gt;：Native framework;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/art/&quot;&gt;android/platform/art&lt;/a&gt;：Art虚拟机;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/kernel/common/&quot;&gt;android/kernel/common&lt;/a&gt;：Android内核，这是驱动工程师最关注的模块；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/system/core/&quot;&gt;android/platform/system/core&lt;/a&gt; ：核心系统;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/libcore/&quot;&gt;android/platform/libcore&lt;/a&gt;：平台的lib库;
另外，对于无法翻墙的朋友来说，还可以通过上Github通过 &lt;a href=&quot;https://github.com/android&quot;&gt;Android主页&lt;/a&gt; 下载Android源码，这些都是定时从Google官方源码的镜像同步而来的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.4 优秀资源&lt;/h3&gt;

&lt;p&gt;牛顿曾说过：&lt;strong&gt;“如果我看得更远一点的话，是因为我站在巨人的肩膀上”&lt;/strong&gt;，这句话很具有实用价值，看完前面的介绍，你千万不要一上来就一头扎进源码的世界，小心你会进入二次元世界，处于混沌状态，最后崩溃乃至放弃求知之路，一定要合理利用现有的优秀资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android 系统源码分析&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/innost?viewmode=contents&quot;&gt;Innost的专栏&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;邓凡平前辈所写博客，条例有序，覆盖了Android系统大部分内容；&lt;/li&gt;
      &lt;li&gt;《深入理解Android》 （卷I，卷II，卷III）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/8923485&quot;&gt;老罗的Android之旅&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;罗升阳前辈所写博客，从各个层面介绍Android系统；&lt;/li&gt;
      &lt;li&gt;《Android系统源代码情景分析 》&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/android/&quot;&gt;Gityuan源码分析&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;对于邓凡平和罗升阳两位前辈的博客基于Android 2.x或4.x，目前Android已发展到Android 6.0。不管Android如何变化，其核心思维变化并没有很大，所以两位前辈的博客还是很有值得学习和参考的地方。话又说回来，Android经过了几个大版本的迭代，无论是从代码结构还是整体逻辑仍有不少变化。故博主计划写一关于Android 6.0源码系列的博文。&lt;/li&gt;
      &lt;li&gt;Gityuan作为Android界新秀，能力尚不及很多前辈，但有一颗乐于分享的心，有一份痴于Android的品质，有一种坚持的态度，已经并一直还在努力奋斗的道路上…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.5 进阶书籍&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;深入理解Linux内核&lt;/li&gt;
  &lt;li&gt;深入Linux内核架构&lt;/li&gt;
  &lt;li&gt;Linux内核设计与实现&lt;/li&gt;
  &lt;li&gt;Linux设备驱动程序&lt;/li&gt;
  &lt;li&gt;重构 改善既有代码的设计&lt;/li&gt;
  &lt;li&gt;编程珠玑 （卷1, 卷2）&lt;/li&gt;
  &lt;li&gt;设计模式&lt;/li&gt;
  &lt;li&gt;设计模式之禅&lt;/li&gt;
  &lt;li&gt;人月神话&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前4本书都是关于Linux，如果你不是需要从事Linux相关开发，只想提升对Android整体的理解，那么只需看一到两本，对Linux的进程、内存、IO以及驱动有所了解，对CPU调度、进程间通信有所熟悉就基本可以。另外，优秀的书还有很多，这里只介绍/列举我看过的书，目前还在看一些优秀的书，后续再更新。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;三、其他&lt;/h2&gt;

&lt;p&gt;最后，再说说关于学习编程的番外篇：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;好奇心比雄心走得更远：很多人对未来空有满腔的雄心壮志，往往不如对技术要有一份好奇心，一份探索欲，再加上一份执着的人。&lt;/li&gt;
  &lt;li&gt;要有open的心态：曾经的我也只是把自己的所思所得都放入自己的云笔记，很少整理，这其实不利于技术发展，有空应该多整理自己零散的知识点，觉得不错的点可以拿出来写成博客，那是对能力的又一层提升。另外，在低头做技术的同时，还应该有空抬头看世界，不能闭门造车。&lt;/li&gt;
  &lt;li&gt;天道酬勤：学历只能代表过去，能力代表现在，潜力代表未来！ 你不把自己逼一把，你压根不知道自己有多优秀，只要努力去学习，去挖掘潜力，进而提升自我技术修为，未来不再是梦！共勉之！&lt;/li&gt;
  &lt;li&gt;解决问题的方式：遇到问题，一定要先尝试自己解决，解决不了再请教他人。这是对自己的一个锻炼，也是对他人的一个尊重，可以有多种途径自行搜索：
    &lt;ul&gt;
      &lt;li&gt;百度一下，很多时候还是能有所帮助的，不要过分强调google，完全抛弃百度，毕竟中文看起来比较快；&lt;/li&gt;
      &lt;li&gt;先中文关键词google一下；再英文关键词google一下；&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;stackoverflow.com&lt;/a&gt;、&lt;a href=&quot;http://zhihu.com&quot;&gt;知乎&lt;/a&gt;等技术问答网站内直接搜索；&lt;/li&gt;
      &lt;li&gt;查看官方文档；&lt;/li&gt;
      &lt;li&gt;如果有源码，尝试直接看源码，看能否解决；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有空可以多逛逛github，多看看Google官方文档，多关注社区，定会收获不少；&lt;/li&gt;
  &lt;li&gt;当然，最最重要的是能静得下心，持之以恒地专研技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;欢迎关注我的微博：&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;Gityuan&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Android全栈工程师：上至能写App，中间能改framework和Native代码，下至能调驱动，整体上解决性能/稳定性/功耗问题。这是我对自己的追求，并一直在努力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果觉得不错，可以到我的知乎文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20708611&quot;&gt;如何自学Android&lt;/a&gt;点个赞支持。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Apr 2016 06:10:22 +0800</pubDate>
        <link>http://gityuan.com/2016/04/25/how-to-study-android/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/04/25/how-to-study-android/</guid>
        
        <category>android</category>
        
        <category>自学编程</category>
        
        
      </item>
    
      <item>
        <title>理解杀进程的实现原理</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;基于Android 6.0的源码剖析， 分析kill进程的实现原理，以及讲讲系统调用(syscall)过程，涉及源码：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/framework/base/core/java/android/os/Process.java
/framework/base/core/jni/android_util_Process.cpp
/system/core/libprocessgroup/processgroup.cpp
/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp

/kernel/kernel/signal.c
/Kernel/include/linux/syscalls.h
/kernel/include/uapi/asm-generic/unistd.h(内核空间的系统调用号)
/bionic/libc/kernel/uapi/asm-generic/unistd.h (用户空间的系统调用号)

/art/runtime/Runtime.cc
/art/runtime/signal_catcher.h
/art/runtime/signal_catcher.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;文章&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create&quot;&gt;理解Android进程创建流程&lt;/a&gt;，介绍了Android进程创建过程是如何从framework一步步走到虚拟机。本文正好相反则是说说进程是如何被kill的过程。简单说，kill进程其实是通过&lt;strong&gt;发送signal&lt;/strong&gt;信号的方式来完成的。创建进程从Process.start开始说起，那么杀进程则相应从Process.killProcess开始讲起。&lt;/p&gt;

&lt;h2 id=&quot;kill&quot;&gt;一、用户态Kill&lt;/h2&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Process.java&lt;/code&gt;文件有3个方法用于杀进程，下面说说这3个方法的具体工作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Process.killProcess(int pid)
 Process.killProcessQuiet(int pid)
 Process.killProcessGroup(int uid, int pid)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;killprocess&quot;&gt;1.1 killProcess&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Step 1-1-1.  killProcess&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[-&amp;gt; Process.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final void killProcess(int pid) {
    sendSignal(pid, SIGNAL_KILL); //【见Step 1-1-2】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGNAL_KILL = 9&lt;/code&gt;，这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;sendSignal&lt;/code&gt;是一个Native方法。在Android系统启动过程中，虚拟机会注册各种framework所需的JNI方法，很多时候查询Java层的native方法所对应的native方法，可在路径&lt;code class=&quot;highlighter-rouge&quot;&gt;/framework/base/core/jni&lt;/code&gt;中找到，在&lt;a href=&quot;http://gityuan.com/2016/02/13/android-zygote/#jnistartreg&quot;&gt;Zygote篇&lt;/a&gt;有介绍JNI方法查看方法。&lt;/p&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;sendSignal&lt;/code&gt;所对应的JNI方法在android_util_Process.cpp文件的&lt;code class=&quot;highlighter-rouge&quot;&gt;android_os_Process_SendSignal&lt;/code&gt;方法，接下来进入见流程2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1-1-2.  android_os_Process_sendSignal&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[- &amp;gt;android_util_Process.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void android_os_Process_sendSignal(JNIEnv* env, jobject clazz, jint pid, jint sig)
{
    if (pid &amp;gt; 0) {
        //打印Signal信息
        ALOGI(&quot;Sending signal. PID: %&quot; PRId32 &quot; SIG: %&quot; PRId32, pid, sig);
        kill(pid, sig);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sendSignal&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;sendSignalQuiet&lt;/code&gt;的唯一区别就是在于是否有ALOGI()这一行代码。最终杀进程的实现方法都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;kill(pid, sig)&lt;/code&gt;方法。&lt;/p&gt;

&lt;h3 id=&quot;killprocessquiet&quot;&gt;1.2 killProcessQuiet&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Step 1-2-1.  killProcessQuiet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[-&amp;gt; Process.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final void killProcessQuiet(int pid) {
    sendSignalQuiet(pid, SIGNAL_KILL); //【见Step 1-2-2】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 1-2-2.  android_os_Process_sendSignalQuiet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[- &amp;gt;android_util_Process.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void android_os_Process_sendSignalQuiet(JNIEnv* env, jobject clazz, jint pid, jint sig)
{
    if (pid &amp;gt; 0) {
        kill(pid, sig); 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可见&lt;code class=&quot;highlighter-rouge&quot;&gt;killProcess&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;killProcessQuiet&lt;/code&gt;的唯一区别在于是否输出log。最终杀进程的实现方法都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;kill(pid, sig)&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/process-kill-quiet.jpg&quot; alt=&quot;process-kill-quiet&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;killprocessgroup&quot;&gt;1.3 killProcessGroup&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Step 1-3-1.  killProcessGroup&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[-&amp;gt; Process.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final native int killProcessGroup(int uid, int pid);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该Native方法所对应的Jni方法如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1-3-2.  android_os_Process_killProcessGroup&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[- &amp;gt;android_util_Process.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jint android_os_Process_killProcessGroup(JNIEnv* env, jobject clazz, jint uid, jint pid)
{
    return killProcessGroup(uid, pid, SIGKILL);  //【见Step 1-3-3】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 1-3-3.  killProcessGroup&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[-&amp;gt; processgroup.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int killProcessGroup(uid_t uid, int initialPid, int signal)
{
    int processes;
    const int sleep_us = 5 * 1000;  // 5ms
    int64_t startTime = android::uptimeMillis();
    int retry = 40;
    // 【见Step 1-3-3-1】
    while ((processes = killProcessGroupOnce(uid, initialPid, signal)) &amp;gt; 0) {
        //当还有进程未被杀死，则重试，最多40次
        if (retry &amp;gt; 0) {
            usleep(sleep_us);
            --retry;
        } else {
            break; //重试40次，仍然没有杀死进程，代表杀进程失败
        }
    }
    if (processes == 0) {
        //移除进程组相应的目录 【见Step 1-3-3-2】
        return removeProcessGroup(uid, initialPid);
    } else {
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 1-3-3-1.  killProcessGroupOnce&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[-&amp;gt; processgroup.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int killProcessGroupOnce(uid_t uid, int initialPid, int signal)
{
    int processes = 0;
    struct ctx ctx;
    pid_t pid;
    ctx.initialized = false;
    while ((pid = getOneAppProcess(uid, initialPid, &amp;amp;ctx)) &amp;gt;= 0) {
        processes++;
        if (pid == 0) {
            continue; //不应该进入该分支
        }
        int ret = kill(pid, signal); //杀进程组中的进程pid
    }
    if (ctx.initialized) {
        close(ctx.fd);
    }
    //processes代表总共杀死了进程组中的进程个数
    return processes; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;getOneAppProcess&lt;/code&gt;方法的作用是从节点&lt;code class=&quot;highlighter-rouge&quot;&gt;/acct/uid_&amp;lt;uid&amp;gt;/pid_&amp;lt;pid&amp;gt;/cgroup.procs&lt;/code&gt;中获取相应pid，这里是进程，而非线程。故&lt;code class=&quot;highlighter-rouge&quot;&gt;killProcessGroupOnce&lt;/code&gt;的功能是杀掉uid下，跟initialPid同一个进程组的所有进程。也就意味着通过&lt;code class=&quot;highlighter-rouge&quot;&gt;kill &amp;lt;pid&amp;gt;&lt;/code&gt; ，当pid是某个进程的子线程时，那么最终杀的仍是进程。&lt;/p&gt;

&lt;p&gt;最终杀进程的实现方法都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;kill(pid, sig)&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1-3-3-2.  removeProcessGroup&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[-&amp;gt; processgroup.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int removeProcessGroup(uid_t uid, int pid)
{
    int ret;
    char path[PROCESSGROUP_MAX_PATH_LEN] = {0};

    //删除目录 /acct/uid_&amp;lt;uid&amp;gt;/pid_&amp;lt;pid&amp;gt;/
    convertUidPidToPath(path, sizeof(path), uid, pid);
    ret = rmdir(path);

    //删除目录 /acct/uid_&amp;lt;uid&amp;gt;/
    convertUidToPath(path, sizeof(path), uid);
    rmdir(path);
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/process-kill-group.jpg&quot; alt=&quot;process-kill-group&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.4 小结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Process.killProcess(int pid): 杀pid进程&lt;/li&gt;
  &lt;li&gt;Process.killProcessQuiet(int pid)：杀pid进程，且不输出log信息&lt;/li&gt;
  &lt;li&gt;Process.killProcessGroup(int uid, int pid)：杀同一个uid下同一进程组下的所有进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上3个方法，最终杀进程的实现方法都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;kill(pid, sig)&lt;/code&gt;方法，该方法位于用户空间的Native层，经过系统调用进入到Linux内核的&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_kill方法&lt;/code&gt;。对于杀进程此处的sig=9，其实与大家平时在adb里输入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill -9 &amp;lt;pid&amp;gt;&lt;/code&gt; 作用一样。&lt;/p&gt;

&lt;p&gt;接下来，进入内核态，看看杀进程的过程。&lt;/p&gt;

&lt;h2 id=&quot;kill-1&quot;&gt;二、内核态Kill&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.1. 系统调用&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; syscalls.h]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;asmlinkage long sys_kill(int pid, int sig);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_kill()&lt;/code&gt;方法在linux内核中没有直接定义，而是通过宏定义&lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL_DEFINE2&lt;/code&gt;的方式来实现的。Android内核（Linux）会为每个syscall分配唯一的系统调用号，当执行系统调用时会根据系统调用号从系统调用表中来查看目标函数的入口地址，在calls.S文件中声明了入口地址信息(这里已经追溯到汇编语言了，就不再介绍)。另外，其中asmlinkage是gcc标签，表明该函数读取的参数位于栈中，而不是寄存器。&lt;/p&gt;

&lt;p&gt;那如何查找&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_kill()&lt;/code&gt;所在路径呢？可通过内核空间的&lt;code class=&quot;highlighter-rouge&quot;&gt;/kernel/include/uapi/asm-generic/unistd.h&lt;/code&gt;，会记录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* kernel/signal.c */
#define __NR_kill 129
__SYSCALL(__NR_kill, sys_kill)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从这里可以推测&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_kill()&lt;/code&gt;的定义在kernel/signal.c文件中，事实也的确如此，接下来进入下面的方法。&lt;/p&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_USER;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
	return kill_something_info(sig, &amp;amp;info, pid); //【见流程2.2】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL_DEFINE2&lt;/code&gt;是系统调用的宏定义，方法在此处经层层展开，等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;asmlinkage long sys_kill(int pid, int sig)&lt;/code&gt;。关于宏展开细节就不多说了，就说一点&lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL_DEFINE2&lt;/code&gt;中的2是指sys_kill方法有两个参数。&lt;/p&gt;

&lt;p&gt;关于系统调用流程比较复杂，涉及汇编语言，可以不用知道整个过程，&lt;strong&gt;只需要知道一点：&lt;/strong&gt; 用户空间的&lt;code class=&quot;highlighter-rouge&quot;&gt;kill()&lt;/code&gt;最终调用到内核空间signal.c的&lt;code class=&quot;highlighter-rouge&quot;&gt;kill_something_info()&lt;/code&gt;方法就可以。&lt;/p&gt;

&lt;h3 id=&quot;killsomethinginfo&quot;&gt;2.2 kill_something_info&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
{
	int ret;
	if (pid &amp;gt; 0) {
		rcu_read_lock();
		//当pid&amp;gt;0时，则发送给pid所对应的进程【见流程2.3】
		ret = kill_pid_info(sig, info, find_vpid(pid));
		rcu_read_unlock();
		return ret;
	}
	read_lock(&amp;amp;tasklist_lock);
	if (pid != -1) {
		//当pid=0时，则发送给当前进程组；
		//当pid&amp;lt;-1时，则发送给-pid所对应的进程。
		ret = __kill_pgrp_info(sig, info,
				pid ? find_vpid(-pid) : task_pgrp(current));
	} else {
		//当pid=-1时，则发送给所有进程
		int retval = 0, count = 0;
		struct task_struct * p;
		for_each_process(p) {
			if (task_pid_vnr(p) &amp;gt; 1 &amp;amp;&amp;amp;
					!same_thread_group(p, current)) {
				int err = group_send_sig_info(sig, info, p);
				++count;
				if (err != -EPERM)
					retval = err;
			}
		}
		ret = count ? retval : -ESRCH;
	}
	read_unlock(&amp;amp;tasklist_lock);
	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当pid&amp;gt;0 时，则发送给pid所对应的进程；&lt;/li&gt;
  &lt;li&gt;当pid=0 时，则发送给当前进程组；&lt;/li&gt;
  &lt;li&gt;当pid=-1时，则发送给所有进程；&lt;/li&gt;
  &lt;li&gt;当pid&amp;lt;-1时，则发送给-pid所对应的进程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;killpidinfo&quot;&gt;2.3 kill_pid_info&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)
{
	int error = -ESRCH;
	struct task_struct *p;
	rcu_read_lock();
retry:
	//根据pid查询到task结构体
	p = pid_task(pid, PIDTYPE_PID);
	if (p) {
		error = group_send_sig_info(sig, info, p); //【见流程2.4】
		if (unlikely(error == -ESRCH))
			goto retry;
	}
	rcu_read_unlock();
	return error;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;groupsendsiginfo&quot;&gt;2.4 group_send_sig_info&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
{
	int ret;
	rcu_read_lock();
	//检查sig是否合法以及隐私等权限问题
	ret = check_kill_permission(sig, info, p);
	rcu_read_unlock();
	if (!ret &amp;amp;&amp;amp; sig)
		ret = do_send_sig_info(sig, info, p, true); //【见流程2.5】
	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;dosendsiginfo&quot;&gt;2.5 do_send_sig_info&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,
			bool group)
{
	unsigned long flags;
	int ret = -ESRCH;
	if (lock_task_sighand(p, &amp;amp;flags)) {
		ret = send_signal(sig, info, p, group); //【见流程2.6】
		unlock_task_sighand(p, &amp;amp;flags);
	}
	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sendsignal&quot;&gt;2.6 send_signal&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
			int group)
{
	int from_ancestor_ns = 0;
#ifdef CONFIG_PID_NS
	from_ancestor_ns = si_fromuser(info) &amp;amp;&amp;amp;
			   !task_pid_nr_ns(current, task_active_pid_ns(t));
#endif
	return __send_signal(sig, info, t, group, from_ancestor_ns); //【见流程2.7】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sendsignal-1&quot;&gt;2.7 __send_signal&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,
			int group, int from_ancestor_ns)
{
	struct sigpending *pending;
	struct sigqueue *q;
	int override_rlimit;
	int ret = 0, result;
	assert_spin_locked(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock);
	result = TRACE_SIGNAL_IGNORED;
	if (!prepare_signal(sig, t,
			from_ancestor_ns || (info == SEND_SIG_FORCED)))
		goto ret;
	pending = group ? &amp;amp;t-&amp;gt;signal-&amp;gt;shared_pending : &amp;amp;t-&amp;gt;pending;
	
	result = TRACE_SIGNAL_ALREADY_PENDING;
	if (legacy_queue(pending, sig))
		goto ret;
	result = TRACE_SIGNAL_DELIVERED;
	
	if (info == SEND_SIG_FORCED)
		goto out_set;
	
	if (sig &amp;lt; SIGRTMIN)
		override_rlimit = (is_si_special(info) || info-&amp;gt;si_code &amp;gt;= 0);
	else
		override_rlimit = 0;
	q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,
		override_rlimit);
	if (q) {
		list_add_tail(&amp;amp;q-&amp;gt;list, &amp;amp;pending-&amp;gt;list);
		switch ((unsigned long) info) {
		case (unsigned long) SEND_SIG_NOINFO:
			q-&amp;gt;info.si_signo = sig;
			q-&amp;gt;info.si_errno = 0;
			q-&amp;gt;info.si_code = SI_USER;
			q-&amp;gt;info.si_pid = task_tgid_nr_ns(current,
							task_active_pid_ns(t));
			q-&amp;gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
			break;
		case (unsigned long) SEND_SIG_PRIV:
			q-&amp;gt;info.si_signo = sig;
			q-&amp;gt;info.si_errno = 0;
			q-&amp;gt;info.si_code = SI_KERNEL;
			q-&amp;gt;info.si_pid = 0;
			q-&amp;gt;info.si_uid = 0;
			break;
		default:
			copy_siginfo(&amp;amp;q-&amp;gt;info, info);
			if (from_ancestor_ns)
				q-&amp;gt;info.si_pid = 0;
			break;
		}
		userns_fixup_signal_uid(&amp;amp;q-&amp;gt;info, t);
	} else if (!is_si_special(info)) {
		if (sig &amp;gt;= SIGRTMIN &amp;amp;&amp;amp; info-&amp;gt;si_code != SI_USER) {
			result = TRACE_SIGNAL_OVERFLOW_FAIL;
			ret = -EAGAIN;
			goto ret;
		} else {
			result = TRACE_SIGNAL_LOSE_INFO;
		}
	}
out_set:
	//将信号sig传递给正处于监听状态的signalfd
	signalfd_notify(t, sig);
	//向信号集中加入信号sig
	sigaddset(&amp;amp;pending-&amp;gt;signal, sig);
	//完成信号过程，【见流程2.8】
	complete_signal(sig, t, group);
ret:
	trace_signal_generate(sig, info, t, group, result);
	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;completesignal&quot;&gt;2.8 complete_signal&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal.c]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void complete_signal(int sig, struct task_struct *p, int group)
{
	struct signal_struct *signal = p-&amp;gt;signal;
	struct task_struct *t;

	//查找能处理该信号的线程
	if (wants_signal(sig, p))
		t = p;
	else if (!group || thread_group_empty(p))
		return;
	else {
		// 递归查找适合的线程
		t = signal-&amp;gt;curr_target;
		while (!wants_signal(sig, t)) {
			t = next_thread(t);
			if (t == signal-&amp;gt;curr_target)
				return;
		}
		signal-&amp;gt;curr_target = t;
	}

	//找到一个能被杀掉的线程，如果这个信号是SIGKILL，则立刻干掉整个线程组
	if (sig_fatal(p, sig) &amp;amp;&amp;amp;
	    !(signal-&amp;gt;flags &amp;amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;amp;&amp;amp;
	    !sigismember(&amp;amp;t-&amp;gt;real_blocked, sig) &amp;amp;&amp;amp;
	    (sig == SIGKILL || !t-&amp;gt;ptrace)) {
		//信号将终结整个线程组
		if (!sig_kernel_coredump(sig)) {
			signal-&amp;gt;flags = SIGNAL_GROUP_EXIT;
			signal-&amp;gt;group_exit_code = sig;
			signal-&amp;gt;group_stop_count = 0;
			t = p;
			//遍历整个线程组，全部结束
			do {
				task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);
				//向信号集中加入信号SIGKILL
				sigaddset(&amp;amp;t-&amp;gt;pending.signal, SIGKILL);
				signal_wake_up(t, 1);
			} while_each_thread(p, t);
			return;
		}
	}

	//该信号处于共享队列里(即将要处理的)。唤醒已选中的目标线程，并将该信号移出队列。
	signal_wake_up(t, sig == SIGKILL);
	return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.9 小结&lt;/h3&gt;

&lt;p&gt;到此Signal信号已发送给目标线程，先用一副图来小结一下上述流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/process-kill.jpg&quot; alt=&quot;process-kill&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图解：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流程分为用户空间(User Space)和内核空间（Kernel Space)。从用户空间进入内核空间需要向内核发出syscall，用户空间的程序通过各种syscall来调用用内核空间相应的服务。系统调用是为了让用户空间的程序陷入内核，该陷入动作是由软中断来完成的。用户态的进程进行系统调用后，CPU切换到内核态，开始执行内核函数。&lt;code class=&quot;highlighter-rouge&quot;&gt;unistd.h&lt;/code&gt;文件中定义了所有的系统中断号，用户态程序通过不同的系统调用号来调用不同的内核服务，通过系统调用号从系统调用表中查看到相应的内核服务。&lt;/p&gt;

&lt;p&gt;再回到信号，在Process.java中定义了如下3个信号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final int SIGNAL_QUIT = 3;  //用于输出线程trace
public static final int SIGNAL_KILL = 9;  //用于杀进程/线程
public static final int SIGNAL_USR1 = 10; //用于强制执行GC
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -9&lt;/code&gt;，信号SIGKILL的处理过程，这是因为SIGKILL是不能被忽略同时也不能被捕获，故不会由目标线程的signal Catcher线程来处理，而是由内核直接处理，到此便完成。&lt;/p&gt;

&lt;p&gt;但对于信号3和10，则是交由目标进程(art虚拟机)的SignalCatcher线程来捕获完成相应操作的，接下来进入目标线程来处理相应的信号。&lt;/p&gt;

&lt;h2 id=&quot;signal-catcher&quot;&gt;三、Signal Catcher&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -3 &amp;lt;pid&amp;gt;&lt;/code&gt;：该pid所在进程的SignalCatcher接收到信号SIGNAL_QUIT，则挂起进程中的所有线程并dump所有线程的状态。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -10 &amp;lt;pid&amp;gt;&lt;/code&gt;： 该pid所在进程的SignalCatcher接收到信号SIGNAL_USR1，则触发进程强制执行GC操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;信号SIGNAL_QUIT、SIGNAL_USR1的发送流程由上一节已介绍，对于信号捕获则是由SignalCatcher线程来捕获完成相应操作的。在上一篇文章&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create/#nativeforkandspecialize&quot;&gt;理解Android进程创建流程&lt;/a&gt;的【Step 6-2-1】中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ForkAndSpecializeCommon&lt;/code&gt;有涉及到signal相关的操作，接下来说说应用进程在创建过程为信号处理做了哪些准备呢？&lt;/p&gt;

&lt;h3 id=&quot;forkandspecializecommon&quot;&gt;3.1 ForkAndSpecializeCommon&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; com_android_internal_os_Zygote.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static pid_t ForkAndSpecializeCommon(...) {
    //设置子进程的signal信号处理函数 //【见流程3.2】
    SetSigChldHandler(); 
    pid_t pid = fork(); //fork子进程
    if (pid == 0) {
        //设置子进程的signal信号处理函数为默认函数 //【见流程3.3】
        UnsetSigChldHandler(); 
        //进入虚拟机，执行相关操作【见流程3.4】
        env-&amp;gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,
                              is_system_server ? NULL : instructionSet);
        ...
    } else if (pid &amp;gt; 0) {
        //进入父进程Zygote
    }
    return pid;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;setsigchldhandler&quot;&gt;3.2 SetSigChldHandler&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; com_android_internal_os_Zygote.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void SetSigChldHandler() {
  struct sigaction sa;
  memset(&amp;amp;sa, 0, sizeof(sa)); //对sa地址内容进行清零操作
  sa.sa_handler = SigChldHandler;
  //安装信号
  int err = sigaction(SIGCHLD, &amp;amp;sa, NULL);
  if (err &amp;lt; 0) {
    ALOGW(&quot;Error setting SIGCHLD handler: %s&quot;, strerror(errno));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进程处理某个信号前，需要先在进程中安装此信号，安装过程主要是建立信号值和进程对相应信息值的动作。此处
SIGCHLD=17，代表子进程退出时所相应的操作动作为&lt;code class=&quot;highlighter-rouge&quot;&gt;SigChldHandler&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;unsetsigchldhandler&quot;&gt;3.3 UnsetSigChldHandler&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; com_android_internal_os_Zygote.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void UnsetSigChldHandler() {
  struct sigaction sa;
  memset(&amp;amp;sa, 0, sizeof(sa));
  sa.sa_handler = SIG_DFL;
  //在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为
  int err = sigaction(SIGCHLD, &amp;amp;sa, NULL);
  if (err &amp;lt; 0) {
    ALOGW(&quot;Error unsetting SIGCHLD handler: %s&quot;, strerror(errno));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;didforkfromzygote&quot;&gt;3.4 DidForkFromZygote&lt;/h3&gt;

&lt;p&gt;在文章&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create/#nativeforkandspecialize&quot;&gt;理解Android进程创建流程&lt;/a&gt;已详细地说明了此过程，并在小节【Step 6-2-2-1-1-1】中说过后续会单独讲讲信号处理过程，那本文便是补充这个过程&lt;/p&gt;

&lt;p&gt;[-&amp;gt; Runtime.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) {
    ...
    //创建Java堆处理的线程池
    heap_-&amp;gt;CreateThreadPool();
    //重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。
    heap_-&amp;gt;ResetGcPerformanceInfo();

    ...
    //启动信号捕获 【见流程3.5】
    StartSignalCatcher();
    //启动JDWP线程，当命令debuger的flags指定&quot;suspend=y&quot;时，则暂停runtime
    Dbg::StartJdwp();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;startsignalcatcher&quot;&gt;3.5 StartSignalCatcher&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; Runtime.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Runtime::StartSignalCatcher() {
  if (!is_zygote_) {
    //【见流程3.6】
    signal_catcher_ = new SignalCatcher(stack_trace_file_);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于非Zygote进程才会启动SignalCatcher线程。&lt;/p&gt;

&lt;h3 id=&quot;signalcatcher&quot;&gt;3.6 SignalCatcher&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal_catcher.cc]&lt;/p&gt;

&lt;p&gt;创建SignalCatcher对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SignalCatcher::SignalCatcher(const std::string&amp;amp; stack_trace_file)
    : stack_trace_file_(stack_trace_file),
      lock_(&quot;SignalCatcher lock&quot;),
      cond_(&quot;SignalCatcher::cond_&quot;, lock_),
      thread_(nullptr) {
  SetHaltFlag(false);
  //通过pthread_create创建一个线程，线程名为&quot;signal catcher thread&quot;; 该线程的启动将关联到Android runtime。
  CHECK_PTHREAD_CALL(pthread_create, (&amp;amp;pthread_, nullptr, &amp;amp;Run, this), &quot;signal catcher thread&quot;);
  Thread* self = Thread::Current();
  MutexLock mu(self, lock_);
  while (thread_ == nullptr) {
    cond_.Wait(self);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SignalCatcher是一个守护线程，用于捕获SIGQUIT、SIGUSR1信号，并采取相应的行为。&lt;/p&gt;

&lt;p&gt;Android系统中，由Zygote孵化而来的子进程，包含system_server进程和各种App进程都存在一个SignalCatcher线程，但是Zygote进程本身是没有这个线程的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/signal_catcher_thread.png&quot; alt=&quot;signal_catcher_thread&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是systemui所在进程的部分线程信息，可以看到其中有一个SignalCatcher线程，该线程具体是如何处理信号的呢，请往下继续看。&lt;/p&gt;

&lt;h3 id=&quot;run&quot;&gt;3.7 Run&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; signal_catcher.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void* SignalCatcher::Run(void* arg) {
  SignalCatcher* signal_catcher = reinterpret_cast&amp;lt;SignalCatcher*&amp;gt;(arg);
  CHECK(signal_catcher != nullptr);
  Runtime* runtime = Runtime::Current();
  //检查当前线程是否依附到Android Runtime
  CHECK(runtime-&amp;gt;AttachCurrentThread(&quot;Signal Catcher&quot;, true, runtime-&amp;gt;GetSystemThreadGroup(), !runtime-&amp;gt;IsAotCompiler()));

  Thread* self = Thread::Current();
  DCHECK_NE(self-&amp;gt;GetState(), kRunnable);
  {
    MutexLock mu(self, signal_catcher-&amp;gt;lock_);
    signal_catcher-&amp;gt;thread_ = self;
    signal_catcher-&amp;gt;cond_.Broadcast(self);
  }

  SignalSet signals;
  signals.Add(SIGQUIT); //添加对信号SIGQUIT的处理
  signals.Add(SIGUSR1); //添加对信号SIGUSR1的处理
  while (true) {
    //等待信号到来，这是个阻塞操作
    int signal_number = signal_catcher-&amp;gt;WaitForSignal(self, signals);
    //当信号捕获需要停止时，则取消当前线程跟Android Runtime的关联。
    if (signal_catcher-&amp;gt;ShouldHalt()) {
      runtime-&amp;gt;DetachCurrentThread();
      return nullptr;
    }
    switch (signal_number) {
    case SIGQUIT:
      signal_catcher-&amp;gt;HandleSigQuit(); //输出线程trace
      break;
    case SIGUSR1:
      signal_catcher-&amp;gt;HandleSigUsr1(); //强制GC
      break;
    default:
      LOG(ERROR) &amp;lt;&amp;lt; &quot;Unexpected signal %d&quot; &amp;lt;&amp;lt; signal_number;
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个方法中，只有信号SIGQUIT和SIGUSR1的处理过程，并没有信号SIGKILL的处理过程，这是因为SIGKILL是不能被忽略同时也不能被捕获，所以不会出现在Signal Catcher线程。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.8 小结&lt;/h3&gt;

&lt;p&gt;调用流程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ForkAndSpecializeCommon
	SetSigChldHandler
	UnsetSigChldHandler
	DidForkFromZygote
		StartSignalCatcher
			SignalCatcher
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，进程被杀后，对于binder的C/S架构，Binder的Server端挂了，Client会收到死亡通告，还会执行各种清理工作。下一篇文章会进一步说明。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;四、实例分析&lt;/h2&gt;

&lt;p&gt;注：下面涉及的signal信号log是Gityuan在kernel.c中自行添加的，原生是没有的，仅用于查看和调试使用。&lt;/p&gt;

&lt;h3 id=&quot;kill--3&quot;&gt;4.1  kill -3&lt;/h3&gt;

&lt;p&gt;当adb终端输入:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb -3 10562&lt;/code&gt;，则signal信号传递过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux/signal/kill_3.png&quot; alt=&quot;kill_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;9365：adb的终端sh所在进程pid;&lt;/li&gt;
  &lt;li&gt;10562：桌面App的进程pid；&lt;/li&gt;
  &lt;li&gt;10568：10562进程的子线程(SignalCatcher线程);&lt;/li&gt;
  &lt;li&gt;上图由红框圈起来的线程都是进程10562的子线程；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由adb所在进程&lt;code class=&quot;highlighter-rouge&quot;&gt;9365&lt;/code&gt;向进程10562的子线程&lt;code class=&quot;highlighter-rouge&quot;&gt;10568&lt;/code&gt;(SignalCatcher线程)，发送&lt;code class=&quot;highlighter-rouge&quot;&gt;signal=3&lt;/code&gt;信号;该过程需要Art虚拟机参与。&lt;/li&gt;
  &lt;li&gt;SignalCatcher线程收到信号3后，再向进程&lt;code class=&quot;highlighter-rouge&quot;&gt;10562&lt;/code&gt;的子线程分别发送&lt;code class=&quot;highlighter-rouge&quot;&gt;signal=33&lt;/code&gt;信号（大于31的signal都是实时信号），用于dump各个子线程的信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;kill--10&quot;&gt;4.2  kill -10&lt;/h3&gt;

&lt;p&gt;当adb终端输入:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb -10 10562&lt;/code&gt;，则signal信号传递过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux/signal/kill_10.png&quot; alt=&quot;kill_10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;9365：adb的终端sh所在进程pid;&lt;/li&gt;
  &lt;li&gt;10562：桌面App的进程pid；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;流程：由adb所在进程&lt;code class=&quot;highlighter-rouge&quot;&gt;9365&lt;/code&gt;向进程&lt;code class=&quot;highlighter-rouge&quot;&gt;10562&lt;/code&gt;，发送&lt;code class=&quot;highlighter-rouge&quot;&gt;signal=10&lt;/code&gt;信号; 该过程需要Art虚拟机参与。&lt;/p&gt;

&lt;h3 id=&quot;kill--9&quot;&gt;4.3  kill -9&lt;/h3&gt;

&lt;p&gt;当adb终端输入:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb -9 8707&lt;/code&gt;，则signal信号传递过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux/signal/kill_9.png&quot; alt=&quot;kill_9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;7115：adb的终端sh所在进程pid;&lt;/li&gt;
  &lt;li&gt;8707：浏览器的进程pid；&lt;/li&gt;
  &lt;li&gt;上图由红框圈起来的线程都是进程8707的子线程；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;流程：由adb所在进程&lt;code class=&quot;highlighter-rouge&quot;&gt;7115&lt;/code&gt;向进程&lt;code class=&quot;highlighter-rouge&quot;&gt;8707&lt;/code&gt;，发送&lt;code class=&quot;highlighter-rouge&quot;&gt;signal=9&lt;/code&gt;信号,判断是SIGKILL信号，则由内核直接处理。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;4.4 小结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -3&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -10&lt;/code&gt;流程由前面介绍的信号发送和信号处理两个过程，过程中由Art虚拟机来对信号进行相应的处理。&lt;/li&gt;
  &lt;li&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt; kill -9&lt;/code&gt;则不同，是由linux底层来完成杀进程的过程，也就是执行到前面讲到第一节中的&lt;a href=&quot;http://gityuan.com/2016/04/16/kill-signal/#completesignal&quot;&gt;complete_signal()&lt;/a&gt;方法后，判断是SIGKILL信号，则由内核直接处理，Art虚拟机压根没机会来处理。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 16 Apr 2016 18:10:22 +0800</pubDate>
        <link>http://gityuan.com/2016/04/16/kill-signal/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/04/16/kill-signal/</guid>
        
        <category>android</category>
        
        <category>process</category>
        
        <category>kill</category>
        
        
      </item>
    
      <item>
        <title> Android开篇</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本站所有博文内容均为原创，欢迎交流与转载，转载请务必注明作者与原文链接，且不得轻易篡改原文内容。另外，未经授权不得用于任何商业目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;一、简述&lt;/h2&gt;

&lt;p&gt;Android系统非常庞大、错中复杂，其底层是采用Linux作为基底，上层采用包含虚拟机的Java层以及Native层，通过系统调用(Syscall)连通系统的内核空间与用户空间。用户空间主要采用C++和Java代码，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而融为一体。&lt;/p&gt;

&lt;p&gt;Google官方提供了一张&lt;a href=&quot;http://gityuan.com/2016/01/30/android-boot/#android&quot;&gt;经典的四层架构图&lt;/a&gt;，从下往上依次分为Linux内核、系统库和Android运行时环境、框架层以及应用层这4层架构，其中每一层都包含大量的子模块或子系统。这只是如垒砖般地简单分层，还远不足以表达Android整个系统的内部架构，运行机理，以及各个模块之间是如何衔接与配合工作的。为了更深入地掌握Android整个架构思想以及各个模块在Android系统所处的地位与价值，计划以Android系统启动过程为主线，&lt;strong&gt;以进程的视角&lt;/strong&gt;来诠释Android系统全貌，全方位的深度剖析各个模块功能，争取各个击破。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本站所有Android系列的文章，都是基于Android 6.0源码&lt;/strong&gt;，深入剖析Android系统架构，力争各个击破。这样才能犹如庖丁解牛，解决、分析问题则能游刃有余。&lt;/p&gt;

&lt;h2 id=&quot;android&quot;&gt;二、Android架构&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;系统启动架构图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击查看&lt;a href=&quot;http://gityuan.com/images/android-process/android-boot.jpg&quot;&gt;大图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/android-boot.jpg&quot; alt=&quot;process_status&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图解：&lt;/strong&gt;&lt;br /&gt;
Android系统启动过程由上图从下往上的一个过程：&lt;code class=&quot;highlighter-rouge&quot;&gt;Loader&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Framework&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;，接来下简要说说每个过程：&lt;/p&gt;

&lt;h3 id=&quot;loader&quot;&gt;2.1 Loader层&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;里的预设出代码开始执行，然后加载引导程序到&lt;code class=&quot;highlighter-rouge&quot;&gt;RAM&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kernel&quot;&gt;2.2 Kernel层&lt;/h3&gt;

&lt;p&gt;Kernel层是指Android内核层，到这里才刚刚开始进入Android系统。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启动Kernel的0号进程：初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；&lt;/li&gt;
  &lt;li&gt;启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。&lt;code class=&quot;highlighter-rouge&quot;&gt;kthreadd进程是所有内核进程的鼻祖&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;native&quot;&gt;2.3 Native层&lt;/h3&gt;

&lt;p&gt;这里的Native层主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，&lt;code class=&quot;highlighter-rouge&quot;&gt;init进程是所有用户进程的鼻祖&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；&lt;/li&gt;
  &lt;li&gt;init进程还启动&lt;code class=&quot;highlighter-rouge&quot;&gt;servicemanager&lt;/code&gt;(binder服务管家)、&lt;code class=&quot;highlighter-rouge&quot;&gt;bootanim&lt;/code&gt;(开机动画)等重要服务&lt;/li&gt;
  &lt;li&gt;init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程，&lt;code class=&quot;highlighter-rouge&quot;&gt;Zygote是所有Java进程的父进程&lt;/code&gt;，Zygote进程本身是由init进程孵化而来的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;framework&quot;&gt;2.4 Framework层&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：
    &lt;ul&gt;
      &lt;li&gt;加载ZygoteInit类，注册Zygote Socket服务端套接字；&lt;/li&gt;
      &lt;li&gt;加载虚拟机；&lt;/li&gt;
      &lt;li&gt;preloadClasses；&lt;/li&gt;
      &lt;li&gt;preloadResouces。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;System Server进程，是由Zygote进程fork而来，&lt;code class=&quot;highlighter-rouge&quot;&gt;System Server是Zygote孵化的第一个进程&lt;/code&gt;，System Server负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。&lt;/li&gt;
  &lt;li&gt;Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service，等服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app&quot;&gt;2.5 App层&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；&lt;/li&gt;
  &lt;li&gt;Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。&lt;/li&gt;
  &lt;li&gt;所有的App进程都是由Zygote进程fork生成的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;三、通信方式&lt;/h2&gt;

&lt;p&gt;无论是Android系统，还是各种Linux衍生系统，各个组件、模块往往运行在各种不同的进程和线程内，这里就必然涉及进程/线程之间的通信。对于IPC(Inter-Process Communication, 进程间通信)，Linux现有管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制，Android额外还有Binder IPC机制，Android OS中的Zygote进程的IPC采用的是Socket机制，在上层system server、media server以及上层App之间更多的是采用Binder IPC方式来完成跨进程间的通信。对于Android上层架构中，还多时候是在同一个进程的线程之间需要相互通信，例如同一个进程的主线程与工作线程之间的通信，往往采用的Handler消息机制。&lt;/p&gt;

&lt;p&gt;想深入理解Android内核层架构，必须先深入理解Linux现有的IPC机制；对于Android上层架构，则最常用的通信方式是Binder、Socket、Handler，当然也有少量其他的IPC方式，比如杀进程Process.killProcess()采用的是signal方式。下面说说Binder、Socket、Handler：&lt;/p&gt;

&lt;h3 id=&quot;binder&quot;&gt;3.1 Binder&lt;/h3&gt;

&lt;p&gt;Binder作为Android系统提供的一种IPC机制，无论从系统开发还是应用开发，都是Android系统中最重要的组成，也是最难理解的一块知识点，想了解&lt;a href=&quot;https://www.zhihu.com/question/39440766/answer/89210950&quot;&gt;为什么Android要采用Binder作为IPC机制？&lt;/a&gt;，可查看博主在知乎上的回答。深入了解Binder机制，最好的方法便是阅读源码，借用Linux鼻祖Linus Torvalds曾说过的一句话：Read The Fucking Source Code。下面简要说说Binder IPC原理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Binder IPC原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Binder通信采用c/s架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/binder/prepare/IPC-Binder.jpg&quot; alt=&quot;ServiceManager&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;想进一步了解Binder，可查看&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/&quot;&gt;Binder系列—开篇&lt;/a&gt;，Binder系列用了13篇文章，从源码角度出发来，讲述驱动、native、framework、app四个层面的整个完整流程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;socket&quot;&gt;3.2 Socket&lt;/h3&gt;

&lt;p&gt;Socket通信方式也是C/S架构，比Binder简单很多。在Android系统中采用Socket通信方式的主要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;zygote：用于孵化进程，系统进程system_server孵化进程时便通过socket向zygote进程发起请求；&lt;/li&gt;
  &lt;li&gt;installd：用于安装App的守护进程，上层PackageManagerService很多实现最终都是交给它来完成；&lt;/li&gt;
  &lt;li&gt;lmkd：lowmemorykiller的守护进程，Java层的LowMemoryKiller最终都是由lmkd来完成；&lt;/li&gt;
  &lt;li&gt;adbd：这个也不用说，用于服务adb；&lt;/li&gt;
  &lt;li&gt;logcatd:这个不用说，用于服务logcat；&lt;/li&gt;
  &lt;li&gt;vold：即volume Daemon，是存储类的守护进程，用于负责如USB、Sdcard等存储设备的事件处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等还有很多，这里不一一列举，Socket方式更多的用于Android framework层与native层之间的通信。Socket通信方式相对于binder非常简单，所以一直没有写相关文章，为了成一个体系，下次再补上。&lt;/p&gt;

&lt;h3 id=&quot;handler&quot;&gt;3.3 Handler&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信&lt;/strong&gt;，Handler消息机制是由一组MessageQueue、Message、Looper、Handler共同组成的，为了方便且称之为Handler消息机制。&lt;/p&gt;

&lt;p&gt;有人可能会疑惑，为何Binder/Socket用于进程间通信，能否用于线程间通信呢？答案是肯定，对于两个具有独立地址空间的进程通信都可以，当然也能用于共享内存空间的两个线程间通信，这就好比杀鸡用牛刀。接着可能还有人会疑惑，那handler消息机制能否用于进程间通信？答案是不能，Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。很多时候，Handler是工作线程向UI主线程发送消息，即App应用中只有主线程能更新UI，其他工作线程往往是完成相应工作后，通过Handler告知主线程需要做出相应地UI更新操作，Handler分发相应的消息给UI主线程去完成，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/handler/handler_thread_commun.jpg&quot; alt=&quot;handler_communication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于工作线程与主线程共享地址空间，即Handler实例对象&lt;code class=&quot;highlighter-rouge&quot;&gt;mHandler&lt;/code&gt;位于线程间共享的内存堆上，工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。工作线程通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mHandler&lt;/code&gt;向其成员变量&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中添加新Message，主线程一直处于loop()方法内，当收到新的Message时按照一定规则分发给相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage&lt;/code&gt;()方法来处理。所以说，而Handler消息机制用于同进程的线程间通信的核心是线程间共享内存空间，而不同进程拥有不同的地址空间，也就不能用handler来实现进程间通信。&lt;/p&gt;

&lt;p&gt;上图只是Handler消息机制的一种处理流程，是不是只能工作线程向UI主线程发消息呢，其实不然，可以是UI线程想工作线程发送消息，也可以是多个工作线程之间通过handler发送消息。更多关于Handler消息机制文章：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/12/26/handler-message-framework/&quot;&gt;Android消息机制-Handler(framework篇)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/12/27/handler-message-native/&quot;&gt;Android消息机制-Handler(native篇)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;四、计划提纲&lt;/h2&gt;

&lt;p&gt;2016年新的一年刚开始，首先祝大家、也祝自己在新的一年诸事顺心，事业蒸蒸日上。在过去的一年，对于Android从底层一路到上层有不少自己的理解和沉淀，但总体较零散，未成体系。借着今天（元旦假日的最后一天），给自己的新的一年提前做一个计划，把知识进行归档整理与再学习，从而加深对Android架构的理解。通过前面对系统启动的介绍，相信大家对Android系统有了一个整体观，接下来需要抓核心、理思路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;Android系统启动过程中，有几个非常重要的进程：&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Zygote&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;system_server&lt;/code&gt;进程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/05/android-init/&quot;&gt;Android系统启动—init篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/13/android-zygote/&quot;&gt;Android系统启动—Zygote篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Android系统启动—SystemServer篇
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/14/android-system-server/&quot;&gt;SystemServer上篇&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/20/android-system-server-2/&quot;&gt;SystemServer下篇&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;再则就是在整个架构中有大量的服务，都是基于&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/&quot;&gt;Binder&lt;/a&gt;来交互的，计划针对部分核心服务来重点分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Android服务篇-ActivityManagerService
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/21/activity-manager-service/&quot;&gt;AMS启动过程（一）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Android服务篇-PackageManagerService&lt;/li&gt;
  &lt;li&gt;Android服务篇-PowerManagerService&lt;/li&gt;
  &lt;li&gt;Android服务篇-BatteryService
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/01/10/power_rank/&quot;&gt;Android耗电统计算法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Android服务篇-WindowManagerService&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然graphic也是一大块难啃的模块，也是需要整理的，先留个空位吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）&lt;/strong&gt;对于App来说，Android应用的四大组件Activity，Service，Broadcast Receiver， Content Provider最为核心，那么我们需要分别展开对其他的分解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Android组件-Activity
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/03/12/start-activity/&quot;&gt;startActivity流程分析(一)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Android组件-Service
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/03/06/start-service/&quot;&gt;startService流程分析&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Android组件-Broadcast Receiver&lt;/li&gt;
  &lt;li&gt;Android组件-Content Provider&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（4）&lt;/strong&gt;有了这些，中间还缺少关于虚拟机ART的介绍，会需要对ART分析，后续还需要开展对ART虚拟机的一系列文章。回顾整个架构，谈谈系统性能，需要先掌握进程、内存、IO这些层面知识，这里牵涉面较广，从底层Linux层直至上层App&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程篇
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create/&quot;&gt;理解Android进程创建流程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/12/19/android-process-category/&quot;&gt;Android进程整理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/10/01/process-lifecycle/&quot;&gt;Android进程生命周期与ADJ&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/10/01/process-priority/&quot;&gt;进程优先级&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内存篇
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/10/30/kernel-memory/&quot;&gt;Linux内存管理&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IO篇&lt;/li&gt;
  &lt;li&gt;Linux驱动篇&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（5）&lt;/strong&gt;最后，说说Android相关的一些常用命令和工具&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/03/19/android-build/&quot;&gt;理解Android编译命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/01/17/systrace/&quot;&gt;性能工具Systrace&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/01/02/memory-analysis-command/&quot;&gt;Android内存分析命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/10/11/ps-command/&quot;&gt;ps进程命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/27/am-command/&quot;&gt;Am命令用法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/02/28/pm-command/&quot;&gt;Pm命令用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本博客还有很多文章并没有写到上面这个清单，先写这么多，后续再不断更新与完善。最后，欢迎大家交流与纠错，大家来找茬。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;欢迎关注我的&lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;，微信公众号：gityuan，后面会持续分享更多原创技术干货。&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 19:49:40 +0800</pubDate>
        <link>http://gityuan.com/2016/04/01/android/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/04/01/android/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>理解Android进程创建流程</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;基于Android 6.0的源码剖析， 分析Android进程是如何一步步创建的，本文涉及到的源码：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/frameworks/base/core/java/android/os/Process.java
/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java
/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java

/frameworks/base/core/java/com/android/internal/os/Zygote.java
/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp

/frameworks/base/cmds/app_process/App_main.cpp （内含AppRuntime类）
/frameworks/base/core/jni/AndroidRuntime.cpp

/libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
/art/runtime/native/dalvik_system_ZygoteHooks.cc
/art/runtime/Runtime.cc
/art/runtime/Thread.cc
/art/runtime/signal_catcher.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;本文要介绍的是进程的创建，先简单说说进程与线程的区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程：&lt;/strong&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;在启动前必须先创建一个进程，该进程是由&lt;code class=&quot;highlighter-rouge&quot;&gt;Zygote&lt;/code&gt; fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个&lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;就运行在一个进程中，除非在AndroidManifest.xml中配置&lt;code class=&quot;highlighter-rouge&quot;&gt;Android:process&lt;/code&gt;属性，或通过native代码fork进程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程：&lt;/strong&gt;线程对应用开发者来说非常熟悉，比如每次&lt;code class=&quot;highlighter-rouge&quot;&gt;new Thread().start()&lt;/code&gt;都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从Linux角度来说进程与线程都是一个task_struct结构体，除了是否共享资源外，并没有其他本质的区别。&lt;/p&gt;

&lt;p&gt;对于大多数的应用开发者来说创建线程比较熟悉，而对于创建进程并没有太多的概念。对于系统工程师或者高级开发者，还是有很必要了解Android系统是如何一步步地创建出一个进程的。先来看一张进程创建过程的简要图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/start_app_process.jpg&quot; alt=&quot;start_app_process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;App发起进程&lt;/strong&gt;：当从桌面启动应用，则发起进程便是Launcher所在进程；当从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过binder发送消息给system_server进程；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;system_server进程&lt;/strong&gt;：调用Process.start()方法，通过socket向zygote进程发送创建新进程的请求；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;zygote进程&lt;/strong&gt;：在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;ZygoteInit.main()&lt;/code&gt;后便进入&lt;code class=&quot;highlighter-rouge&quot;&gt;runSelectLoop()&lt;/code&gt;循环体内，当有客户端连接时便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;新进程&lt;/strong&gt;：执行handleChildProc方法，最后调用ActivityThread.main()方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可能朋友不是很了解system_server进程和Zygote进程，下面简要说说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;system_server&lt;/code&gt;进程：是用于管理整个Java framework层，包含ActivityManager，PowerManager等各种系统服务;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Zygote&lt;/code&gt;进程：是Android系统的首个Java进程，Zygote是所有Java进程的父进程，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;system_server&lt;/code&gt;进程以及所有的App进程都是Zygote的子进程，注意这里说的是子进程，而非子线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想更进一步了解system_server进程和Zygote进程在整个Android系统所处的地位，可查看我的另一个文章&lt;a href=&quot;http://gityuan.com/2016/01/30/android-boot/&quot;&gt;Android系统-开篇&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;接下来从Android 6.0源码，展开讲解进程创建是一个怎样的过程。&lt;/p&gt;

&lt;h3 id=&quot;processstart&quot;&gt;1. Process.start&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; Process.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final ProcessStartResult start(final String processClass,
                          final String niceName,
                          int uid, int gid, int[] gids,
                          int debugFlags, int mountExternal,
                          int targetSdkVersion,
                          String seInfo,
                          String abi,
                          String instructionSet,
                          String appDataDir,
                          String[] zygoteArgs) {
    try {
         //【见流程2】
        return startViaZygote(processClass, niceName, uid, gid, gids,
                debugFlags, mountExternal, targetSdkVersion, seInfo,
                abi, instructionSet, appDataDir, zygoteArgs);
    } catch (ZygoteStartFailedEx ex) {
        throw new RuntimeException(&quot;&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;startviazygote&quot;&gt;2. startViaZygote&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; Process.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static ProcessStartResult startViaZygote(final String processClass,
                              final String niceName,
                              final int uid, final int gid,
                              final int[] gids,
                              int debugFlags, int mountExternal,
                              int targetSdkVersion,
                              String seInfo,
                              String abi,
                              String instructionSet,
                              String appDataDir,
                              String[] extraArgs)
                              throws ZygoteStartFailedEx {
    synchronized(Process.class) {
        ArrayList&amp;lt;String&amp;gt; argsForZygote = new ArrayList&amp;lt;String&amp;gt;();

        argsForZygote.add(&quot;--runtime-args&quot;);
        argsForZygote.add(&quot;--setuid=&quot; + uid);
        argsForZygote.add(&quot;--setgid=&quot; + gid);
        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);

        if (niceName != null) {
            argsForZygote.add(&quot;--nice-name=&quot; + niceName);
        }
        if (appDataDir != null) {
            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);
        }
        argsForZygote.add(processClass);

        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
         //【见流程3】
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该过程主要工作是生成&lt;code class=&quot;highlighter-rouge&quot;&gt;argsForZygote&lt;/code&gt;数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。&lt;/p&gt;

&lt;h3 id=&quot;zygotesendargsandgetresult&quot;&gt;3. zygoteSendArgsAndGetResult&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; Process.java]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3-1.&lt;/strong&gt; openZygoteSocketIfNeeded&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);
        }
    }

    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }

    //当主zygote没能匹配成功，则尝试第二个zygote
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);
        }
    }

    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }

    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;openZygoteSocketIfNeeded(abi)&lt;/code&gt;方法是根据当前的abi来选择与zygote还是zygote64来进行通信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3-2.&lt;/strong&gt; zygoteSendArgsAndGetResult&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static ProcessStartResult zygoteSendArgsAndGetResult(
        ZygoteState zygoteState, ArrayList&amp;lt;String&amp;gt; args)
        throws ZygoteStartFailedEx {
    try {
        //
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;

        writer.write(Integer.toString(args.size()));
        writer.newLine();

        int sz = args.size();
        for (int i = 0; i &amp;lt; sz; i++) {
            String arg = args.get(i);
            if (arg.indexOf(&#39;\n&#39;) &amp;gt;= 0) {
                throw new ZygoteStartFailedEx(
                        &quot;embedded newlines not allowed&quot;);
            }
            writer.write(arg);
            writer.newLine();
        }

        writer.flush();

        ProcessStartResult result = new ProcessStartResult();
        //等待socket服务端（即zygote）返回新创建的进程pid;
        //对于等待时长问题，Google正在考虑此处是否应该有一个timeout，但目前是没有的。
        result.pid = inputStream.readInt();
        if (result.pid &amp;lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }
        result.usingWrapper = inputStream.readBoolean();
        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。&lt;/p&gt;

&lt;p&gt;既然system_server进程通过socket向Zygote进程发送消息，这是便会唤醒Zygote进程，来响应socket客户端的请求（即system_server端），接下来的操作便是在Zygote进程中执行。&lt;/p&gt;

&lt;h3 id=&quot;runselectloop&quot;&gt;4. runSelectLoop&lt;/h3&gt;

&lt;p&gt;[–&amp;gt;ZygoteInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String argv[]) {
    try {
        runSelectLoop(abiList);
        ....
    } catch (MethodAndArgsCaller caller) {
        caller.run(); //【见流程13】
    } catch (RuntimeException ex) {
        closeServerSocket();
        throw ex;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后续会讲到runSelectLoop()方法会抛出异常&lt;code class=&quot;highlighter-rouge&quot;&gt;MethodAndArgsCaller&lt;/code&gt;，从而进入caller.run()方法。&lt;/p&gt;

&lt;p&gt;[-&amp;gt; ZygoteInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {
    ...

    ArrayList&amp;lt;ZygoteConnection&amp;gt; peers = new ArrayList&amp;lt;ZygoteConnection&amp;gt;();
    while (true) {
        for (int i = pollFds.length - 1; i &amp;gt;= 0; --i) {
            //采用I/O多路复用机制，当客户端发出连接请求或者数据处理请求时，跳过continue，执行后面的代码
            if ((pollFds[i].revents &amp;amp; POLLIN) == 0) {
                continue;
            }
            if (i == 0) {
                //创建客户端连接
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                //处理客户端数据事务 【见流程5】
                boolean done = peers.get(i).runOnce();
                if (done) {
                    peers.remove(i);
                    fds.remove(i);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒Zygote进程，创建Socket通道ZygoteConnection，然后执行ZygoteConnection的runOnce()方法。&lt;/p&gt;

&lt;h3 id=&quot;runonce&quot;&gt;5. runOnce&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; ZygoteConnection.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {

    String args[];
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;

    try {
        //读取socket客户端发送过来的参数列表
        args = readArgumentList(); 
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        closeSocket();
        return true;
    }

    PrintStream newStderr = null;
    if (descriptors != null &amp;amp;&amp;amp; descriptors.length &amp;gt;= 3) {
        newStderr = new PrintStream(new FileOutputStream(descriptors[2]));
    }

    int pid = -1;
    FileDescriptor childPipeFd = null;
    FileDescriptor serverPipeFd = null;

    try {
        //将binder客户端传递过来的参数，解析成Arguments对象格式
        parsedArgs = new Arguments(args);
        ...

        int [] fdsToClose = { -1, -1 };

        FileDescriptor fd = mSocket.getFileDescriptor();
        if (fd != null) {
            fdsToClose[0] = fd.getInt$();
        }

        fd = ZygoteInit.getServerSocketFileDescriptor();
        if (fd != null) {
            fdsToClose[1] = fd.getInt$();
        }
        fd = null;
        //【见流程6】
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,
                parsedArgs.appDataDir);
    } catch (Exception e) {
        ...
    }

    try {
        if (pid == 0) {
            //子进程执行
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            //【见流程7】
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);

            // 不应到达此处，子进程预期的是抛出异常ZygoteInit.MethodAndArgsCaller或者执行exec().
            return true;
        } else {
            //父进程执行
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;forkandspecialize&quot;&gt;6. forkAndSpecialize&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; Zygote.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,
      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
      String instructionSet, String appDataDir) {
    VM_HOOKS.preFork(); //【见流程6-1】
    int pid = nativeForkAndSpecialize(
              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
              instructionSet, appDataDir); //【见流程6-2】
    ...
    VM_HOOKS.postForkCommon(); //【见流程6-3】
    return pid;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_HOOKS&lt;/code&gt;是做什么的呢？  这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_HOOKS = new ZygoteHooks()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;先说说Zygote进程，如下图：
&lt;img src=&quot;/images/android-process/zygote_sub_thread.png&quot; alt=&quot;zygote_sub_thread&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可知Zygote进程有4个子线程，分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceQueueDaemon&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;FinalizerDaemon&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;FinalizerWatchdogDaemon&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;HeapTaskDaemon&lt;/code&gt;，此处称为为Zygote的4个Daemon子线程。图中线程名显示的并不完整是由于底层的进程结构体&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;是由长度为16的char型数组保存，超过15个字符便会截断。&lt;/p&gt;

&lt;p&gt;可能有人会问zygote64进程不是还有system_server，com.android.phone等子线程，怎么会只有4个呢？那是因为这些并不是Zygote子线程，而是Zygote的子进程。在图中用红色圈起来的是进程的&lt;a href=&quot;http://gityuan.com/2015/10/11/ps-command/&quot;&gt;VSIZE，virtual size)&lt;/a&gt;，代表的是进程虚拟地址空间大小。线程与进程的最为本质的区别便是是否共享内存空间，图中VSIZE和Zygote进程相同的才是Zygote的子线程，否则就是Zygote的子进程。&lt;/p&gt;

&lt;h4 id=&quot;prefork&quot;&gt;6-1 preFork&lt;/h4&gt;

&lt;p&gt;[-&amp;gt; ZygoteHooks.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public void preFork() {
    Daemons.stop(); //停止4个Daemon子线程【见流程6-1-1】
    waitUntilAllThreadsStopped(); //等待所有子线程结束【见流程6-1-2】
    token = nativePreFork(); //完成gc堆的初始化工作【见流程6-1-3】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-1-1.&lt;/strong&gt; Daemons.stop&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void stop() {
    HeapTaskDaemon.INSTANCE.stop(); //Java堆整理线程
    ReferenceQueueDaemon.INSTANCE.stop(); //引用队列线程
    FinalizerDaemon.INSTANCE.stop(); //析构线程
    FinalizerWatchdogDaemon.INSTANCE.stop(); //析构监控线程
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处守护线程Stop方式是先调用目标线程interrrupt()方法，然后再调用目标线程join()方法，等待线程执行完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 6-1-2.&lt;/strong&gt; waitUntilAllThreadsStopped&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void waitUntilAllThreadsStopped() {
    File tasks = new File(&quot;/proc/self/task&quot;);
    // 当/proc中线程数大于1，就出让CPU直到只有一个线程，才退出循环
    while (tasks.list().length &amp;gt; 1) {
        Thread.yield(); 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-1-3.&lt;/strong&gt; nativePreFork&lt;/p&gt;

&lt;p&gt;nativePreFork通过JNI最终调用的是dalvik_system_ZygoteHooks.cc中的ZygoteHooks_nativePreFork()方法，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {
    Runtime* runtime = Runtime::Current();
    CHECK(runtime-&amp;gt;IsZygote()) &amp;lt;&amp;lt; &quot;runtime instance not started with -Xzygote&quot;;
    runtime-&amp;gt;PreZygoteFork(); //【见流程6-1-3-1】
    if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {
      Trace::Pause();
    }
    //将线程转换为long型并保存到token，该过程是非安全的
    return reinterpret_cast&amp;lt;jlong&amp;gt;(ThreadForEnv(env));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-1-3-1.&lt;/strong&gt; PreZygoteFork&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Runtime::PreZygoteFork() {
    // 堆的初始化工作。这里就不继续再往下追了，等后续有空专门谢谢关于art虚拟机
    heap_-&amp;gt;PreZygoteFork(); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;VM_HOOKS.preFork()的主要功能便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），并等待这些线程的停止，初始化gc堆的工作。&lt;/p&gt;

&lt;h4 id=&quot;nativeforkandspecialize&quot;&gt;6-2 nativeForkAndSpecialize&lt;/h4&gt;

&lt;p&gt;nativeForkAndSpecialize()通过JNI最终调用的是com_android_internal_os_Zygote.cpp中的
com_android_internal_os_Zygote_nativeForkAndSpecialize()方法，如下：&lt;/p&gt;

&lt;p&gt;[-&amp;gt; com_android_internal_os_Zygote.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(
    JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,
    jint debug_flags, jobjectArray rlimits,
    jint mount_external, jstring se_info, jstring se_name,
    jintArray fdsToClose, jstring instructionSet, jstring appDataDir) {
    // 将CAP_WAKE_ALARM赋予蓝牙进程
    jlong capabilities = 0;
    if (uid == AID_BLUETOOTH) {
        capabilities |= (1LL &amp;lt;&amp;lt; CAP_WAKE_ALARM);
    }
    //【见流程6-2-1】
    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,
            rlimits, capabilities, capabilities, mount_external, se_info,
            se_name, false, fdsToClose, instructionSet, appDataDir);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-2-1.&lt;/strong&gt;ForkAndSpecializeCommon&lt;/p&gt;

&lt;p&gt;[-&amp;gt; com_android_internal_os_Zygote.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,
                                     jint debug_flags, jobjectArray javaRlimits,
                                     jlong permittedCapabilities, jlong effectiveCapabilities,
                                     jint mount_external,
                                     jstring java_se_info, jstring java_se_name,
                                     bool is_system_server, jintArray fdsToClose,
                                     jstring instructionSet, jstring dataDir) {
  //设置子进程的signal信号处理函数
  SetSigChldHandler(); 
  //fork子进程 【见流程6-2-1-1】
  pid_t pid = fork(); 
  if (pid == 0) {
    //进入子进程
    DetachDescriptors(env, fdsToClose); //关闭并清除文件描述符

    if (!is_system_server) {
        //对于非system_server子进程，则创建进程组
        int rc = createProcessGroup(uid, getpid());
    }
    SetGids(env, javaGids); //设置设置group
    SetRLimits(env, javaRlimits); //设置资源limit

    int rc = setresgid(gid, gid, gid);
    rc = setresuid(uid, uid, uid);

    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);
    SetSchedulerPolicy(env); //设置调度策略

     //selinux上下文
    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);

    if (se_info_c_str == NULL &amp;amp;&amp;amp; is_system_server) {
      se_name_c_str = &quot;system_server&quot;;
    }
    if (se_info_c_str != NULL) {
      SetThreadName(se_name_c_str); //设置线程名为system_server，方便调试
    }
    //在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为
    UnsetSigChldHandler(); 
    //等价于调用zygote.callPostForkChildHooks() 【见流程6-2-2-1】
    env-&amp;gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,
                              is_system_server ? NULL : instructionSet);
    ...

  } else if (pid &amp;gt; 0) {
    //进入父进程，即Zygote进程
  }
  return pid;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-2-1-1.&lt;/strong&gt; fork()&lt;/p&gt;

&lt;p&gt;fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;父进程中，fork返回新创建的子进程的pid;&lt;/li&gt;
  &lt;li&gt;子进程中，fork返回0；&lt;/li&gt;
  &lt;li&gt;当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段空间等，当然也包含拷贝fork()代码之后的要执行的代码到新的进程。&lt;/p&gt;

&lt;p&gt;下面，说说zygote的fork()过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/boot/zygote/zygote_fork.jpg&quot; alt=&quot;zygote_fork&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zygote进程是所有Android进程的母体，包括system_server进程以及App进程都是由Zygote进程孵化而来。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。何为copy on write(写时复制)？当进程A执行修改某个内存数据时（这便是on write时机），才发生缺页中断，从而分配新的内存地址空间（这便是copy操作），对于copy on write是基于内存页，而不是基于进程的。关于Zygote进程的libc、vm、preloaded classes、preloaded resources是如何生成的，可查看另一个文章&lt;a href=&quot;http://gityuan.com/2016/02/13/android-zygote/#preload&quot;&gt;Android系统启动-zygote篇&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 6-2-2-1.&lt;/strong&gt; Zygote.callPostForkChildHooks&lt;/p&gt;

&lt;p&gt;[-&amp;gt; Zygote.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer,
        String instructionSet) {
    //【见下文】
    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;[-&amp;gt; ZygoteHooks.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void postForkChild(int debugFlags, String instructionSet) {
    //【见流程6-2-2-1-1】
    nativePostForkChild(token, debugFlags, instructionSet);
    Math.setRandomSeedInternal(System.currentTimeMillis());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里，设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 6-2-2-1-1.&lt;/strong&gt; nativePostForkChild&lt;/p&gt;

&lt;p&gt;最终调用dalvik_system_ZygoteHooks的ZygoteHooks_nativePostForkChild&lt;/p&gt;

&lt;p&gt;[-&amp;gt; dalvik_system_ZygoteHooks.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags,
                                            jstring instruction_set) {
    Thread* thread = reinterpret_cast&amp;lt;Thread*&amp;gt;(token);
    //设置新进程的主线程id
    thread-&amp;gt;InitAfterFork();
    ..
    if (instruction_set != nullptr) {
      ScopedUtfChars isa_string(env, instruction_set);
      InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());
      Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;
      if (isa != kNone &amp;amp;&amp;amp; isa != kRuntimeISA) {
        action = Runtime::NativeBridgeAction::kInitialize;
      }
      //【见流程6-2-2-1-1-1】
      Runtime::Current()-&amp;gt;DidForkFromZygote(env, action, isa_string.c_str());
    } else {
      Runtime::Current()-&amp;gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-2-2-1-1-1.&lt;/strong&gt; DidForkFromZygote&lt;/p&gt;

&lt;p&gt;[-&amp;gt; Runtime.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) {
  is_zygote_ = false;
  if (is_native_bridge_loaded_) {
    switch (action) {
      case NativeBridgeAction::kUnload:
        UnloadNativeBridge(); //卸载用于跨平台的桥连库
        is_native_bridge_loaded_ = false;
        break;
      case NativeBridgeAction::kInitialize:
        InitializeNativeBridge(env, isa);//初始化用于跨平台的桥连库
        break;
    }
  }
  //创建Java堆处理的线程池
  heap_-&amp;gt;CreateThreadPool();
  //重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。
  heap_-&amp;gt;ResetGcPerformanceInfo();
  if (jit_.get() == nullptr &amp;amp;&amp;amp; jit_options_-&amp;gt;UseJIT()) {
    //当flag被设置，并且还没有创建JIT时，则创建JIT
    CreateJit();
  }
  //设置信号处理函数
  StartSignalCatcher();
  //启动JDWP线程，当命令debuger的flags指定&quot;suspend=y&quot;时，则暂停runtime
  Dbg::StartJdwp();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于信号处理过程，其代码位于signal_catcher.cc文件中，后续会单独讲解。&lt;/p&gt;

&lt;h4 id=&quot;postforkcommon&quot;&gt;6-3 postForkCommon&lt;/h4&gt;

&lt;p&gt;[-&amp;gt; ZygoteHooks.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void postForkCommon() {
    Daemons.start(); //【见流程6-3-1】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 6-3-1.&lt;/strong&gt; Daemons.start&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void start() {
    ReferenceQueueDaemon.INSTANCE.start();
    FinalizerDaemon.INSTANCE.start();
    FinalizerWatchdogDaemon.INSTANCE.start();
    HeapTaskDaemon.INSTANCE.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;VM_HOOKS.postForkCommon的主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。&lt;/p&gt;

&lt;h4 id=&quot;forkandspecialize-1&quot;&gt;forkAndSpecialize小结&lt;/h4&gt;

&lt;p&gt;调用关系链：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Zygote.forkAndSpecialize
	ZygoteHooks.preFork
		Daemons.stop
		ZygoteHooks.nativePreFork
			dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork
				Runtime::PreZygoteFork
					heap_-&amp;gt;PreZygoteFork()
	Zygote.nativeForkAndSpecialize
		com_android_internal_os_Zygote.ForkAndSpecializeCommon
			fork()
			Zygote.callPostForkChildHooks
				ZygoteHooks.postForkChild
					dalvik_system_ZygoteHooks.nativePostForkChild
						Runtime::DidForkFromZygote
	ZygoteHooks.postForkCommon
		Daemons.start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;时序图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击查看&lt;a href=&quot;http://gityuan.com/images/android-process/fork_and_specialize.jpg&quot;&gt;大图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/fork_and_specialize.jpg&quot; alt=&quot;fork_and_specialize&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到此App进程已完成了创建的所有工作，接下来开始新创建的App进程的工作。在前面ZygoteConnection.runOnce方法中，zygote进程执行完&lt;code class=&quot;highlighter-rouge&quot;&gt;forkAndSpecialize()&lt;/code&gt;后，新创建的App进程便进入&lt;code class=&quot;highlighter-rouge&quot;&gt;handleChildProc()&lt;/code&gt;方法，下面的操作运行在App进程。&lt;/p&gt;

&lt;h3 id=&quot;handlechildproc&quot;&gt;7. handleChildProc&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; ZygoteConnection.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void handleChildProc(Arguments parsedArgs,
        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)
        throws ZygoteInit.MethodAndArgsCaller {

    //关闭Zygote的socket两端的连接
    closeSocket();
    ZygoteInit.closeServerSocket();

    if (descriptors != null) {
        try {
            Os.dup2(descriptors[0], STDIN_FILENO);
            Os.dup2(descriptors[1], STDOUT_FILENO);
            Os.dup2(descriptors[2], STDERR_FILENO);
            for (FileDescriptor fd: descriptors) {
                IoUtils.closeQuietly(fd);
            }
            newStderr = System.err;
        } catch (ErrnoException ex) {
            Log.e(TAG, &quot;Error reopening stdio&quot;, ex);
        }
    }

    if (parsedArgs.niceName != null) {
        //设置进程名
        Process.setArgV0(parsedArgs.niceName);
    }

    if (parsedArgs.invokeWith != null) {
        //据说这是用于检测进程内存泄露或溢出时场景而设计，后续还需要进一步分析。
        WrapperInit.execApplication(parsedArgs.invokeWith,
                parsedArgs.niceName, parsedArgs.targetSdkVersion,
                VMRuntime.getCurrentInstructionSet(),
                pipeFd, parsedArgs.remainingArgs);
    } else {
        //执行目标类的main()方法 【见流程8】
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,
                parsedArgs.remainingArgs, null);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;zygoteinit&quot;&gt;8. zygoteInit&lt;/h3&gt;

&lt;p&gt;[–&amp;gt;RuntimeInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {

    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);
    redirectLogStreams(); //重定向log输出

    commonInit(); // 通用的一些初始化【见流程9】
    nativeZygoteInit(); // zygote初始化 【见流程10】
    applicationInit(targetSdkVersion, argv, classLoader); // 应用初始化【见流程11】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;commoninit&quot;&gt;9. commonInit&lt;/h3&gt;

&lt;p&gt;[–&amp;gt;RuntimeInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final void commonInit() {
    // 设置默认的未捕捉异常处理方法
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());

    // 设置市区，中国时区为&quot;Asia/Shanghai&quot;
    TimezoneGetter.setInstance(new TimezoneGetter() {
        @Override
        public String getId() {
            return SystemProperties.get(&quot;persist.sys.timezone&quot;);
        }
    });
    TimeZone.setDefault(null);

    //重置log配置
    LogManager.getLogManager().reset(); 
    new AndroidConfig(); 

    // 设置默认的HTTP User-agent格式,用于 HttpURLConnection。
    String userAgent = getDefaultUserAgent();
    System.setProperty(&quot;http.agent&quot;, userAgent);

    // 设置socket的tag，用于网络流量统计
    NetworkManagementSocketTagger.install();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认的HTTP User-agent格式，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &quot;Dalvik/1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build/LMY47V)&quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nativezygoteinit&quot;&gt;10. nativeZygoteInit&lt;/h3&gt;

&lt;p&gt;nativeZygoteInit()方法在AndroidRuntime.cpp中，进行了jni映射，对应下面的方法。&lt;/p&gt;

&lt;p&gt;[–&amp;gt;AndroidRuntime.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime-&amp;gt;onZygoteInit(); //此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;[–&amp;gt;app_main.cpp]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;virtual void onZygoteInit()
{
    sp&amp;lt;ProcessState&amp;gt; proc = ProcessState::self();
    proc-&amp;gt;startThreadPool(); //启动新binder线程
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()，在binder系列文章中的&lt;a href=&quot;http://gityuan.com/2015/11/14/binder-add-service/&quot;&gt;注册服务(addService)&lt;/a&gt;详细这两个方法的执行原理。&lt;/p&gt;

&lt;h3 id=&quot;applicationinit&quot;&gt;11. applicationInit&lt;/h3&gt;

&lt;p&gt;[–&amp;gt;RuntimeInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {
    //true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用
    nativeSetExitWithoutCleanup(true);

    //设置虚拟机的内存利用率参数值为0.75
    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);
    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);

    final Arguments args;
    try {
        args = new Arguments(argv); //解析参数
    } catch (IllegalArgumentException ex) {
        Slog.e(TAG, ex.getMessage());
        return;
    }

    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);

    //调用startClass的static方法 main() 【见流程12】
    invokeStaticMain(args.startClass, args.startArgs, classLoader);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处args.startClass为”android.app.ActivityThread”。&lt;/p&gt;

&lt;h3 id=&quot;invokestaticmain&quot;&gt;12. invokeStaticMain&lt;/h3&gt;

&lt;p&gt;[–&amp;gt;RuntimeInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {
    Class&amp;lt;?&amp;gt; cl;

    try {
        cl = Class.forName(className, true, classLoader);
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
                &quot;Missing class when invoking static main &quot; + className, ex);
    }

    Method m;
    try {
        m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException( &quot;Missing static main on &quot; + className, ex);
    } catch (SecurityException ex) {
        throw new RuntimeException(
                &quot;Problem getting static main on &quot; + className, ex);
    }

    int modifiers = m.getModifiers();
    if (! (Modifier.isStatic(modifiers) &amp;amp;&amp;amp; Modifier.isPublic(modifiers))) {
        throw new RuntimeException(
                &quot;Main method is not public and static on &quot; + className);
    }

    //通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。【见流程13】
    throw new ZygoteInit.MethodAndArgsCaller(m, argv);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;invokeStaticMain()方法中抛出的异常&lt;code class=&quot;highlighter-rouge&quot;&gt;MethodAndArgsCaller&lt;/code&gt;，根据前面的【流程4】中可知，下一步进入caller.run()方法。&lt;/p&gt;

&lt;h3 id=&quot;methodandargscaller&quot;&gt;13. MethodAndArgsCaller&lt;/h3&gt;

&lt;p&gt;[–&amp;gt;ZygoteInit.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static class MethodAndArgsCaller extends Exception
        implements Runnable {

    public void run() {
        try {
            //根据传递过来的参数，可知此处通过反射机制调用的是ActivityThread.main()方法
            mMethod.invoke(null, new Object[] { mArgs }); 
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            Throwable cause = ex.getCause();
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            } else if (cause instanceof Error) {
                throw (Error) cause;
            }
            throw new RuntimeException(ex);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此，总算是进入到了ActivityThread类的main()方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;当App第一次启动时或者启动远程Service，即AndroidManifest.xml文件中定义了process:remote属性时，都需要创建进程。比如当用户点击桌面的某个App图标，桌面本身是一个app（即Launcher App），那么Launcher所在进程便是这次创建新进程的发起进程，该通过binder发送消息给system_server进程，该进程承载着整个java framework的核心服务。system_server进程从Process.start开始，执行创建进程，流程图（以进程的视角）如下：&lt;/p&gt;

&lt;p&gt;点击查看&lt;a href=&quot;http://gityuan.com/images/android-process/process-create.jpg&quot;&gt;大图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-process/process-create.jpg&quot; alt=&quot;process-create&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，&lt;code class=&quot;highlighter-rouge&quot;&gt;system_server&lt;/code&gt;进程通过socket IPC通道向&lt;code class=&quot;highlighter-rouge&quot;&gt;zygote&lt;/code&gt;进程通信，&lt;code class=&quot;highlighter-rouge&quot;&gt;zygote&lt;/code&gt;在fork出新进程后由于fork&lt;strong&gt;调用一次，返回两次&lt;/strong&gt;，即在zygote进程中调用一次，在zygote进程和子进程中各返回一次，从而能进入子进程来执行代码。该调用流程图的过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;system_server进程&lt;/strong&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;即流程1~3&lt;/code&gt;）：通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;zygote进程&lt;/strong&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;即流程4~6&lt;/code&gt;）：接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节（&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create/#forkandspecialize-1&quot;&gt;详见流程6&lt;/a&gt;），其具体工作是依次执行下面的3个方法：
    &lt;ul&gt;
      &lt;li&gt;preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；&lt;/li&gt;
      &lt;li&gt;nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；&lt;/li&gt;
      &lt;li&gt;postForkCommon()：在启动之前被暂停的4个Daemon子线程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;新进程&lt;/strong&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;即流程7~13&lt;/code&gt;）：进入handleChildProc()方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即Activity.main()方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再之后的流程，如果是startActivity则将要进入Activity的onCreate/onStart/onResume等生命周期；如果是startService则将要进入Service的onCreate等生命周期。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;欢迎关注我的&lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;，微信公众号：gityuan，后面会持续分享更多原创技术干货。&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 05:10:11 +0800</pubDate>
        <link>http://gityuan.com/2016/03/27/app-process-create/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/03/27/app-process-create/</guid>
        
        <category>android</category>
        
        <category>boot</category>
        
        <category>process</category>
        
        
      </item>
    
      <item>
        <title>理解Android编译命令</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;工欲善其事，必先利其器，对于想要深入学习Android源码，必须先掌握Android编译命令.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;一、引言&lt;/h2&gt;

&lt;p&gt;关于Android Build系统，这个话题很早就打算整理下，迟迟没有下笔，决定跟大家分享下。先看下面几条指令，相信编译过Android源码的人都再熟悉不过的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source /opt/android1204_17.conf 
source setenv.sh
lunch
make -j12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;记得最初刚接触Android时，同事告诉我用上面的指令就可以编译Android源码，指令虽短但过几天就记不全或者忘记顺序，每次编译时还需要看看自己的云笔记，冰冷的指令总是难以让我记忆。后来我决定认真研究下这个指令的含义。知其然还需知其所以然，这样能更深层次的理解并记忆，才能与自身的知识体系建立强连接，或许&lt;strong&gt;还有意外收获&lt;/strong&gt;，果然如此，接下来跟大家分享一下在研究上述几条指令含义的过程中，深入了解到的Android Build(编译)系统。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、编译命令&lt;/h2&gt;

&lt;p&gt;准备好编译环境后，编译Android源码的第一步是 &lt;code class=&quot;highlighter-rouge&quot;&gt;source build/envsetup.sh&lt;/code&gt;，其中source命令就是用于运行shell脚本命令，功能等价于”.”，因此该命令也等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;. build/envsetup.sh&lt;/code&gt;。在文件&lt;code class=&quot;highlighter-rouge&quot;&gt;envsetup.sh&lt;/code&gt;声明了当前会话终端可用的命令，这里需要注意的是当前会话终端，也就意味着每次新打开一个终端都必须再一次执行这些指令。起初并不理解为什么新开的终端不能直接执行make指令，到这里总算明白了。&lt;/p&gt;

&lt;p&gt;接下来，解释一下&lt;strong&gt;本文开头的引用&lt;/strong&gt;的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source /opt/android1204_17.conf  //初始化jdk环境变量（这个不是必需的，因厂商而异）
source setenv.sh  //初始化编译环境，包括后面的lunch和make指令
lunch  //指定此次编译的目标设备以及编译类型
make  -j12 //开始编译，默认为编译整个系统，其中-j12代表的是编译的job数量为12。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的编译命令都在&lt;code class=&quot;highlighter-rouge&quot;&gt;envsetup.sh&lt;/code&gt;文件能找到相对应的function，比如上述的命令&lt;code class=&quot;highlighter-rouge&quot;&gt;lunch&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;，在文件一定能找到&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function lunch(){
	...
}

function make(){
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;source envsetup.sh&lt;/code&gt;，需要cd到setenv.sh文件所在路径执行，路径可能在build/envsetup.sh，或者integrate/envsetup.sh，再或者不排除有些厂商会封装自己的.sh脚本，但核心思路是一致的。&lt;/p&gt;

&lt;p&gt;具体实现这里就不展开说明，下面精炼地总结了一下各个指令用法和功效。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;2.1 代码编译&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;编译指令&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;在源码树的根目录执行编译&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mm&lt;/td&gt;
      &lt;td&gt;编译当前路径下所有模块，但不包含依赖&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mmm [module_path]&lt;/td&gt;
      &lt;td&gt;编译指定路径下所有模块，但不包含依赖&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mma&lt;/td&gt;
      &lt;td&gt;编译当前路径下所有模块，且包含依赖&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mmma [module_path]&lt;/td&gt;
      &lt;td&gt;编译指定路径下所有模块，且包含依赖&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;make [module_name]&lt;/td&gt;
      &lt;td&gt;无参数，则表示编译整个Android代码&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面列举部分模块的编译指令：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块&lt;/th&gt;
      &lt;th&gt;make命令&lt;/th&gt;
      &lt;th&gt;mmm命令&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;init&lt;/td&gt;
      &lt;td&gt;make init&lt;/td&gt;
      &lt;td&gt;mmm system/core/init&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;zygote&lt;/td&gt;
      &lt;td&gt;make app_process&lt;/td&gt;
      &lt;td&gt;mmm frameworks/base/cmds/app_process&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;system_server&lt;/td&gt;
      &lt;td&gt;make services&lt;/td&gt;
      &lt;td&gt;mmm frameworks/base/services&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;java framework&lt;/td&gt;
      &lt;td&gt;make framework&lt;/td&gt;
      &lt;td&gt;mmm frameworks/base&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;framework资源&lt;/td&gt;
      &lt;td&gt;make framework-res&lt;/td&gt;
      &lt;td&gt;mmm frameworks/base/core/res&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jni framework&lt;/td&gt;
      &lt;td&gt;make libandroid_runtime&lt;/td&gt;
      &lt;td&gt;mmm frameworks/base/core/jni&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;binder&lt;/td&gt;
      &lt;td&gt;make libbinder&lt;/td&gt;
      &lt;td&gt;mmm frameworks/native/libs/binder&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述mmm命令同样适用于mm/mma/mmma，编译系统采用的是增量编译，只会编译发生变化的目标文件。当需要重新编译所有的相关模块，则需要编译命令后增加参数&lt;code class=&quot;highlighter-rouge&quot;&gt;-B&lt;/code&gt;，比如make -B [module_name]，或者 mm -B [module_path]。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;m、mm、mmm、mma、mmma&lt;/code&gt;这些命令的实现都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;方式来完成的。&lt;/li&gt;
  &lt;li&gt;mmm/mm编译的效率很高，而make/mma/mmma编译较缓慢；&lt;/li&gt;
  &lt;li&gt;make/mma/mmma编译时会把所有的依赖模块一同编译，但mmm/mm不会;&lt;/li&gt;
  &lt;li&gt;建议：首次编译时采用make/mma/mmma编译；当依赖模块已经编译过的情况，则使用mmm/mm编译。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.2 代码搜索&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;搜索指令&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;cgrep&lt;/td&gt;
      &lt;td&gt;所有&lt;strong&gt;C/C++&lt;/strong&gt;文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jgrep&lt;/td&gt;
      &lt;td&gt;所有&lt;strong&gt;Java&lt;/strong&gt;文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ggrep&lt;/td&gt;
      &lt;td&gt;所有&lt;strong&gt;Gradle&lt;/strong&gt;文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mangrep [keyword]&lt;/td&gt;
      &lt;td&gt;所有&lt;strong&gt;AndroidManifest.xml&lt;/strong&gt;文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sepgrep [keyword]&lt;/td&gt;
      &lt;td&gt;所有&lt;strong&gt;sepolicy&lt;/strong&gt;文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;resgrep [keyword]&lt;/td&gt;
      &lt;td&gt;所有本地res/*.xml文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sgrep [keyword]&lt;/td&gt;
      &lt;td&gt;所有资源文件执行搜索操作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述指令用法最终实现方式都是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt;指令，各个指令用法格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xgrep [keyword]  //x代表的是上表的搜索指令
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，搜索所有AndroidManifest.xml文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;launcher&lt;/code&gt;关键字所在文件的具体位置，指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mangrep launcher
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再如，搜索所有Java代码中包含zygote所在文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jgrep zygote
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;又如，搜索所有system_app的selinux权限信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sepgrep system_app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt; Android源码非常庞大，直接采用grep来搜索代码，不仅方法笨拙、浪费时间，而且搜索出很多无意义的混淆结果。根据具体需求，来选择合适的代码搜索指令，能节省代码搜索时间，提高搜索结果的精准度，方便定位目标代码。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.3 导航指令&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;导航指令&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;croot&lt;/td&gt;
      &lt;td&gt;切换至Android根目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cproj&lt;/td&gt;
      &lt;td&gt;切换至工程的根目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;godir [filename]&lt;/td&gt;
      &lt;td&gt;跳转到包含某个文件的目录&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;  当每次修改完某个文件后需要编译时，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;cproj&lt;/code&gt;后会跳转到当前模块的根目录，也就是Android.mk文件所在目录，然后再执行mm指令，即可编译目标模块；当进入源码层级很深后，需要返回到根目录，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;croot&lt;/code&gt;一条指令完成；另外&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt; 指令可用于快速切换至上次目录。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.4 信息查询&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;查询指令&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;hmm&lt;/td&gt;
      &lt;td&gt;查询所有的指令help信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;findmakefile&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;查询当前目录所在工程的Android.mk文件路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;print_lunch_menu&lt;/td&gt;
      &lt;td&gt;查询lunch可选的product&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;printconfig&lt;/td&gt;
      &lt;td&gt;查询各项编译变量值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gettop&lt;/td&gt;
      &lt;td&gt;查询Android源码的根目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gettargetarch&lt;/td&gt;
      &lt;td&gt;获取TARGET_ARCH值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.5 其他指令&lt;/h3&gt;

&lt;p&gt;上述只是列举比较常用的指令，还有其他指令，而且不同的build编译系统，支持的指令可能会存在一些差异，当忘记这些编译指令，可以通过执行&lt;code class=&quot;highlighter-rouge&quot;&gt;hmm&lt;/code&gt;，查询指令的帮助信息。&lt;/p&gt;

&lt;p&gt;最后再列举两个比较常用的指令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;make clean：执行清理操作，等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm -rf out/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;make update-api：更新API，在framework API改动后需执行该指令，Api记录在目录&lt;code class=&quot;highlighter-rouge&quot;&gt;frameworks/base/api&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;三、编译系统&lt;/h2&gt;

&lt;p&gt;Android 编译系统是Android源码的一部分，用于编译Android系统，Android SDK以及相关文档。该编译系统是由Make文件、Shell以及Python脚本共同组成，其中最为重要的便是Make文件。关于编译系统可参考 &lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/&quot;&gt;理解 Android Build 系统&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;makefile&quot;&gt;3.1 Makefile分类&lt;/h3&gt;

&lt;p&gt;整个Build系统的Make文件分为三大类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;系统核心的Make文件：&lt;/strong&gt;定义了Build系统的框架，文件全部位于路径&lt;code class=&quot;highlighter-rouge&quot;&gt;/build/core&lt;/code&gt;，其他Make文件都是基于该框架编写的；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;针对产品的Make文件：&lt;/strong&gt;定义了具体某个型号手机的Make文件，文件路径位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/device&lt;/code&gt;，该目录下往往又以公司名和产品名划分两个子级目录，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;/device/qcom/msm8916&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;针对模块的Make文件：&lt;/strong&gt;整个系统分为各个独立的模块，每个模块都一个专门的Make文件，名称统一为”Android.mk”，该文件定义了当前模块的编译方式。Build系统会扫描整个源码树中名为”Android.mk”的问题，并执行相应模块的编译工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;3.2 编译产物&lt;/h3&gt;

&lt;p&gt;经过&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;编译后的产物，都位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/out目录&lt;/code&gt;，该目录下主要关注下面几个目录：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。&lt;/li&gt;
  &lt;li&gt;/out/target/common：通用的一些编译产物，包含Java应用代码和Java库；&lt;/li&gt;
  &lt;li&gt;/out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在/out/target/product/[product_name]目录下，有几个重量级的镜像文件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;system.img:挂载为根分区，主要包含Android OS的系统文件；&lt;/li&gt;
  &lt;li&gt;ramdisk.img:主要包含init.rc文件和配置文件等；&lt;/li&gt;
  &lt;li&gt;userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。&lt;/p&gt;

&lt;h3 id=&quot;androidmk&quot;&gt;3.3 Android.mk解析&lt;/h3&gt;

&lt;p&gt;在源码树中每一个模块的所有文件通常都相应有一个自己的文件夹，在该模块的根目录下有一个名称为“Android.mk”
的文件。编译系统正是以模块为单位进行编译，每个模块都有唯一的模块名，一个模块可以有依赖多个其他模块，模块间的依赖关系就是通过模块名来引用的。也就是说当模块需要依赖一个jar包或者apk时，必须先将jar包或apk定义为一个模块，然后再依赖相应的模块。&lt;/p&gt;

&lt;p&gt;对于Android.mk文件，通常都是以下面两行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCAL_PATH := $(call my-dir)  //设置当编译路径为当前文件夹所在路径
include $(CLEAR_VARS)  //清空编译环境的变量（由其他模块设置过的变量）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为方便模块编译，编译系统设置了很多的编译环境变量，如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LOCAL_SRC_FILES：当前模块包含的所有源码文件；&lt;/li&gt;
  &lt;li&gt;LOCAL_MODULE：当前模块的名称（具有唯一性）；&lt;/li&gt;
  &lt;li&gt;LOCAL_PACKAGE_NAME：当前APK应用的名称（具有唯一性）；&lt;/li&gt;
  &lt;li&gt;LOCAL_C_INCLUDES：C/C++所需的头文件路径;&lt;/li&gt;
  &lt;li&gt;LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库名;&lt;/li&gt;
  &lt;li&gt;LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库名;&lt;/li&gt;
  &lt;li&gt;LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的Java静态库;&lt;/li&gt;
  &lt;li&gt;LOCAL_JAVA_LIBRARIES：当前模块依赖的Java共享库;&lt;/li&gt;
  &lt;li&gt;LOCAL_CERTIFICATE：签署当前应用的证书名称，比如platform。&lt;/li&gt;
  &lt;li&gt;LOCAL_MODULE_TAGS：当前模块所包含的标签，可以包含多标签，可能值为debgu,eng,user,development或optional（默认值）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对这些环境变量，编译系统还定义了一些便捷函数，如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(call my-dir)：获取当前文件夹路径；&lt;/li&gt;
  &lt;li&gt;$(call all-java-files-under, &lt;src&gt;)：获取指定目录下的所有Java文件；&lt;/src&gt;&lt;/li&gt;
  &lt;li&gt;$(call all-c-files-under, &lt;src&gt;)：获取指定目录下的所有C文件；&lt;/src&gt;&lt;/li&gt;
  &lt;li&gt;$(call all-Iaidl-files-under, &lt;src&gt;) ：获取指定目录下的所有AIDL文件；&lt;/src&gt;&lt;/li&gt;
  &lt;li&gt;$(call all-makefiles-under, &lt;folder&gt;)：获取指定目录下的所有Make文件；&lt;/folder&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  LOCAL_PATH := $(call my-dir) 
  include $(CLEAR_VARS) 
   
  # 获取所有子目录中的Java文件
  LOCAL_SRC_FILES := $(call all-subdir-java-files) 
   
  # 当前模块依赖的动态Java库名称
  LOCAL_JAVA_LIBRARIES := com.gityuan.lib 
   
  # 当前模块的名称
  LOCAL_MODULE := demo 
   
  # 将当前模块编译成一个静态的Java库
  include $(BUILD_STATIC_JAVA_LIBRARY)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;如果觉得本文对您有所帮助，请关注我的&lt;strong&gt;微信公众号：gityuan&lt;/strong&gt;， &lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;。 或者&lt;a href=&quot;http://gityuan.com/about/&quot;&gt;点击这里查看更多关于gityuan个人信息&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Mar 2016 05:19:12 +0800</pubDate>
        <link>http://gityuan.com/2016/03/20/android-build/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/03/20/android-build/</guid>
        
        <category>android</category>
        
        <category>make</category>
        
        <category>command</category>
        
        
      </item>
    
      <item>
        <title>startActivity流程分析(一)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;基于Android 6.0的源码剖析， 分析android Activity启动流程中ActivityManagerService所扮演的角色&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/frameworks/base/services/core/java/com/android/server/am/ActiveServices.java
/frameworks/base/services/core/java/com/android/server/am/ProcessRecord.java

/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
/frameworks/base/core/java/android/app/IActivityManager.java
/frameworks/base/core/java/android/app/ActivityManagerNative.java (内含ActivityManagerProxy类)
/frameworks/base/core/java/android/app/ActivityManager.java

/frameworks/base/core/java/android/app/IApplicationThread.java
/frameworks/base/core/java/android/app/ApplicationThreadNative.java (内含ApplicationThreadProxy类)
/frameworks/base/core/java/android/app/ActivityThread.java (内含ApplicationThread类)

/frameworks/base/core/java/android/app/ContextImpl.java
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;一、启动过程&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startActivity&lt;/code&gt;的整体流程与&lt;a href=&quot;http://gityuan.com/2016/02/21/start-service/&quot;&gt;startService流程&lt;/a&gt;非常相近，但比服务启动更为复杂，多了UI的相关内容以及Activity的生命周期更为丰富。&lt;/p&gt;

&lt;p&gt;对于Activity的启动过程，可用如下图来概括。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/activity/start_activity_process.jpg&quot; alt=&quot;start_activity_process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；&lt;/li&gt;
  &lt;li&gt;system_server进程接收到请求后，向zygote进程发送创建进程的请求；&lt;/li&gt;
  &lt;li&gt;Zygote进程fork出新的子进程，即App进程；&lt;/li&gt;
  &lt;li&gt;App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；&lt;/li&gt;
  &lt;li&gt;system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；&lt;/li&gt;
  &lt;li&gt;App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；&lt;/li&gt;
  &lt;li&gt;主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。&lt;/p&gt;

&lt;p&gt;启动Activity较为复杂，涉及UI渲染问题，后续再单独篇幅从源码角度阐述该过程。&lt;/p&gt;

&lt;h3 id=&quot;activity&quot;&gt;二、Activity生命周期&lt;/h3&gt;

&lt;h4 id=&quot;activity-1&quot;&gt;2.1 Activity状态&lt;/h4&gt;

&lt;p&gt;Activity的生命周期中只有在以下3种状态之一，才能较长时间内保持状态不变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/activity/activity_lifecycle.jpg&quot; alt=&quot;activity_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Resumed（运行状态）&lt;/strong&gt;：Activity处于前台，且用户可以与其交互。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Paused（暂停状态）&lt;/strong&gt;: Activity被在前台中处于半透明状态或者未覆盖全屏的其他Activity部分遮挡。 暂停的Activity不会接收用户输入，也无法执行任何代码。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stopped（停止状态）&lt;/strong&gt;：Activity被完全隐藏，且对用户不可见；被视为后台Activity。 停止的Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，其他状态都是过渡状态(或称为暂时状态)，比如onCreate()，onStart()后很快就会调用onResume()方法&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.2 生命周期&lt;/h4&gt;

&lt;p&gt;对于App来说，其Activity的生命周期执行是由系统进程中的·ActivityManagerService·服务触发的，接下来从进程和线程的角度来分析Activity的生命周期，这里涉及到系统进程和应用进程：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;system_server进程是系统进程&lt;/strong&gt;，java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App进程是应用程序所在进程&lt;/strong&gt;，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），除了下图中所示的线程，其实还有很多线程，比如signal catcher线程等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/activity/app_process.jpg&quot; alt=&quot;app_process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder&lt;/code&gt;用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事件，比如图中线程2向线程4发送事务；而&lt;code class=&quot;highlighter-rouge&quot;&gt;handler&lt;/code&gt;用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息。&lt;/p&gt;

&lt;p&gt;结合图说说Activity生命周期，比如暂停Activity的流程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程1&lt;/code&gt;的AMS中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;线程2&lt;/code&gt;的ATP来发送事件；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程2&lt;/code&gt;通过binder将暂停Activity的事件传输到App进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;线程4&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程4&lt;/code&gt;通过handler消息机制，将暂停Activity的消息发送给&lt;code class=&quot;highlighter-rouge&quot;&gt;主线程&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;主线程&lt;/code&gt;在looper.loop()中循环遍历消息，当收到暂停Activity的消息(&lt;code class=&quot;highlighter-rouge&quot;&gt;PAUSE_ACTIVITY&lt;/code&gt;)时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的层层调用，最后便会调用到Activity.onPause()方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这便是由AMS完成了onPause()控制，那么同理Activity的其他生命周期也是这么个流程来进行控制的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、流程分析&lt;/h3&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityThread&lt;/code&gt;的内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;H.handleMessage()&lt;/code&gt;来控制Activity的生命周期，在H类中共定义了50种消息。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.1 启动应用&lt;/h4&gt;

&lt;p&gt;消息： &lt;code class=&quot;highlighter-rouge&quot;&gt;LAUNCH_ACTIVITY&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用链&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActivityThread.handleLaunchActivity
	ActivityThread.handleConfigurationChanged
		ActivityThread.performConfigurationChanged
			ComponentCallbacks2.onConfigurationChanged

	ActivityThread.performLaunchActivity
		LoadedApk.makeApplication
			Instrumentation.callApplicationOnCreate
				Application.onCreate
	
		Instrumentation.callActivityOnCreate
			Activity.performCreate
				Activity.onCreate

		Instrumentation.callActivityonRestoreInstanceState
			Activity.performRestoreInstanceState
				Activity.onRestoreInstanceState

	ActivityThread.handleResumeActivity
		ActivityThread.performResumeActivity
			Activity.performResume
				Activity.performRestart
					Instrumentation.callActivityOnRestart
						Activity.onRestart

					Activity.performStart
						Instrumentation.callActivityOnStart
							Activity.onStart

				Instrumentation.callActivityOnResume
					Activity.onResume
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;采用缩进方式，来代表方法的调用链，相同缩进层的方法代表来自位于同一个调用方法里。callActivityOnCreate和callActivityonRestoreInstanceState相同层级，代表都是由上一层级的ActivityThread.performLaunchActivity()方法中调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App角度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用链过程层层调用，但对上层应用是透明的，App开发者只需要覆写其中重要的回调函数即可，故此处所说的App角度，便是指App开发者来说可见之处。经过上述的调用链，依次会执行下面回调方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ComponentCallbacks2.onConfigurationChanged()：&lt;/li&gt;
  &lt;li&gt;Application.onCreate()&lt;/li&gt;
  &lt;li&gt;Activity.onCreate()&lt;/li&gt;
  &lt;li&gt;Activity.onRestoreInstanceState()&lt;/li&gt;
  &lt;li&gt;Activity.onRestart()&lt;/li&gt;
  &lt;li&gt;Activity.onStart()&lt;/li&gt;
  &lt;li&gt;Activity.onResume()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Application和Activity都实现了ComponentCallbacks2接口；所以Application和Activity会先执行onConfigurationChanged()回调方法。在前面说过onCreate()是过渡状态，紧跟着会执行handleResumeActivity()方法，然后就进入Resumed状态。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;3.2 恢复应用&lt;/h4&gt;

&lt;p&gt;消息： &lt;code class=&quot;highlighter-rouge&quot;&gt;RESUME_ACTIVITY&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用链&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActivityThread.handleResumeActivity
	ActivityThread.performResumeActivity
		Activity.performResume
			Activity.performRestart
				Instrumentation.callActivityOnRestart
					Activity.onRestart

				Activity.performStart
					Instrumentation.callActivityOnStart
						Activity.onStart

			Instrumentation.callActivityOnResume
				Activity.onResume
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;App角度&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.onRestart()&lt;/li&gt;
  &lt;li&gt;Activity.onStart()&lt;/li&gt;
  &lt;li&gt;Activity.onResume()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;App处于运行状态，UI可见。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;3.3 暂停应用&lt;/h4&gt;

&lt;p&gt;msg: &lt;code class=&quot;highlighter-rouge&quot;&gt;PAUSE_ACTIVITY&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用链&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActivityThread.handlePauseActivity
	ActivityThread.performPauseActivity
		ActivityThread.callCallActivityOnSaveInstanceState
			Instrumentation.callActivityOnSaveInstanceState
				Activity.performSaveInstanceState
					Activity.onSaveInstanceState

		Instrumentation.callActivityOnPause
			Activity.performPause
				Activity.onPause
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;App角度&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.onSaveInstanceState()&lt;/li&gt;
  &lt;li&gt;Activity.onPause()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据saveState是否true决定是否执行callCallActivityOnSaveInstanceState()分支，从而决定是否回调onRestoreInstanceState()方法&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;3.4 停止应用&lt;/h4&gt;

&lt;p&gt;msg: &lt;code class=&quot;highlighter-rouge&quot;&gt;STOP_ACTIVITY_HIDE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用链&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActivityThread.handleStopActivity
	ActivityThread.performStopActivityInner
		ActivityThread.callCallActivityOnSaveInstanceState
			Instrumentation.callActivityOnSaveInstanceState
				Activity.performSaveInstanceState
					Activity.onSaveInstanceState

		ActivityThread.performStop
			Activity.performStop
				Instrumentation.callActivityOnStop
					Activity.onStop

	updateVisibility

	H.post(StopInfo)
		AMP.activityStopped
			AMS.activityStopped
				ActivityStack.activityStoppedLocked
				AMS.trimApplications
					ProcessRecord.kill
					ApplicationThread.scheduleExit
						Looper.myLooper().quit()

					AMS.cleanUpApplicationRecordLocked
					AMS.updateOomAdjLocked
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;App角度&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.onSaveInstanceState&lt;/li&gt;
  &lt;li&gt;Activity.onStop&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在停止Activity的过程，会有一个trimApplications()的操作，主要是kill空进程，将当前进程退出loop循环，清理应用的上下文环境，并且更新进程的Adj值。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;3.5 销毁应用&lt;/h4&gt;

&lt;p&gt;msg: &lt;code class=&quot;highlighter-rouge&quot;&gt;DESTROY_ACTIVITY&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用链&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActivityThread.handleDestroyActivity
	ActivityThread.performDestroyActivity
		Instrumentation.callActivityOnPause
		Activity.performStop()
		Instrumentation.callActivityOnDestroy
			Activity.performDestroy
				Window.destroy
				Activity.onDestroy

	AMP.activityDestroyed
		AMS.activityDestroyed
			ActivityStack.activityDestroyedLocked
				ActivityStackSupervisor.resumeTopActivitiesLocked
					ActivityStack.resumeTopActivityLocked
						ActivityStack.resumeTopActivityInnerLocked
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;App角度&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Activity.onDestroy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;销毁应用后，会查看第一个没有结束的Activity，用于显示在最顶层界面，当不存在未结束的Activity时，则显示Launcher界面，即主界面。&lt;/p&gt;

&lt;h4 id=&quot;intent&quot;&gt;3.6 创建Intent&lt;/h4&gt;

&lt;p&gt;msg: &lt;code class=&quot;highlighter-rouge&quot;&gt;NEW_INTENT&lt;/code&gt; （打开已经处于栈顶的Activity，则会发送给NEW_INTENT消息给主线程）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用链&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActivityThread.handleNewIntent
	performNewIntents
		Instrumentation.callActivityOnPause
			Activity.performPause
				Activity.onPause

		deliverNewIntents
			Instrumentation.callActivityOnNewIntent
				Activity.onNewIntent

		Activity.performResume
			Activity.performRestart
				Instrumentation.callActivityOnRestart
					Activity.onRestart

				Activity.performStart
					Instrumentation.callActivityOnStart
						Activity.onStart

			Instrumentation.callActivityOnResume
				Activity.onResume
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;App角度&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.onPause&lt;/li&gt;
  &lt;li&gt;Activity.onNewIntent&lt;/li&gt;
  &lt;li&gt;Activity.onRestart&lt;/li&gt;
  &lt;li&gt;Activity.onStart&lt;/li&gt;
  &lt;li&gt;Activity.onResume&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文主要是概括性讲述Activity的调用过程，后续会再从源码角度进一步细说Activity生命周期。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;如果觉得本文对您有所帮助，请关注我的&lt;strong&gt;微信公众号：gityuan&lt;/strong&gt;， &lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;。 或者&lt;a href=&quot;http://gityuan.com/about/&quot;&gt;点击这里查看更多关于gityuan的信息&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Mar 2016 04:09:12 +0800</pubDate>
        <link>http://gityuan.com/2016/03/13/start-activity/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/03/13/start-activity/</guid>
        
        <category>android</category>
        
        <category>boot</category>
        
        <category>activity</category>
        
        
      </item>
    
      <item>
        <title>startService流程分析</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;基于Android 6.0的源码剖析， 分析android Service启动流程中ActivityManagerService所扮演的角色&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/frameworks/base/services/core/java/com/android/server/am/ActiveServices.java
/frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java
/frameworks/base/services/core/java/com/android/server/am/ProcessRecord.java

/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
/frameworks/base/core/java/android/app/IActivityManager.java
/frameworks/base/core/java/android/app/ActivityManagerNative.java (内含ActivityManagerProxy类)
/frameworks/base/core/java/android/app/ActivityManager.java

/frameworks/base/core/java/android/app/IApplicationThread.java
/frameworks/base/core/java/android/app/ApplicationThreadNative.java (内含ApplicationThreadProxy类)
/frameworks/base/core/java/android/app/ActivityThread.java (内含ApplicationThread类)

/frameworks/base/core/java/android/app/ContextImpl.java
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;看过前面介绍&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/&quot;&gt;Binder系列&lt;/a&gt;文章，相信对Binder架构有了较深地理解。在&lt;a href=&quot;http://gityuan.com/2016/01/03/android-boot/&quot;&gt;Android系统启动-开篇&lt;/a&gt;中讲述了Binder的地位是非常之重要，整个Java framework的提供ActivityManagerService、PackageManagerService等服务都是基于Binder架构来通信的，另外
&lt;a href=&quot;http://gityuan.com/2015/12/26/handler-message/&quot;&gt;handle消息机制&lt;/a&gt;在进程内的通信使用非常多。本文将开启对ActivityManagerService的分析。&lt;/p&gt;

&lt;p&gt;ActivityManagerService是Android的Java framework的服务框架最重要的服务之一。对于Andorid的Activity、Service、Broadcast、ContentProvider四剑客的管理，包含其生命周期都是通过ActivityManagerService来完成的。对于这四剑客的介绍，此处先略过，后续博主会针对这4剑客分别阐述。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面先看看ActivityManagerService相关的类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-service/am/activity_manager_classes.png&quot; alt=&quot;activity_manager_classes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;单单就一个ActivityManagerService.java文件就代码超过20000万行，我们需要需要一个线，再结合binder的知识，来把我们想要了解的东西串起来，那么本文将从App启动的视角来分析ActivityManagerService。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在app中启动一个service，就一行语句搞定，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;startService()； //或 binderService()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-service/am/start_service.png&quot; alt=&quot;start_service&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当App通过调用Android API方法startService()或binderService()来生成并启动服务的过程，主要是由ActivityManagerService来完成的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService通过Socket通信方式向Zygote进程请求生成(fork)用于承载服务的进程ActivityThread。此处讲述启动远程服务的过程，即服务运行于单独的进程中，对于运行本地服务则不需要启动服务的过程。ActivityThread是应用程序的主线程；&lt;/li&gt;
  &lt;li&gt;Zygote通过fork的方法，将zygote进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程；&lt;/li&gt;
  &lt;li&gt;ActivityManagerService向新生成的ActivityThread进程，通过Binder方式发送生成服务的请求；&lt;/li&gt;
  &lt;li&gt;ActivityThread启动运行服务，这便于服务启动的简易过程，真正流程远比这服务；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;启动服务的流程图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击查看&lt;a href=&quot;http://gityuan.com/images/android-service/am/Seq_start_service.png&quot;&gt;大图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-service/am/Seq_start_service.png&quot; alt=&quot;Seq_start_service&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中涉及的首字母缩写：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AMP:ActivityManagerProxy&lt;/li&gt;
  &lt;li&gt;AMN:ActivityManagerNative&lt;/li&gt;
  &lt;li&gt;AMS:ActivityManagerService&lt;/li&gt;
  &lt;li&gt;AT:ApplicationThread&lt;/li&gt;
  &lt;li&gt;ATP:ApplicationThreadProxy&lt;/li&gt;
  &lt;li&gt;ATN:ApplicationThreadNative&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;接下来，我们正式从代码角度来分析服务启动的过程。首先在我们应用程序的Activity类的调用startService()方法，该方法调用【流程1】的方法。&lt;/p&gt;

&lt;h3 id=&quot;contextwrapperstartservice&quot;&gt;1. ContextWrapper.startService&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ContextWrapper extends Context {
    @Override
    public ComponentName startService(Intent service) {
        return mBase.startService(service); //其中mBase为ContextImpl对象 【见流程2-1】
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;contextimplstartservice&quot;&gt;2. ContextImpl.startService&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[2-1]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ContextImpl extends Context {
	@Override
    public ComponentName startService(Intent service) {
        //当system进程调用此方法时输出warn信息，system进程建立调用startServiceAsUser方法
        warnIfCallingFromSystemProcess(); 
        return startServiceCommon(service, mUser); //【见流程2-2】
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[2-2]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private ComponentName startServiceCommon(Intent service, UserHandle user) {
    try {
        //检验service，当service为空则throw异常
        validateServiceIntent(service); 
        service.prepareToLeaveProcess();
        // 调用ActivityManagerNative类 【见流程3】
        ComponentName cn = ActivityManagerNative.getDefault().startService(
            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), getOpPackageName(), user.getIdentifier());
        if (cn != null) {
            if (cn.getPackageName().equals(&quot;!&quot;)) {
                throw new SecurityException(&quot;Not allowed to start service &quot; + 
                    service + &quot; without permission &quot; + cn.getClassName());
            } else if (cn.getPackageName().equals(&quot;!!&quot;)) {
                throw new SecurityException(&quot;Unable to start service &quot; + 
                    service  &quot;: &quot; + cn.getClassName());
            }
        }
        return cn;
    } catch (RemoteException e) {
        throw new RuntimeException(&quot;Failure from system&quot;, e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ActivityManagerNative.getDefault()&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static public IActivityManager getDefault() {
    return gDefault.get();
}

//获取IActivityManager的代理类
private static final Singleton&amp;lt;IActivityManager&amp;gt; gDefault = new Singleton&amp;lt;IActivityManager&amp;gt;() {
    protected IActivityManager create() {
        //获取名为&quot;activity&quot;的服务，服务都注册到ServiceManager来统一管理
        IBinder b = ServiceManager.getService(&quot;activity&quot;);
        IActivityManager am = asInterface(b);
        return am;
    }
};

//单例模式，此处的mInstance为IActivityManager类的代理对象，即ActivityManagerProxy。
public abstract class Singleton&amp;lt;T&amp;gt; {
    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该方法返回的是ActivityManagerProxy对象，那么下一步调用ActivityManagerProxy.startService()方法。&lt;/p&gt;

&lt;p&gt;通过Binder通信过程中，提供了一个IActivityManager服务接口，ActivityManagerProxy类与ActivityManagerService类都实现了IActivityManager接口。ActivityManagerProxy作为binder通信的客户端，ActivityManagerService作为binder通信的服务端，根据&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/&quot;&gt;Binder系列&lt;/a&gt;文章，ActivityManagerProxy.startService()最终调用ActivityManagerService.startService()，整个流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-service/am/Activity_Manager_Service.png&quot; alt=&quot;Activity_Manager_Service&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ampstartservice&quot;&gt;3. AMP.startService&lt;/h3&gt;

&lt;p&gt;该类位于文件ActivityManagerNative.java&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ComponentName startService(IApplicationThread caller, Intent service,
            String resolvedType, String callingPackage, int userId) throws RemoteException
{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    service.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeString(callingPackage);
    data.writeInt(userId);
    //通过Binder 传递数据　【见流程4】
    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);
    reply.readException();
    ComponentName res = ComponentName.readFromParcel(reply);
    data.recycle();
    reply.recycle();
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;mRemote.transact()是binder通信的客户端发起方法，经过binder驱动，最后回到binder服务端ActivityManagerNative的onTransact()方法。&lt;/p&gt;

&lt;h3 id=&quot;amnontransact&quot;&gt;4. AMN.onTransact&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException {
    switch (code) {
    ...
     case START_SERVICE_TRANSACTION: {
        data.enforceInterface(IActivityManager.descriptor);
        IBinder b = data.readStrongBinder();
        //生成ApplicationThreadNative的代理对象，即ApplicationThreadProxy对象
        IApplicationThread app = ApplicationThreadNative.asInterface(b);
        Intent service = Intent.CREATOR.createFromParcel(data);
        String resolvedType = data.readString();
        String callingPackage = data.readString();
        int userId = data.readInt();
        //调用ActivityManagerService的startService()方法【见流程5】
        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);
        reply.writeNoException();
        ComponentName.writeToParcel(cn, reply);
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在整个调用过程涉及两个进程，不妨令startService的发起进程记为进程A，ServiceManagerService记为进程B；那么进程A通过Binder机制（采用IActivityManager接口）向进程B发起请求服务，进程B则通过Binder机制(采用IApplicationThread接口)向进程A发起请求服务。也就是说进程A与进程B能相互间主动发起请求，进程通信。&lt;/p&gt;

&lt;p&gt;这里涉及IApplicationThread，那么下面直接把其相关的类图展示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-service/am/application_thread_classes.png&quot; alt=&quot;application_thread_classes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与IActivityManager的binder通信原理一样，ApplicationThreadProxy作为binder通信的客户端，ApplicationThreadNative作为Binder通信的服务端,ApplicationThread继承ApplicationThreadProxy类，覆写其中的部分方法。&lt;/p&gt;

&lt;h3 id=&quot;amsstartservice&quot;&gt;5. AMS.startService&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public ComponentName startService(IApplicationThread caller, Intent service,
        String resolvedType, String callingPackage, int userId)
        throws TransactionTooLargeException {
    //当调用者是孤立进程，则抛出异常。
    enforceNotIsolatedCaller(&quot;startService&quot;); 
    
    if (service != null &amp;amp;&amp;amp; service.hasFileDescriptors() == true) {
        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);
    }
    if (callingPackage == null) {
        throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);
    }
    if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,
            &quot;startService: &quot; + service + &quot; type=&quot; + resolvedType);

    synchronized(this) {
        final int callingPid = Binder.getCallingPid(); //调用者pid
        final int callingUid = Binder.getCallingUid(); //调用者uid
        final long origId = Binder.clearCallingIdentity();
        //此次的mServices为ActiveServices对象 【见流程6-1】
        ComponentName res = mServices.startServiceLocked(caller, service,
                resolvedType, callingPid, callingUid, callingPackage, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该方法参数说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;caller：IApplicationThread类型，复杂处理&lt;/li&gt;
  &lt;li&gt;service：Intent类型，包含需要运行的service信息&lt;/li&gt;
  &lt;li&gt;resolvedType：String类型&lt;/li&gt;
  &lt;li&gt;callingPackage: String类型，调用该方法的package&lt;/li&gt;
  &lt;li&gt;userId: int类型，用户的id&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;activeservicesstartservicelocked&quot;&gt;6. ActiveServices.startServiceLocked&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[6-1]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,
        int callingPid, int callingUid, String callingPackage, int userId)
        throws TransactionTooLargeException {

    final boolean callerFg;
    if (caller != null) {
        final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
        if (callerApp == null) 
            throw new SecurityException(&quot;&quot;); //抛出异常，此处省略异常字符串
        callerFg = callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
    } else {
        callerFg = true;
    }
    //检索服务信息 
    ServiceLookupResult res =  retrieveServiceLocked(service, resolvedType, callingPackage,
                callingPid, callingUid, userId, true, callerFg);
    if (res == null) {
        return null;
    }
    if (res.record == null) {
        return new ComponentName(&quot;!&quot;, res.permission != null
                ? res.permission : &quot;private to package&quot;);
    }
    ServiceRecord r = res.record;
    if (!mAm.getUserManagerLocked().exists(r.userId)) { //检查是否存在启动服务的user
        return null;
    }
    NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked(
            callingUid, r.packageName, service, service.getFlags(), null, r.userId);

    r.lastActivity = SystemClock.uptimeMillis();
    r.startRequested = true;
    r.delayedStop = false;
    r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
            service, neededGrants));
    final ServiceMap smap = getServiceMap(r.userId);
    boolean addToStarting = false;
    //对于非前台进程的调度
    if (!callerFg &amp;amp;&amp;amp; r.app == null &amp;amp;&amp;amp; mAm.mStartedUsers.get(r.userId) != null) {
        ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, false);
        if (proc == null || proc.curProcState &amp;gt; ActivityManager.PROCESS_STATE_RECEIVER) {
            if (r.delayed) {  //已计划延迟启动
                return r.name;
            }
            if (smap.mStartingBackground.size() &amp;gt;= mMaxStartingBackground) {
                //当超出 同一时间允许后续启动的最大服务数，则将该服务加入延迟启动的队列。
                smap.mDelayedStartList.add(r);
                r.delayed = true;
                return r.name;
            }
            addToStarting = true;
        } else if (proc.curProcState &amp;gt;= ActivityManager.PROCESS_STATE_SERVICE) {
            //将新的服务加入到后台启动队列，该队列也包含当前正在运行其他services或者receivers的进程
            addToStarting = true;
        } 
    } 
    return startServiceInnerLocked(smap, service, r, callerFg, addToStarting); //【见流程6-2】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[6-2]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,
        boolean callerFg, boolean addToStarting) throws TransactionTooLargeException {
    ProcessStats.ServiceState stracker = r.getTracker();
    if (stracker != null) {
        stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);
    }
    r.callStart = false;
    synchronized (r.stats.getBatteryStats()) {
        r.stats.startRunningLocked(); //用于耗电统计，开启运行的状态
    }
    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); //【见流程6-3】
    if (error != null) {
        return new ComponentName(&quot;!!&quot;, error);
    }
    if (r.startRequested &amp;amp;&amp;amp; addToStarting) {
        boolean first = smap.mStartingBackground.size() == 0;
        smap.mStartingBackground.add(r);
        r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT;
        if (first) {
            smap.rescheduleDelayedStarts();
        }
    } else if (callerFg) {
        smap.ensureNotStartingBackground(r);
    }
    return r.name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[6-3]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
        boolean whileRestarting) throws TransactionTooLargeException {
    if (r.app != null &amp;amp;&amp;amp; r.app.thread != null) {
        sendServiceArgsLocked(r, execInFg, false);
        return null;
    }
    if (!whileRestarting &amp;amp;&amp;amp; r.restartDelay &amp;gt; 0) {
        return null; //等待延迟重启的过程，则直接返回
    }

    // 启动service前，把service从重启服务队列中移除
    if (mRestartingServices.remove(r)) {
        r.resetRestartCounter();
        clearRestartingIfNeededLocked(r);
    }
    //service正在启动，将delayed设置为false
    if (r.delayed) {
        getServiceMap(r.userId).mDelayedStartList.remove(r);
        r.delayed = false;
    }

    //确保拥有该服务的user已经启动，否则停止；
    if (mAm.mStartedUsers.get(r.userId) == null) {
        String msg = &quot;&quot;;
        bringDownServiceLocked(r);
        return msg;
    }
    //服务正在启动，设置package停止状态为false
    try {
        AppGlobals.getPackageManager().setPackageStoppedState(
                r.packageName, false, r.userId);
    } catch (RemoteException e) {
    } catch (IllegalArgumentException e) {
        Slog.w(TAG, &quot;Failed trying to unstop package &quot; + r.packageName + &quot;: &quot; + e);
    }

    final boolean isolated = (r.serviceInfo.flags&amp;amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
    final String procName = r.processName;
    ProcessRecord app;
    if (!isolated) {
        //根据进程名和uid，查询ProcessRecord
        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
        if (app != null &amp;amp;&amp;amp; app.thread != null) {
            try {
                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                // 启动服务 【见流程10-2】
                realStartServiceLocked(r, app, execInFg); 
                return null;
            } catch (TransactionTooLargeException e) {
                throw e;
            } catch (RemoteException e) {
                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);
            }
        }
    } else {
        app = r.isolatedProc;
    }

    //对于进程没有启动的情况
    if (app == null) {
        //启动service所要运行的进程 【见流程7-1】
        if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                &quot;service&quot;, r.name, false, isolated, false)) == null) {
            String msg = &quot;&quot; 
            bringDownServiceLocked(r); // 进程启动失败
            return msg;
        }
        if (isolated) {
            r.isolatedProc = app;
        }
    }
    if (!mPendingServices.contains(r)) {
        mPendingServices.add(r); 
    }
    if (r.delayedStop) {
        r.delayedStop = false;
        if (r.startRequested) {
            stopServiceLocked(r); //停止服务
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于非前台进程调用而需要启动的服务，如果已经有其他的后台服务正在启动中，那么我们可能希望延迟其启动。这是用来避免启动同时启动过多的进程(非必须的)。&lt;/p&gt;

&lt;h3 id=&quot;amsstartprocesslocked&quot;&gt;7. AMS.startProcessLocked&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[7-1]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final ProcessRecord startProcessLocked(String processName,
        ApplicationInfo info, boolean knownToBeDead, int intentFlags,
        String hostingType, ComponentName hostingName, boolean allowWhileBooting,
        boolean isolated, boolean keepIfLarge) {
    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,
            hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,
            null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,
            null /* crashHandler */);  //【见7-2】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[7-2]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
    long startTime = SystemClock.elapsedRealtime();
    ProcessRecord app;
    if (!isolated) {
        //根据进程名和uid检查相应的ProcessRecord
        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);

        if ((intentFlags &amp;amp; Intent.FLAG_FROM_BACKGROUND) != 0) {
            //如果当前处理后台进程，检查当前进程是否处理bad进程列表
            if (mBadProcesses.get(info.processName, info.uid) != null) {
                return null;
            }
        } else {
            //当用户明确地启动进程，则清空crash次数，以保证其不处于bad进程直到下次再弹出crash对话框。
            mProcessCrashTimes.remove(info.processName, info.uid);
            if (mBadProcesses.get(info.processName, info.uid) != null) {
                mBadProcesses.remove(info.processName, info.uid);
                if (app != null) {
                    app.bad = false;
                }
            }
        }
    } else {
        //对于孤立进程，无法再利用已存在的进程
        app = null;
    }

    if (app != null &amp;amp;&amp;amp; app.pid &amp;gt; 0) {
        if (!knownToBeDead || app.thread == null) {
            //如果这是进程中新package，则添加到列表
            app.addPackage(info.packageName, info.versionCode, mProcessStats);
            return app;
        }
        //当application record已经被attached到先前的一个进程，则杀死该进程
        // clean it up now.
        killProcessGroup(app.info.uid, app.pid);
        handleAppDiedLocked(app, true, true);
    }
    String hostingNameStr = hostingName != null? hostingName.flattenToShortString() : null;
    if (app == null) {
        // 创建新的Process Record对象
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
        if (app == null) {
            return null;
        }
        app.crashHandler = crashHandler;
    } else {
        ////如果这是进程中新package，则添加到列表
        app.addPackage(info.packageName, info.versionCode, mProcessStats);
    }
    //当系统未准备完毕，则将当前进程加入到mProcessesOnHold
    if (!mProcessesReady &amp;amp;&amp;amp; !isAllowedWhileBooting(info) &amp;amp;&amp;amp; !allowWhileBooting) {
        if (!mProcessesOnHold.contains(app)) {
            mProcessesOnHold.add(app);
        }
        return app;
    }
    // 启动进程【7-3】
    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    return (app.pid != 0) ? app : null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[7-3]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final void startProcessLocked(ProcessRecord app, String hostingType,
        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    //当app的pid大于0且不是当前进程的pid，则从mPidsSelfLocked中移除该app.pid
    if (app.pid &amp;gt; 0 &amp;amp;&amp;amp; app.pid != MY_PID) {
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        app.setPid(0);
    }

    mProcessesOnHold.remove(app);
    updateCpuStats(); //更新cpu统计信息
    try {
        try {
            if (AppGlobals.getPackageManager().isPackageFrozen(app.info.packageName)) {
                //当前package已被冻结
                throw new RuntimeException(&quot;Package &quot; + app.info.packageName + &quot; is frozen!&quot;);
            }
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                //通过Package Manager获取gids
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(
                        MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid,
                        app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            
            //添加共享app和gids，用于app直接共享资源
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[2];
            } else {
                gids = new int[permGids.length + 2];
                System.arraycopy(permGids, 0, gids, 2, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }

        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL
                    &amp;amp;&amp;amp; mTopComponent != null &amp;amp;&amp;amp; app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL
                    &amp;amp;&amp;amp; (app.info.flags&amp;amp;ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        //在AndroidManifest.xml中设置androidd:debuggable为true，代表app运行在debug模式
        if ((app.info.flags &amp;amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
            //开启 检查JNI功能
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // 在AndroidManifest.xml中设置androidd:vmSafeMode为true，代表app运行在安全模式
        if ((app.info.flags &amp;amp; ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if (&quot;1&quot;.equals(SystemProperties.get(&quot;debug.checkjni&quot;))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String jitDebugProperty = SystemProperties.get(&quot;debug.usejit&quot;);
        if (&quot;true&quot;.equals(jitDebugProperty)) {
            debugFlags |= Zygote.DEBUG_ENABLE_JIT;
        } else if (!&quot;false&quot;.equals(jitDebugProperty)) {
            if (&quot;true&quot;.equals(SystemProperties.get(&quot;dalvik.vm.usejit&quot;))) {
                debugFlags |= Zygote.DEBUG_ENABLE_JIT;
            }
        }
        String genDebugInfoProperty = SystemProperties.get(&quot;debug.generate-debug-info&quot;);
        if (&quot;true&quot;.equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if (&quot;1&quot;.equals(SystemProperties.get(&quot;debug.jni.logging&quot;))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if (&quot;1&quot;.equals(SystemProperties.get(&quot;debug.assert&quot;))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;

        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;
        //请求Zygote创建新进程 【见流程8，此处跳级见后面说明】 
        Process.ProcessStartResult startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                app.info.dataDir, entryPointArgs);

        if (app.isolated) {
            mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid);
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }

        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        //将新创建的进程加入到mPidsSelfLocked
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                //延迟发送消息PROC_START_TIMEOUT_MSG
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
    } catch (RuntimeException e) {
        //进程创建失败
        app.setPid(0);
        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
        if (app.isolated) {
            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于&lt;strong&gt;Process.start()&lt;/strong&gt;是通过socket通信，告知&lt;a href=&quot;http://gityuan.com/2016/02/13/android-zygote/&quot;&gt;Zygote&lt;/a&gt;创建fork子进程，创建完新进程，将ActivityThread类加载到新进程，并调用ActivityThread.main()方法。该过程详细情况，见&lt;a href=&quot;http://gityuan.com/2016/03/26/app-process-create/&quot;&gt;Android Process创建过程分析&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;activitythreadmain&quot;&gt;8. ActivityThread.main&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[8-1]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    //性能统计默认是关闭的
    SamplingProfilerIntegration.start();
    CloseGuard.setEnabled(false);
    Environment.initForCurrentUser();
    EventLogger.setReporter(new EventLoggingReporter());
    AndroidKeyStoreProvider.install();
    //确保可信任的CA证书存放在正确的位置
    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
    TrustedCertificateStore.setDefaultUserDirectory(configDir);
    Process.setArgV0(&quot;&amp;lt;pre-initialized&amp;gt;&quot;);

    Looper.prepareMainLooper();
    //创建ActivityThread对象
    ActivityThread thread = new ActivityThread(); 
    //建立Binder通道 【见流程8-2】
    thread.attach(false);
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    // 当设置为true时，可打开消息队列的debug log信息
    if (false) {
        Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }
    Looper.loop(); //消息循环运行
    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处的&lt;code class=&quot;highlighter-rouge&quot;&gt;mAppThread = new ApplicationThread()&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[8-2]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void attach(boolean system) {
    sCurrentActivityThread = this;
    mSystemThread = system;
    if (!system) {
        ViewRootImpl.addFirstDrawHandler(new Runnable() {
            @Override
            public void run() {
                ensureJitEnabled(); //开启虚拟机的jit即时编译功能
            }
        });
        android.ddm.DdmHandleAppName.setAppName(&quot;&amp;lt;pre-initialized&amp;gt;&quot;, UserHandle.myUserId());
        RuntimeInit.setApplicationObject(mAppThread.asBinder());
        //创建ActivityManagerProxy对象
        final IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            //调用基于IActivityManager接口的Binder通道【见流程9-1】
            mgr.attachApplication(mAppThread); 
        } catch (RemoteException ex) {
            // Ignore
        }

        //观察是否快接近heap的上限 
        BinderInternal.addGcWatcher(new Runnable() {
            @Override public void run() {
                if (!mSomeActivitiesChanged) {
                    return;
                }
                Runtime runtime = Runtime.getRuntime();
                long dalvikMax = runtime.maxMemory();
                long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();
                if (dalvikUsed &amp;gt; ((3*dalvikMax)/4)) {
                    mSomeActivitiesChanged = false;
                    try {
                        mgr.releaseSomeActivities(mAppThread); //释放空间
                    } catch (RemoteException e) {
                    }
                }
            }
        });
    } else {
        android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId());
        try {
            mInstrumentation = new Instrumentation();
            ContextImpl context = ContextImpl.createAppContext(
                    this, getSystemContext().mPackageInfo);
            mInitialApplication = context.mPackageInfo.makeApplication(true, null);
            mInitialApplication.onCreate();
        } catch (Exception e) {
            throw new RuntimeException(&quot;Unable to instantiate Application():&quot; + e.toString(), e);
        }
    }
    //添加dropbox日志到libcore
    DropBox.setReporter(new DropBoxReporter());
    ViewRootImpl.addConfigCallback(new ComponentCallbacks2() {
        @Override
        public void onConfigurationChanged(Configuration newConfig) {
            synchronized (mResourcesManager) {
                if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) {
                    if (mPendingConfiguration == null ||
                            mPendingConfiguration.isOtherSeqNewer(newConfig)) {
                        mPendingConfiguration = newConfig;
                        sendMessage(H.CONFIGURATION_CHANGED, newConfig);
                    }
                }
            }
        }
        @Override
        public void onLowMemory() {
        }
        @Override
        public void onTrimMemory(int level) {
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ampattachapplication&quot;&gt;9. AMP.attachApplication&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[9-1] ActivityManagerProxy.attachApplication&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void attachApplication(IApplicationThread app) throws RemoteException
{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(app.asBinder());
    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); //【见流程9-2】
    reply.readException();
    data.recycle();
    reply.recycle();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[9-2] ActivityManagerNative.onTransact&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException {
    switch (code) {
    ...
     case ATTACH_APPLICATION_TRANSACTION: {
        data.enforceInterface(IActivityManager.descriptor);
        IApplicationThread app = ApplicationThreadNative.asInterface(
                data.readStrongBinder());
        if (app != null) {
            attachApplication(app); //此处是ActivityManagerService类中的方法 【见流程9-3】
        }
        reply.writeNoException();
        return true;
    }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[9-3] ActivityManagerService.attachApplication&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public final void attachApplication(IApplicationThread thread) {
    synchronized (this) {
        int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid); // 【见流程9-4】
        Binder.restoreCallingIdentity(origId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[9-4]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid) {
    ProcessRecord app;
    if (pid != MY_PID &amp;amp;&amp;amp; pid &amp;gt;= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid); // 根据pid获取 ProcessRecord
        }
    } else {
        app = null;
    }
    if (app == null) {
        //ProcessRecord为空，则杀掉该进程
        if (pid &amp;gt; 0 &amp;amp;&amp;amp; pid != MY_PID) {
            Process.killProcessQuiet(pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
                // Ignore exceptions.
            }
        }
        return false;
    }
    //如果这个ProcessRecord附到上一个进程，则立刻清空
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }

    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);//绑定死亡通知
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, &quot;link fail&quot;, processName); //重新启动进程
        return false;
    }

    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = -100;
    app.curSchedGroup = app.setSchedGroup = Process.THREAD_GROUP_DEFAULT;
    app.forcingToForeground = null;
    // 更新前台进程
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); //移除进程启动超时的消息
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List&amp;lt;ProviderInfo&amp;gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    
    try {
        int testMode = IApplicationThread.DEBUG_OFF;
        if (mDebugApp != null &amp;amp;&amp;amp; mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger
                ? IApplicationThread.DEBUG_WAIT: IApplicationThread.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        String profileFile = app.instrumentationProfileFile;
        ParcelFileDescriptor profileFd = null;
        int samplingInterval = 0;
        boolean profileAutoStop = false;
        if (mProfileApp != null &amp;amp;&amp;amp; mProfileApp.equals(processName)) {
            mProfileProc = app;
            profileFile = mProfileFile;
            profileFd = mProfileFd;
            samplingInterval = mSamplingInterval;
            profileAutoStop = mAutoStopProfiler;
        }
        boolean enableOpenGlTrace = false;
        if (mOpenGlTraceApp != null &amp;amp;&amp;amp; mOpenGlTraceApp.equals(processName)) {
            enableOpenGlTrace = true;
            mOpenGlTraceApp = null;
        }

        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null &amp;amp;&amp;amp; mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = (mBackupTarget.backupMode == BackupRecord.RESTORE)
                    || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL)
                    || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
        }
        ensurePackageDexOpt(app.instrumentationInfo != null
                ? app.instrumentationInfo.packageName
                : app.info.packageName);
        if (app.instrumentationClass != null) {
            ensurePackageDexOpt(app.instrumentationClass.getPackageName());
        }
      
        ApplicationInfo appInfo = app.instrumentationInfo != null
                ? app.instrumentationInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profileFd != null) {
            profileFd = profileFd.dup();
        }
        ProfilerInfo profilerInfo = profileFile == null ? null
                : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);
        // 绑定应用
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                isRestrictedBackupMode || !normalMode, app.persistent,
                new Configuration(mConfiguration), app.compat,
                getCommonServicesLocked(app.isolated),
                mCoreSettingsObserver.getCoreSettingsLocked());
        //更新进程LRU队列
        updateLruProcessLocked(app, false, null);
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        //这里有很可能会导致进程无限重启
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, &quot;bind fail&quot;, processName);
        return false;
    }
    
    mPersistentStartingProcesses.remove(app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    //检查最顶层可见的Activity是否等待在该进程中运行
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            badApp = true;
        }
    }
    //寻找所有需要在该进程中运行的服务 【见流程10-1】
    if (!badApp) {
        try { 
            didSomething |= mServices.attachApplicationLocked(app, processName);
        } catch (Exception e) {
            badApp = true;
        }
    }
    //检查是否在这个进程中有下一个广播接收者
    if (!badApp &amp;amp;&amp;amp; isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
        } catch (Exception e) {
            badApp = true;
        }
    }
    //检查是否在这个进程中有下一个backup代理
    if (!badApp &amp;amp;&amp;amp; mBackupTarget != null &amp;amp;&amp;amp; mBackupTarget.appInfo.uid == app.uid) {
        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,
                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),
                    mBackupTarget.backupMode);
        } catch (Exception e) {
            badApp = true;
        }
    }
    if (badApp) { //杀掉bad应用
        app.kill(&quot;error during init&quot;, true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked(); //更新adj的值
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;attachapplicationlocked&quot;&gt;10. attachApplicationLocked&lt;/h3&gt;

&lt;p&gt;[-&amp;gt; ActiveServices.java]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[10-1]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean attachApplicationLocked(ProcessRecord proc, String processName)
        throws RemoteException {
    boolean didSomething = false;
    //启动mPendingServices队列中，等待在该进程启动的服务
    if (mPendingServices.size() &amp;gt; 0) {
        ServiceRecord sr = null;
        try {
            for (int i=0; i&amp;lt;mPendingServices.size(); i++) {
                sr = mPendingServices.get(i);
                if (proc != sr.isolatedProc &amp;amp;&amp;amp; (proc.uid != sr.appInfo.uid
                        || !processName.equals(sr.processName))) {
                    continue;
                }
                mPendingServices.remove(i);
                i--;
                // 将当前服务的包信息加入到proc
                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,
                        mAm.mProcessStats);
                // 启动服务，即将进入服务的生命周期 【见流程10-2】
                realStartServiceLocked(sr, proc, sr.createdFromFg);
                didSomething = true;
            }
        } catch (RemoteException e) {
            Slog.w(TAG, &quot;Exception in new application when starting service &quot;
                    + sr.shortName, e);
            throw e;
        }
    }
    // 对于正在等待重启并需要运行在该进程的服务，现在是启动它们的大好时机
    if (mRestartingServices.size() &amp;gt; 0) {
        ServiceRecord sr = null;
        for (int i=0; i&amp;lt;mRestartingServices.size(); i++) {
            sr = mRestartingServices.get(i);
            if (proc != sr.isolatedProc &amp;amp;&amp;amp; (proc.uid != sr.appInfo.uid
                    || !processName.equals(sr.processName))) {
                continue;
            }
            mAm.mHandler.removeCallbacks(sr.restarter);
            mAm.mHandler.post(sr.restarter);
        }
    }
    return didSomething;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[10-2]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException {
    if (app.thread == null) {
        throw new RemoteException();
    }

    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    final boolean newService = app.services.add(r);
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try {
        synchronized (r.stats.getBatteryStats()) {
            r.stats.startLaunchedLocked();
        }
        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
        //服务 进入 onCreate() 【见流程11】
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        r.postNotification();
        created = true;
    } catch (DeadObjectException e) {
        mAm.appDiedLocked(app); //应用死亡处理
        throw e;
    } finally {
        if (!created) {
            final boolean inDestroying = mDestroyingServices.contains(r);
            serviceDoneExecutingLocked(r, inDestroying, inDestroying);
            if (newService) {
                app.services.remove(r);
                r.app = null;
            }
            //尝试重新启动服务
            if (!inDestroying) {
                scheduleServiceRestartLocked(r, false);
            }
        }
    }
    requestServiceBindingsLocked(r, execInFg);
    updateServiceClientActivitiesLocked(app, null, true);
    // If the service is in the started state, and there are no
    // pending arguments, then fake up one so its onStartCommand() will
    // be called.
    if (r.startRequested &amp;amp;&amp;amp; r.callStart &amp;amp;&amp;amp; r.pendingStarts.size() == 0) {
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    }
    //服务 进入onStartCommand() 【见流程12-1】
    sendServiceArgsLocked(r, execInFg, true);
    if (r.delayed) {
        getServiceMap(r.userId).mDelayedStartList.remove(r);
        r.delayed = false;
    }
    if (r.delayedStop) {
        r.delayedStop = false;
        if (r.startRequested) {
            stopServiceLocked(r); //停止服务
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;schedulecreateservice&quot;&gt;11. scheduleCreateService&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[11-1] ApplicationThreadProxy.scheduleCreateService&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void scheduleCreateService(IBinder token, ServiceInfo info,
        CompatibilityInfo compatInfo, int processState) throws RemoteException {
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(token);
    info.writeToParcel(data, 0);
    compatInfo.writeToParcel(data, 0);
    data.writeInt(processState);
    try {
        //【见流程11-2】
        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY);
    } catch (TransactionTooLargeException e) {
        throw e;
    }
    data.recycle();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[11-2] ApplicationThreadNative.onTransact&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException {
    switch (code) {
    case SCHEDULE_CREATE_SERVICE_TRANSACTION: {
        data.enforceInterface(IApplicationThread.descriptor);
        IBinder token = data.readStrongBinder();
        ServiceInfo info = ServiceInfo.CREATOR.createFromParcel(data);
        CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);
        int processState = data.readInt();
        // 【见流程11-3】
        scheduleCreateService(token, info, compatInfo, processState);
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[11-3] ApplicationThread.scheduleCreateService&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;位于ActivityThread线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void scheduleCreateService(IBinder token,
            ServiceInfo info, CompatibilityInfo compatInfo, int processState) {
    updateProcessState(processState, false);
    CreateServiceData s = new CreateServiceData(); //准备服务创建所需的数据
    s.token = token;
    s.info = info;
    s.compatInfo = compatInfo;
    sendMessage(H.CREATE_SERVICE, s); //发送消息 【见流程12-1】
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;handlecreateservice&quot;&gt;12. handleCreateService&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[12-1] ActivityThread.H&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void handleMessage(Message msg) {
    switch (msg.what) {
        ...

        case CREATE_SERVICE:
            handleCreateService((CreateServiceData)msg.obj); //【见流程12-2】
            break;
        case BIND_SERVICE:
            handleBindService((BindServiceData)msg.obj);
            break;
        case UNBIND_SERVICE:
            handleUnbindService((BindServiceData)msg.obj);
            break;
        case SERVICE_ARGS: 
            handleServiceArgs((ServiceArgsData)msg.obj);  // serviceStart
            break;
        case STOP_SERVICE:
            handleStopService((IBinder)msg.obj);
            maybeSnapshot();
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[12-2]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void handleCreateService(CreateServiceData data) {
    //当应用处于后台即将进行GC，而此时被调回到活动状态，则跳过本次gc。
    unscheduleGcIdler();
    //生成服务对象
    LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);
    Service service = null;
    try {
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        //
        service = (Service) cl.loadClass(data.info.name).newInstance();
    } catch (Exception e) {
        if (!mInstrumentation.onException(service, e)) {
            throw new RuntimeException(
                &quot;Unable to instantiate service &quot; + data.info.name + &quot;: &quot; + e.toString(), e);
        }
    }
    try {
        //创建ContextImpl对象
        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
        context.setOuterContext(service);
        Application app = packageInfo.makeApplication(false, mInstrumentation);
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManagerNative.getDefault());
        service.onCreate(); //调用服务的 onCreate()方法 【见流程13】
        mServices.put(data.token, service);
        try {
            ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        } catch (RemoteException e) {
            // nothing to do.
        }
    } catch (Exception e) {
        if (!mInstrumentation.onException(service, e)) {
            throw new RuntimeException(
                &quot;Unable to create service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;serviceoncreate&quot;&gt;13. Service.onCreate&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public abstract class Service extends ContextWrapper implements ComponentCallbacks2 {
    public void onCreate(){	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终调用到抽象类Service.onCreate()方法，对于真正的Service都会通过覆写该方式，调用真正的onCreate()方法。拨云见日，到此总算是进入了Service的生命周期。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;在整个startService过程，从进程角度看服务启动过程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Process A进程：&lt;/strong&gt;是指调用startService命令所在的进程，也就是启动服务的发起端进程，比如点击桌面App图标，此处Process A便是Launcher所在进程。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;system_server进程：&lt;/strong&gt;系统进程，是java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的，每个进程binder线程个数的上限为16。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Zygote进程：&lt;/strong&gt;是由&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;进程孵化而来的，用于创建Java层进程的母体，所有的Java层进程都是由Zygote进程孵化而来；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Remote Service进程：&lt;/strong&gt;远程服务所在进程，是由Zygote进程孵化而来的用于运行Remote服务的进程。主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），当然还有其他线程，这里不是重点就不提了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-service/start_service/start_service_processes.jpg&quot; alt=&quot;start_service_process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中涉及3种IPC通信方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Socket&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;，在图中分别用3种不同的颜色来代表这3种通信方式。一般来说，同一进程内的线程间通信采用的是 &lt;a href=&quot;http://gityuan.com/2015/12/26/handler-message/&quot;&gt;Handler消息队列机制&lt;/a&gt;，不同进程间的通信采用的是&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/&quot;&gt;binder机制&lt;/a&gt;，另外与Zygote进程通信采用的&lt;code class=&quot;highlighter-rouge&quot;&gt;Socket&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;启动流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Process A进程采用Binder IPC向system_server进程发起startService请求；&lt;/li&gt;
  &lt;li&gt;system_server进程接收到请求后，向zygote进程发送创建进程的请求；&lt;/li&gt;
  &lt;li&gt;zygote进程fork出新的子进程Remote Service进程；&lt;/li&gt;
  &lt;li&gt;Remote Service进程，通过Binder IPC向sytem_server进程发起attachApplication请求；&lt;/li&gt;
  &lt;li&gt;system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向remote Service进程发送scheduleCreateService请求；&lt;/li&gt;
  &lt;li&gt;Remote Service进程的binder线程在收到请求后，通过handler向主线程发送CREATE_SERVICE消息；&lt;/li&gt;
  &lt;li&gt;主线程在收到Message后，通过发射机制创建目标Service，并回调Service.onCreate()方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到此，服务便正式启动完成。当创建的是本地服务时，无需经过上述步骤2、3，直接创建服务即可。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;如果觉得本文对您有所帮助，请关注我的&lt;strong&gt;微信公众号：gityuan&lt;/strong&gt;， &lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;。 或者&lt;a href=&quot;http://gityuan.com/about/&quot;&gt;点击这里查看更多关于我的信息&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Mar 2016 04:12:50 +0800</pubDate>
        <link>http://gityuan.com/2016/03/07/start-service/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/03/07/start-service/</guid>
        
        <category>android</category>
        
        <category>boot</category>
        
        <category>service</category>
        
        
      </item>
    
      <item>
        <title>Binder IPC的权限控制</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;基于Android 6.0的源码剖析， 分析Binder IPC通信的权限控制方法clearCallingIdentity和restoreCallingIdentity的原理和用途。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/frameworks/base/core/java/android/os/Binder.java
/frameworks/base/core/jni/android_util_Binder.cpp
/frameworks/native/libs/binder/IPCThreadState.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;一、概述&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/&quot;&gt;Binder系列&lt;/a&gt;中通过十篇文章，深入探讨了Android M的Binder IPC机制。看过Android系统源代码的朋友，一定看到过&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.clearCallingIdentity()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.restoreCallingIdentity()&lt;/code&gt;这两个方法，其定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.java&lt;/code&gt;文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//作用是清空远程调用端的uid和pid，用当前本地进程的uid和pid替代；
public static final native long clearCallingIdentity();
//作用是恢复远程调用端的uid和pid信息，正好是`clearCallingIdentity`的反过程;
public static final native void restoreCallingIdentity(long token);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两个方法涉及的uid和pid，每个线程都有自己独一无二的&lt;code class=&quot;highlighter-rouge&quot;&gt;IPCThreadState&lt;/code&gt;对象，记录当前线程的pid和uid，可通过方法&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.getCallingPid()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.getCallingUid()&lt;/code&gt;获取相应的pid和uid。&lt;/p&gt;

&lt;p&gt;clearCallingIdentity(), restoreCallingIdentity()这两个方法使用过程都是成对使用的，这两个方法配合使用，用于权限控制检测功能。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、原理&lt;/h2&gt;

&lt;p&gt;从定义这两个方法是native方法，通过&lt;a href=&quot;http://gityuan.com/2015/11/21/binder-framework/#registerandroidosbinder&quot;&gt;Binder的JNI调用&lt;/a&gt;，在&lt;code class=&quot;highlighter-rouge&quot;&gt;android_util_Binder.cpp&lt;/code&gt;文件中定义了native方法所对应的jni方法。&lt;/p&gt;

&lt;h3 id=&quot;clearcallingidentity&quot;&gt;2.1 clearCallingIdentity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[–&amp;gt;android_util_Binder.cpp]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static jlong android_os_Binder_clearCallingIdentity(JNIEnv* env, jobject clazz)
{
    //调用IPCThreadState类的方法执行
    return IPCThreadState::self()-&amp;gt;clearCallingIdentity();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[–&amp;gt;IPCThreadState.cpp]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int64_t IPCThreadState::clearCallingIdentity()
{
    int64_t token = ((int64_t)mCallingUid&amp;lt;&amp;lt;32) | mCallingPid;
    clearCaller();
    return token;
}

void IPCThreadState::clearCaller()
{
    mCallingPid = getpid(); //当前进程pid赋值给mCallingPid
    mCallingUid = getuid(); //当前进程uid赋值给mCallingUid
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;mCallingUid(记为UID)，保存Binder IPC通信的调用方进程的Uid；&lt;/li&gt;
  &lt;li&gt;mCallingPid(记为PID)，保存Binder IPC通信的调用方进程的Pid；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UID和PID是IPCThreadState的成员变量， 都是32位的int型数据，通过移位操作，将UID和PID的信息保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;，其中高32位保存UID，低32位保存PID。然后调用clearCaller()方法将当前本地进程pid和uid分别赋值给PID和UID，最后返回&lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;restorecallingidentity&quot;&gt;2.2 restoreCallingIdentity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;[–&amp;gt;android_util_Binder.cpp]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void android_os_Binder_restoreCallingIdentity(JNIEnv* env, jobject clazz, jlong token)
{
    //token记录着uid信息，将其右移32位得到的是uid
    int uid = (int)(token&amp;gt;&amp;gt;32);
    if (uid &amp;gt; 0 &amp;amp;&amp;amp; uid &amp;lt; 999) {
        //目前Android中不存在小于999的uid，当uid&amp;lt;999则抛出异常。
        char buf[128];
        jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, buf);
        return;
    }
    //调用IPCThreadState类的方法执行
    IPCThreadState::self()-&amp;gt;restoreCallingIdentity(token);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[–&amp;gt;IPCThreadState.cpp]&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void IPCThreadState::restoreCallingIdentity(int64_t token)
{
    mCallingUid = (int)(token&amp;gt;&amp;gt;32);
    mCallingPid = (int)token;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;中解析出PID和UID，并赋值给相应的变量。该方法正好是&lt;code class=&quot;highlighter-rouge&quot;&gt;clearCallingIdentity&lt;/code&gt;的反过程。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;三、用途&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.1 场景分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt;首先线程A通过Binder远程调用线程B，然后线程B通过Binder调用当前线程的另一个service或者activity之类的组件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程A通过Binder远程调用线程B：则线程B的IPCThreadState中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mCallingUid&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mCallingPid&lt;/code&gt;保存的就是线程A的UID和PID。这时在线程B中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.getCallingPid()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Binder.getCallingUid()&lt;/code&gt;方法便可获取线程A的UID和PID，然后利用UID和PID进行权限比对，判断线程A是否有权限调用线程B的某个方法。&lt;/li&gt;
  &lt;li&gt;线程B通过Binder调用当前线程的某个组件：此时线程B是线程B某个组件的调用端，则&lt;code class=&quot;highlighter-rouge&quot;&gt;mCallingUid&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mCallingPid&lt;/code&gt;应该保存当前线程B的PID和UID，故需要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;clearCallingIdentity()&lt;/code&gt;方法完成这个功能。当线程B调用完某个组件，由于线程B仍然处于线程A的被调用端，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;mCallingUid&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mCallingPid&lt;/code&gt;需要恢复成线程A的UID和PID，这是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;restoreCallingIdentity()&lt;/code&gt;即可完成。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/binder/binder_clearCallingIdentity.jpg&quot; alt=&quot;binder_clearCallingIdentity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一句话：图中过程2（调用组件2开始之前）执行&lt;code class=&quot;highlighter-rouge&quot;&gt;clearCallingIdentity()&lt;/code&gt;，过程3（调用组件2结束之后）执行&lt;code class=&quot;highlighter-rouge&quot;&gt;restoreCallingIdentity()&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.2 类比分析&lt;/h3&gt;

&lt;p&gt;看完场景分析，估计还有不少朋友感到迷惑，为何需要这两个方法来多此一举，直接检测最初调用端的权限不就行了吗？为了更加形象明了地说明其用途，下面用一个生活中的场景来类比说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt;假如你的朋友请你帮忙，给她(他)到你的公司以内部价购买公司的某个产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;这个过程分为两个阶段&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/binder/binder_clearCallingIdentity_2.jpg&quot; alt=&quot;binder_clearCallingIdentity_2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一阶段：你的朋友请你帮忙的过程，这个过程并不一定所有朋友都会帮的，这时就需要一个权限检测，那么在你的朋友”远程调用”你执行任务时，你会记录他的”Identity”信息（比如是性别），有了信息那么就可以权限检测，不妨令权限规则是如果这个朋友是女性则答应帮忙，否则就认定权限不够拒绝执行（可能黑客会想到先去一趟泰国，权限控制可能相应需要打补丁了），若答应帮忙则进入第二阶段，否则直接返回。&lt;/li&gt;
  &lt;li&gt;第二阶段：你向自己所在公司的相关部门内购产品的过程，这个过程也并不是所有人都能权限能够内购的，只有自己公司的员工才行，否则你的朋友也不会找你帮忙了。 这个过程同样需要权限检测，但是”Identity”保存的是性别女的信息，公司内购产品如果也以性别来判断，那岂不是公司的所有男员工没有权限内购，那这公司就有点太坑了，这明显不符合实情。 &lt;code class=&quot;highlighter-rouge&quot;&gt;clearCallingIdentity()&lt;/code&gt;是时候该登场了，在第二阶段开始之前，先执行&lt;code class=&quot;highlighter-rouge&quot;&gt;clearCallingIdentity()&lt;/code&gt;过程，也就是把”Identity”信息清空，替换为你的信息（比如员工编码ITCode之类的），那公司相关部门通过ITCode就可以直接判断是否允许内购某产品。当第二阶段完成后，也就是你已经购买到了公司产品，这时你需要将产品交付给你的朋友，需要&lt;code class=&quot;highlighter-rouge&quot;&gt;restoreCallingIdentity&lt;/code&gt;，恢复”Identity”为女的信息，这样就嗯呢该顺便交付给你的女朋友。如果不恢复信息，还是原来的ITCode，你交付的朋友可能是男的，另有其人，这样就不科学了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相信到此，大家应该都能明白这两个方法的作用，缺一不可，而且要成对出现。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;3.3 实例分析&lt;/h3&gt;

&lt;p&gt;上述过程主要在system_server进程的各个线程中比较常见（普通的app应用很少出现），比如system_server进程中的ActivityManagerService子线程，代码如下：&lt;/p&gt;

&lt;p&gt;[–&amp;gt;ActivityManagerService.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public final void attachApplication(IApplicationThread thread) {
    synchronized (this) {
        //获取远程Binder调用端的pid
        int callingPid = Binder.getCallingPid();
        //清除远程Binder调用端uid和pid信息，并保存到origId变量
        final long origId = Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid);
        //通过origId变量，还原远程Binder调用端的uid和pid信息
        Binder.restoreCallingIdentity(origId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文章&lt;a href=&quot;http://gityuan.com/2016/02/21/start-service/#activitymanagerproxyattachapplication&quot;&gt;startService流程分析&lt;/a&gt;中有讲到&lt;code class=&quot;highlighter-rouge&quot;&gt;attachApplication()&lt;/code&gt;的调用。该方法一般是system_server进程的子线程调用远程进程时使用，而&lt;code class=&quot;highlighter-rouge&quot;&gt;attachApplicationLocked&lt;/code&gt;方法则是在同一个线程中，故需要在调用该方法前清空远程调用者的uid和pid，调用结束后恢复远程调用者的uid和pid。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如果觉得本文对您有所帮助，请关注我的&lt;strong&gt;微信公众号：gityuan&lt;/strong&gt;， &lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;。 或者&lt;a href=&quot;http://gityuan.com/about/&quot;&gt;点击这里查看更多关于我的信息&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Mar 2016 04:12:45 +0800</pubDate>
        <link>http://gityuan.com/2016/03/06/binder-clearCallingIdentity/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/03/06/binder-clearCallingIdentity/</guid>
        
        <category>android</category>
        
        <category>binder</category>
        
        <category>permission</category>
        
        
      </item>
    
      <item>
        <title>Pm命令用法</title>
        <description>&lt;h2 id=&quot;pm&quot;&gt;一、Pm命令&lt;/h2&gt;

&lt;p&gt;命令格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm &amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令列表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;实现方法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;list packages&lt;/td&gt;
      &lt;td&gt;列举app包信息&lt;/td&gt;
      &lt;td&gt;PMS.getInstalledPackages&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;install &lt;code class=&quot;highlighter-rouge&quot;&gt;[options&lt;/code&gt;] &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;PATH&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;安装应用&lt;/td&gt;
      &lt;td&gt;PMS.installPackageAsUser&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uninstall &lt;code class=&quot;highlighter-rouge&quot;&gt;[options&lt;/code&gt;]&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;卸载应用&lt;/td&gt;
      &lt;td&gt;IPackageInstaller.uninstall&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;enable &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;包名或组件名&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;enable&lt;/td&gt;
      &lt;td&gt;PMS.setEnabledSetting&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;disable &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;包名或组件名&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;disable&lt;/td&gt;
      &lt;td&gt;PMS.setEnabledSetting&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hide &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;隐藏应用&lt;/td&gt;
      &lt;td&gt;PMS.setApplicationHiddenSettingAsUser&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unhide &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;显示应用&lt;/td&gt;
      &lt;td&gt;PMS.setApplicationHiddenSettingAsUser&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get-install-location&lt;/td&gt;
      &lt;td&gt;获取安装位置&lt;/td&gt;
      &lt;td&gt;PMS.getInstallLocation&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;set-install-location&lt;/td&gt;
      &lt;td&gt;设置安装位置&lt;/td&gt;
      &lt;td&gt;PMS.setInstallLocation&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;path &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;查看App路径&lt;/td&gt;
      &lt;td&gt;PMS.getPackageInfo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clear &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;清空App数据&lt;/td&gt;
      &lt;td&gt;AMS.clearApplicationUserData&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get-max-users&lt;/td&gt;
      &lt;td&gt;最大用户数&lt;/td&gt;
      &lt;td&gt;UserManager.getMaxSupportedUsers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;force-dex-opt &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;dex优化&lt;/td&gt;
      &lt;td&gt;PMS.forceDexOpt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dump &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;dump信息&lt;/td&gt;
      &lt;td&gt;AM.dumpPackageStateStatic&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;trim-caches &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;目标size&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;紧缩cache目标大小&lt;/td&gt;
      &lt;td&gt;PMS.freeStorageAndNotify&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;pm命令实的实现方式在Pm.java，最后大多数都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;PackageManagerService&lt;/code&gt;相应的方法来完成的。disbale之后，在桌面和应用程序列表里边都看到不该app。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;二、详细参数&lt;/h2&gt;

&lt;h3 id=&quot;list-packages&quot;&gt;2.1 list packages&lt;/h3&gt;

&lt;p&gt;查看所有的package&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list packages [options] &amp;lt;FILTER&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其中[options]参数：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-f: 显示包名所关联的文件；&lt;/li&gt;
  &lt;li&gt;-d: 只显示disabled包名；&lt;/li&gt;
  &lt;li&gt;-e: 只显示enabled包名；&lt;/li&gt;
  &lt;li&gt;-s: 只显示系统包名；&lt;/li&gt;
  &lt;li&gt;-3: 只显示第3方应用的包名；&lt;/li&gt;
  &lt;li&gt;-i: 包名所相应的installer;&lt;/li&gt;
  &lt;li&gt;-u: 包含uninstalled包名.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;规律&lt;/strong&gt;： disabled + enabled = 总应用个数；  系统 + 第三方 = 总应用个数。&lt;/p&gt;

&lt;p&gt;比如：查看第3方应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm list packages -3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;又比如，查看已经被禁用的包名。（国内的厂商一般把google的服务禁用了）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm list packages -d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;FILTER&lt;/code&gt;&amp;gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当FILTER为不为空时，则只会输出包名带有FILTER字段的应用；当FILTER为空时，则默认显示所有满足条件的应用。&lt;/p&gt;

&lt;p&gt;比如，查看包名带google字段的包名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm list packages google
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;pm-install&quot;&gt;2.2 pm install&lt;/h3&gt;

&lt;p&gt;安装应用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm install [options] &amp;lt;PATH&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其中[options]参数：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-r: 覆盖安装已存在Apk，并保持原有数据；&lt;/li&gt;
  &lt;li&gt;-d: 运行安装低版本Apk;&lt;/li&gt;
  &lt;li&gt;-t: 运行安装测试Apk&lt;/li&gt;
  &lt;li&gt;-i &lt;installer_package_name&gt;: 指定Apk的安装器；&lt;/installer_package_name&gt;&lt;/li&gt;
  &lt;li&gt;-s: 安装apk到共享快存储，比如sdcard;&lt;/li&gt;
  &lt;li&gt;-f: 安装apk到内部系统内存；&lt;/li&gt;
  &lt;li&gt;-l: 安装过程，持有转发锁&lt;/li&gt;
  &lt;li&gt;-g: 准许Apk manifest中的所有权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;PATH&lt;/code&gt;&amp;gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数是必须的，是指需要安装的apk所在的路径。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.3 其他参数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm list users //查看当前手机用户
pm list libraries //查看当前设备所支持的库
pm list features //查看系统所有的features
pm list instrumentation //所有测试包的信息
pm list permission-groups //查看所有的权限组
pm list permissions [options] &amp;lt;group&amp;gt; 查看权限
	-g: 以组形式组织；
	-f: 打印所有信息；
	-s: 简要信息；
	-d: 只列举危险权限；
	-u: 只列举用户可见的权限。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;如果觉得本文对您有所帮助，请关注我的&lt;strong&gt;微信公众号：gityuan&lt;/strong&gt;， &lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;。 或者&lt;a href=&quot;http://gityuan.com/about/&quot;&gt;点击这里查看更多关于我的信息&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Feb 2016 04:55:51 +0800</pubDate>
        <link>http://gityuan.com/2016/02/29/pm-command/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/02/29/pm-command/</guid>
        
        <category>android</category>
        
        <category>pm</category>
        
        <category>command</category>
        
        
      </item>
    
      <item>
        <title>Am命令用法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;一、概述&lt;/h2&gt;

&lt;p&gt;作为一名开发者，相信对adb指令一定不会陌生。那么在手机连接adb后，可通过am命令做很多操作：&lt;/p&gt;

&lt;p&gt;(1) 拨打电话10086&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb shell am start -a android.intent.action.CALL -d tel:10086
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(2) 打开网站&lt;code class=&quot;highlighter-rouge&quot;&gt;www.gityuan.com&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb shell am start -a android.intent.action.VIEW -d  http://gityuan.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(3) 启动Activity： 启动包名为&lt;code class=&quot;highlighter-rouge&quot;&gt;com.yuanhh.app&lt;/code&gt;，主Activity为&lt;code class=&quot;highlighter-rouge&quot;&gt;.MainActivity&lt;/code&gt;，且extra数据以”website”为key, “yuanh.com”为value。通过java代码要完成该功能虽然不复杂，但至少需要一个android环境，而通过adb的方式，只需要在adb窗口，输入如下命令便可完成:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am start -n com.yuanhh.app/.MainActivity -es website gityuan.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;am命令还可以启动Service、Broadcast，杀进程，监控等功能，这些功能都非常便捷调试程序，接下来讲述关于am更多更详细的功能。&lt;/p&gt;

&lt;h2 id=&quot;am&quot;&gt;二、Am命令&lt;/h2&gt;

&lt;p&gt;命令格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am [subcommand] [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令列表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;实现方法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;am start  &lt;code class=&quot;highlighter-rouge&quot;&gt;[options&lt;/code&gt;]  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;INTENT&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;启动Activity&lt;/td&gt;
      &lt;td&gt;startActivityAsUser&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am startservice  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;INTENT&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;启动Service&lt;/td&gt;
      &lt;td&gt;startService&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am stopservice  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;INTENT&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;停止Service&lt;/td&gt;
      &lt;td&gt;stopService&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am broadcast  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;INTENT&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;发送广播&lt;/td&gt;
      &lt;td&gt;broadcastIntent&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am kill  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;PACKAGE&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;杀指定后台进程&lt;/td&gt;
      &lt;td&gt;killBackgroundProcesses&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am kill-all&lt;/td&gt;
      &lt;td&gt;杀所有后台进程&lt;/td&gt;
      &lt;td&gt;killAllBackgroundProcesses&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am force-stop  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;PACKAGE&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;强杀进程&lt;/td&gt;
      &lt;td&gt;forceStopPackage&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am hang&lt;/td&gt;
      &lt;td&gt;系统卡住&lt;/td&gt;
      &lt;td&gt;hang&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am restart&lt;/td&gt;
      &lt;td&gt;重启&lt;/td&gt;
      &lt;td&gt;restart&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am bug-report&lt;/td&gt;
      &lt;td&gt;创建bugreport&lt;/td&gt;
      &lt;td&gt;requestBugReport&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am dumpheap &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pid&lt;/code&gt;&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;file&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;进程pid的堆信息输出到file&lt;/td&gt;
      &lt;td&gt;dumpheap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am send-trim-memory  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pid&lt;/code&gt;&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;level&lt;/code&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;收紧进程的内存&lt;/td&gt;
      &lt;td&gt;setProcessMemoryTrimLevel&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;am monitor&lt;/td&gt;
      &lt;td&gt;监控&lt;/td&gt;
      &lt;td&gt;MyActivityController.run&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;am命令实的实现方式在Am.java，最终几乎都是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityManagerService&lt;/code&gt;相应的方法来完成的，&lt;code class=&quot;highlighter-rouge&quot;&gt;am monitor&lt;/code&gt;除外。比如前面概述中介绍的命令&lt;code class=&quot;highlighter-rouge&quot;&gt;am start -a android.intent.action.VIEW -d  http://gityuan.com&lt;/code&gt;， 启动Acitivty最终调用的是ActivityManagerService类的startActivityAsUser()方法来完成的。再比如&lt;code class=&quot;highlighter-rouge&quot;&gt;am kill-all&lt;/code&gt;命令，最终的实现工作是由ActivityManagerService的killBackgroundProcesses()方法完成的。&lt;/p&gt;

&lt;p&gt;接下来，说说&lt;code class=&quot;highlighter-rouge&quot;&gt;[options&lt;/code&gt;]和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;INTENT&lt;/code&gt;&amp;gt;参数的意义以及如何正确取值。&lt;/p&gt;

&lt;h2 id=&quot;options&quot;&gt;三、 Options&lt;/h2&gt;

&lt;h3 id=&quot;activity&quot;&gt;3.1 启动Activity&lt;/h3&gt;
&lt;p&gt;主要是启动Activity命令&lt;code class=&quot;highlighter-rouge&quot;&gt;am start [options] &amp;lt;INTENT&amp;gt;&lt;/code&gt;使用options参数，接下来列举Activity命令的[options]参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-D: 允许调试功能&lt;/li&gt;
  &lt;li&gt;-W: 等待app启动完成&lt;/li&gt;
  &lt;li&gt;-R &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;COUNT&lt;/code&gt;&amp;gt;: 重复启动Activity COUNT次&lt;/li&gt;
  &lt;li&gt;-S: 启动activity之前，先调用forceStopPackage()方法强制停止app.&lt;/li&gt;
  &lt;li&gt;–opengl-trace: 运行获取OpenGL函数的trace&lt;/li&gt;
  &lt;li&gt;–user &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;USER_ID&lt;/code&gt;&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; current: 指定用户来运行App,默认为当前用户。&lt;/li&gt;
  &lt;li&gt;–start-profiler &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;FILE&lt;/code&gt;&amp;gt;: 启动profiler，并将结果发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;FILE&lt;/code&gt;&amp;gt;;&lt;/li&gt;
  &lt;li&gt;-P &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;FILE&lt;/code&gt;&amp;gt;: 类似 –start-profiler，不同的是当app进入idle状态，则停止profiling&lt;/li&gt;
  &lt;li&gt;–sampling INTERVAL: 设置profiler 取样时间间隔，单位ms;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动Activity的实现原理： 存在-W参数则调用startActivityAndWait()方法来运行，否则startActivityAsUser()。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3.2 收紧内存&lt;/h3&gt;
&lt;p&gt;命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am send-trim-memory  &amp;lt;pid&amp;gt; &amp;lt;level&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如： 向pid=12345的进程，发出level=RUNNING_LOW的收紧内存命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am send-trim-memory 12345 RUNNING_LOW。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么level取值范围为： HIDDEN、RUNNING_MODERATE、BACKGROUND、RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.3 其他&lt;/h3&gt;

&lt;p&gt;对于am的子命令，startservice, stopservice, broadcast, kill, profile start, profile stop, dumpheap的可选参数都允许设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--user &amp;lt;USER_ID&amp;gt;&lt;/code&gt;。目前市面上的绝大多数手机还是单用户模式，故可以忽略该参数，默认为当前用户。&lt;/p&gt;

&lt;p&gt;例如：启动id=10010的用户的指定service。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am startservice --user 10010
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;intent&quot;&gt;四、 Intent&lt;/h2&gt;

&lt;p&gt;Intent的参数和flags较多，本文为方便起见，分为3种类型参数，常用参数，Extra参数，Flags参数。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4.1 常用参数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-a &amp;lt;ACTION&amp;gt;&lt;/code&gt;: 指定Intent action， 实现原理Intent.setAction()；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n &amp;lt;COMPONENT&amp;gt;&lt;/code&gt;: 指定组件名，格式为{包名}/.{主Activity名}，实现原理Intent.setComponent(）；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d &amp;lt;DATA_URI&amp;gt;&lt;/code&gt;: 指定Intent data URI&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t &amp;lt;MIME_TYPE&amp;gt;&lt;/code&gt;: 指定Intent MIME Type&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c &amp;lt;CATEGORY&amp;gt; [-c &amp;lt;CATEGORY&amp;gt;] ...]&lt;/code&gt;:指定Intent category，实现原理Intent.addCategory()&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p &amp;lt;PACKAGE&amp;gt;&lt;/code&gt;: 指定包名，实现原理Intent.setPackage();&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f &amp;lt;FLAGS&amp;gt;&lt;/code&gt;: 添加flags，实现原理Intent.setFlags(int )，紧接着的参数必须是int型；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am start -a android.intent.action.VIEW
am start -n com.yuanhh.app/.MainActivity
am start -d content://contacts/people/1
am start -t image/png
am start -c android.intent.category.APP_CONTACTS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;extra&quot;&gt;4.2 Extra参数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;(1). 基本类型&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;参数&lt;/td&gt;
      &lt;td&gt;-e/-es&lt;/td&gt;
      &lt;td&gt;-esn&lt;/td&gt;
      &lt;td&gt;-ez&lt;/td&gt;
      &lt;td&gt;-ei&lt;/td&gt;
      &lt;td&gt;-el&lt;/td&gt;
      &lt;td&gt;-ef&lt;/td&gt;
      &lt;td&gt;-eu&lt;/td&gt;
      &lt;td&gt;-ecn&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;类型&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;(String)null&lt;/td&gt;
      &lt;td&gt;boolean&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
      &lt;td&gt;long&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
      &lt;td&gt;uri&lt;/td&gt;
      &lt;td&gt;component&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;比如参数es是Extra String首字母简称，实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am start -n com.yuanhh.app/.MainActivity -es website gityuan.com 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处&lt;code class=&quot;highlighter-rouge&quot;&gt;-es website gityuan.com&lt;/code&gt;，等价于Intent.putExtra(“website”, “gityuan.com”);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2). 数组类型&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;参数&lt;/td&gt;
      &lt;td&gt;-esa&lt;/td&gt;
      &lt;td&gt;-eia&lt;/td&gt;
      &lt;td&gt;-ela&lt;/td&gt;
      &lt;td&gt;-efa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数组类型&lt;/td&gt;
      &lt;td&gt;String[]&lt;/td&gt;
      &lt;td&gt;int[]&lt;/td&gt;
      &lt;td&gt;long[]&lt;/td&gt;
      &lt;td&gt;float[]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;比如参数eia，是Extra int array首字母简称，多个value值之间以逗号隔开，实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am start -n com.yuanhh.app/.MainActivity -ela weekday 1,2,3,4,5 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处&lt;code class=&quot;highlighter-rouge&quot;&gt;-ela weekday 1,2,3,4,5&lt;/code&gt;，等价于Intent.putExtra(“weekday”, new int[]{1,2,3,4,5});&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3). ArrayList类型&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;参数&lt;/td&gt;
      &lt;td&gt;-esal&lt;/td&gt;
      &lt;td&gt;-eial&lt;/td&gt;
      &lt;td&gt;-elal&lt;/td&gt;
      &lt;td&gt;-efal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;List类型&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
      &lt;td&gt;long&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;比如参数efal，是Extra float Array List首字母简称，多个value值之间以逗号隔开，实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am start -n com.yuanhh.app/.MainActivity -efal nums 1.2,2.2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处&lt;code class=&quot;highlighter-rouge&quot;&gt;-efal nums 1.2,2.2&lt;/code&gt;，等价于先构造ArrayList变量，再通过putExtra放入第二个参数。&lt;/p&gt;

&lt;h3 id=&quot;flags&quot;&gt;4.3 Flags参数&lt;/h3&gt;

&lt;p&gt;在参数类型1中，提到有&lt;code class=&quot;highlighter-rouge&quot;&gt;-f &amp;lt;FLAGS&amp;gt;&lt;/code&gt;，是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Intent.setFlags(int )&lt;/code&gt;方法，来设置Intent的flags.本小节也是关于flags，是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Intent.addFlags(int )&lt;/code&gt;方法。如下所示，所有的flags参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[--grant-read-uri-permission] [--grant-write-uri-permission]
[--grant-persistable-uri-permission] [--grant-prefix-uri-permission]
[--debug-log-resolution]
[--exclude-stopped-packages] [--include-stopped-packages]
[--activity-brought-to-front] [--activity-clear-top]
[--activity-clear-when-task-reset] [--activity-exclude-from-recents]
[--activity-launched-from-history] [--activity-multiple-task]
[--activity-no-animation] [--activity-no-history]
[--activity-no-user-action] [--activity-previous-is-top]
[--activity-reorder-to-front] [--activity-reset-task-if-needed]
[--activity-single-top] [--activity-clear-task]
[--activity-task-on-home]
[--receiver-registered-only] [--receiver-replace-pending]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，发送action=”broadcast.demo”的广播，并且对于forceStopPackage()的应用不允许接收该广播，命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;am broadcast -a broadcast.demo --exclude-stopped-packages
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;如果觉得本文对您有所帮助，请关注我的&lt;strong&gt;微信公众号：gityuan&lt;/strong&gt;， &lt;strong&gt;&lt;a href=&quot;http://weibo.com/gityuan&quot;&gt;微博：Gityuan&lt;/a&gt;&lt;/strong&gt;。 或者&lt;a href=&quot;http://gityuan.com/about/&quot;&gt;点击这里查看更多关于我的信息&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Feb 2016 04:55:51 +0800</pubDate>
        <link>http://gityuan.com/2016/02/28/am-command/</link>
        <guid isPermaLink="true">http://gityuan.com/2016/02/28/am-command/</guid>
        
        <category>android</category>
        
        <category>am</category>
        
        <category>command</category>
        
        
      </item>
    
  </channel>
</rss>
