<hr />
<p>layout: post
title:  “Android动画之插值器（三）”
date:   2015-9-5 22:20:00
catalog:  true
tags:
    - android
    - 动画</p>

<hr />

<blockquote>
  <p>本文从源码的角度，来展开对动画的深入解析，关于动画基本用法，可查看<a href="http://gityuan.com/2015/09/03/android-anaimator-1/"><strong>Android动画之入门篇(一）</strong></a>，<a href="http://gityuan.com/2015/09/04/android-anaimator-2/"><strong>Android动画之入门篇（二）</strong></a>。</p>
</blockquote>

<p>关于动画有两个非常重要的类，那就是插值器(Interpolators)与 估值器（Evaluators），下面将详细讲解。</p>

<h2 id="section">一、 插值器</h2>
<p>时间插值器，定义了一个时间的函数：y = f(t),其中t=<code class="highlighter-rouge">elapsed time</code> / <code class="highlighter-rouge">duration</code>.</p>

<p>每个插值器的源码流程都相同，下面以AccelerateInterpolator为例，说明插值器的内部原理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//系统自带的所有插值器都继承了BaseInterpolator
public class AccelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory {
    private final float mFactor;
    private final double mDoubleFactor;

    //无参数的构造方法, factor默认为1
    public AccelerateInterpolator() {
        mFactor = 1.0f;
        mDoubleFactor = 2.0;
    }

    //有参数的构造方法
    public AccelerateInterpolator(float factor) {
        mFactor = factor;
        mDoubleFactor = 2 * mFactor;
    }

     //构造方法，通过资源文件获取参数
    public AccelerateInterpolator(Context context, AttributeSet attrs) {
        this(context.getResources(), context.getTheme(), attrs);
    }

    /** @hide 隐藏方法，真正用来解析资源文件的方法*/
    public AccelerateInterpolator(Resources res, Theme theme, AttributeSet attrs) {
        TypedArray a;
        if (theme != null) {
            a = theme.obtainStyledAttributes(attrs, R.styleable.AccelerateInterpolator, 0, 0);
        } else {
            a = res.obtainAttributes(attrs, R.styleable.AccelerateInterpolator);
        }
        
        //资源文件未定义factor时，默认为1.0f
        mFactor = a.getFloat(R.styleable.AccelerateInterpolator_factor, 1.0f);
        mDoubleFactor = 2 * mFactor;
        setChangingConfiguration(a.getChangingConfigurations());
        // 回收TypedArray，释放相应的内存资源
        a.recycle();
    }
    
    //插值计算的核心方法，定义了插值的映射关系
    public float getInterpolation(float input) {
        if (mFactor == 1.0f) {
            return input * input;
        } else {
            return (float)Math.pow(input, mDoubleFactor);
        }
    }

    /** @hide */
    @Override
    public long createNativeInterpolator() {
        return NativeInterpolatorFactoryHelper.createAccelerateInterpolator(mFactor);
    }
}
</code></pre>
</div>

<p>其中 <code class="highlighter-rouge">BaseInterpolaor</code>实现了<code class="highlighter-rouge">Interpolator</code>接口，而<code class="highlighter-rouge">Interpolator</code>接口并没有定义任何方法和属性，只是单纯地继承了<code class="highlighter-rouge">TimeInterpolator</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>abstract public class BaseInterpolator implements Interpolator {
    private int mChangingConfiguration;
    /**
     * @hide
     */
    public int getChangingConfiguration() {
        return mChangingConfiguration;
    }

    /**
     * @hide
     */
    void setChangingConfiguration(int changingConfiguration) {
        mChangingConfiguration = changingConfiguration;
    }
}
</code></pre>
</div>

<p><code class="highlighter-rouge">TimeInterpolator</code>接口自定义了一个方法<code class="highlighter-rouge">getInterpolation</code>,这就是所有插值器最为核心的方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface TimeInterpolator {

    /*
     * @param input 代表动画的已执行的时间，∈[0,1]
     * @return 插值转换后的值
     */
    float getInterpolation(float input);
}
</code></pre>
</div>

<p>通过分析每一个插值器的插值方法的源码，下面总结了所有插值器的插值函数：</p>

<h3 id="linear">1.1 Linear</h3>
<ul>
  <li>资源ID: @android:anim/linear_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public LinearInterpolator()</code>; //没有任何可调参数</li>
    </ul>
  </li>
  <li>插值函数：
    <ul>
      <li>公式：<code class="highlighter-rouge">y=t</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/1.png" alt="Linear Interpolator" /></li>
</ul>

<h3 id="accelerate">1.2 Accelerate</h3>
<ul>
  <li>资源ID: @android:anim/accelerate_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public AccelerateInterpolator()</code>；//默认factor=1</li>
      <li><code class="highlighter-rouge">public AccelerateInterpolator(float factor)</code>；</li>
      <li><code class="highlighter-rouge">public AccelerateInterpolator(Context context, AttributeSet attrs)</code>; //通过资源文件获取factor值，默认为1。</li>
    </ul>
  </li>
  <li>插值函数：factor为加速因子，记为f, 默认值为1
    <ul>
      <li>公式：<code class="highlighter-rouge">y=t^(2f)</code></li>
      <li>缺省：<code class="highlighter-rouge">y=t^2</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/2.png" alt="Accelerate Interpolator" /></li>
</ul>

<h3 id="decelerate">1.3 Decelerate</h3>
<ul>
  <li>资源ID: @android:anim/decelerate_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public AccelerateInterpolator()</code>；//默认factor=1</li>
      <li><code class="highlighter-rouge">public AccelerateInterpolator(float factor)</code>；</li>
      <li><code class="highlighter-rouge">public AccelerateInterpolator(Context context, AttributeSet attrs)</code>; //通过资源文件获取factor值，默认为1。</li>
    </ul>
  </li>
  <li>插值函数：factor为减速因子，记为f, 默认值为1
    <ul>
      <li>公式：<code class="highlighter-rouge">y= 1-(1-t）^(2f)</code>,</li>
      <li>缺省：<code class="highlighter-rouge">y= 2t-t^2</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/3.png" alt="Decelerate Interpolator" /></li>
</ul>

<h3 id="acceleratedecelerate">1.4 AccelerateDecelerate</h3>
<ul>
  <li>资源ID: @android:anim/accelerate_decelerate_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public AccelerateDecelerateInterpolator()</code>；  //没有任何可调参数<br />
资源文件获取factor值。</li>
    </ul>
  </li>
  <li>插值函数：
    <ul>
      <li>公式：<code class="highlighter-rouge">y = 0.5cos((t+1)π)+0.5</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/4.png" alt="AccelerateDecelerate Interpolator" /></li>
</ul>

<h3 id="anticipate">1.5 Anticipate</h3>
<ul>
  <li>资源ID: @android:anim/anticipate_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public AnticipateInterpolator()</code>；//默认tension=2</li>
      <li><code class="highlighter-rouge">public AnticipateInterpolator(float tension)</code>；</li>
      <li><code class="highlighter-rouge">public AnticipateInterpolator(Context context, AttributeSet attrs)</code>; //通过资源文件获取tension值。</li>
    </ul>
  </li>
  <li>插值函数：tension`为张力因子，记为s, 默认值为2
    <ul>
      <li>公式：<code class="highlighter-rouge">y = t*t*((s+1)t-s)</code>,</li>
      <li>缺省：<code class="highlighter-rouge">y = t*t*(3t-2)</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/5.png" alt="Anticipate Interpolator" /></li>
</ul>

<h3 id="overshoot">1.6 Overshoot</h3>
<ul>
  <li>资源ID: @android:anim/overshoot_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public OvershootInterpolator()</code>；//默认tension=2</li>
      <li><code class="highlighter-rouge">public OvershootInterpolator(float tension)</code>；</li>
      <li><code class="highlighter-rouge">public OvershootInterpolator(Context context, AttributeSet attrs)</code>; //通过资源文件获取tension值。</li>
    </ul>
  </li>
  <li>插值函数：tension`为张力因子，记为s, 默认值为2
    <ul>
      <li>公式：<code class="highlighter-rouge">y  = (t-1)(t-1)((s+1)(t-1)+s) + 1</code>,</li>
      <li>缺省：<code class="highlighter-rouge">y = (t-1)(t-1)(3t-1) + 1</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/6.png" alt=" Overshoot Interpolator" /></li>
</ul>

<h3 id="anticipateovershoot">1.7 AnticipateOvershoot</h3>
<ul>
  <li>资源ID: @android:anim/anticipate_overshoot_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public AnticipateOvershootInterpolator()</code>；//默认tension=3</li>
      <li><code class="highlighter-rouge">public AnticipateOvershootInterpolator(float tension)</code>； //tension = 1.5*tension</li>
      <li><code class="highlighter-rouge">public AnticipateOvershootInterpolator(float tension, float extraTension)</code>; //tension =  tension * extraTension</li>
      <li><code class="highlighter-rouge">public AnticipateOvershootInterpolator(Context context, AttributeSet attrs)</code>; //通过资源文件获取tension值。</li>
    </ul>
  </li>
  <li>插值函数：tension`为张力因子，记为s
    <ul>
      <li>公式：
        <ul>
          <li><code class="highlighter-rouge">y  = 2t*t*(2t*s+2t-s), 当t &lt; 0.5时</code>,</li>
          <li><code class="highlighter-rouge">y = 2(t-1)(t-1)(2(s+1)(t-1)+s) + 1 ,  当t &gt;= 0.5时</code>,</li>
        </ul>
      </li>
      <li>缺省：
        <ul>
          <li><code class="highlighter-rouge">y = 2t*t*(8t-3),  当t &lt; 0.5时</code>,</li>
          <li><code class="highlighter-rouge">y = 2(t-1)(t-1)(8t-5) + 1 ,  当t &gt;= 0.5时</code>,</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/7.png" alt=" AnticipateOvershoot Interpolator" /></li>
</ul>

<h3 id="bounce">1.8 Bounce</h3>
<ul>
  <li>资源ID: @android:anim/bounce_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public BounceInterpolator()</code>；//没有任何可调参数</li>
    </ul>
  </li>
  <li>插值函数：
    <ul>
      <li>公式：
        <ul>
          <li>y = 8*(1.1226t)^2 ，当 t &lt; 0.3535</li>
          <li>y = 8*(1.1226t - 0.54719)^2 + 0.7 ，当 t &lt; 0.7408</li>
          <li>y = 8*(1.1226t - 0.8526)^2 + 0.9 ，当 t &lt; 0.9644</li>
          <li>y = 8*(1.1226t - 1.0435)^2 + 0.95 ，当 t &lt;= 1.0</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/8.png" alt="Bounce Interpolator" /></li>
</ul>

<h3 id="cycle">1.9 Cycle</h3>
<ul>
  <li>资源ID: @android:anim/cycle_interpolator</li>
  <li>构造方法：
    <ul>
      <li><code class="highlighter-rouge">public CycleInterpolator(float cycles)</code>；</li>
      <li><code class="highlighter-rouge">public CycleInterpolator(Context context, AttributeSet attrs)</code>; //通过资源文件获取cycles值，默认为1。</li>
    </ul>
  </li>
  <li>插值函数：cycles`为循环次数，记为c
    <ul>
      <li>公式：<code class="highlighter-rouge">y  = sin（2*c*t*π）</code>,</li>
      <li>缺省：<code class="highlighter-rouge">y = sin（2*t*π）</code></li>
    </ul>
  </li>
  <li>插值曲线：<br />
<img src="/images/interpolator/9.png" alt=" Cycle Interpolator" /></li>
</ul>

<hr />

<h2 id="section-1">二、 估值器</h2>
<p>估值器，用于计算属性动画的给定属性的取值，与属性的起始值，结束值，<code class="highlighter-rouge">fraction</code>三个值相关。</p>

<p>每个估值器的源码流程都相似，所有的估值器都实现了TypeEvaluator接口，接口采用泛型，可自定义各种类型的估值器，只需实现如下接口即可：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface TypeEvaluator&lt;T&gt; {
	/*
     *
     * @param fraction   插值器计算转换后的值
     * @param startValue 属性起始值
     * @param endValue   属性结束值
     * @return 转换后的值
     */
    public T evaluate(float fraction, T startValue, T endValue);
}
</code></pre>
</div>

<h3 id="intevaluator">2.1 IntEvaluator</h3>
<p>用于评估Integer型的属性值，起始值与结束值，以及evaluate返回值都是Integer类型。评估的返回值与fraction成一次函数，即线性关系。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; {

    /**
     * 函数关系：result = x0 + t * (x1 - x0)
     *
     * @param fraction   
     * @param startValue 属性起始值，Integer类型
     * @param endValue   属性结束值，Integer类型
     * @return 与fraction成线性关系。
     */
    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
        int startInt = startValue;
    	return (int)(startInt + fraction * (endValue - startInt));
    }
}
</code></pre>
</div>

<h3 id="floatevaluator">2.2 FloatEvaluator</h3>
<p>用于评估Float型的属性值，起始值与结束值，以及evaluate返回值都是Float类型，同样也是线程关系。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; {

    /**
     * @param fraction   
     * @param startValue 属性起始值，float类型
     * @param endValue   属性结束值，float类型
     * @return 与fraction成线性关系。
     */
    public Float evaluate(float fraction, Number startValue, Number endValue) {
    float startFloat = startValue.floatValue();
    return startFloat + fraction * (endValue.floatValue() - startFloat);
}
}
</code></pre>
</div>

<h3 id="argbevaluator">2.3 ArgbEvaluator</h3>
<p>用于评估颜色的属性值，采用16进制。将ARGB四个量，同步进行动画渐变，同样也是采用线性的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ArgbEvaluator implements TypeEvaluator {
    private static final ArgbEvaluator sInstance = new ArgbEvaluator();

   /*
    * @hide
    *   貌似采用单例的方式，可该方法确实@hide隐藏方法，同时并没有将构造方法定义为private。
    *   意味着单例对于上层开发者来说是不可见的，这样单例就没有起效果，google难道只是为了framework
    *   的单例使用，很诡异的设计。
 	    */
    public static ArgbEvaluator getInstance() {
        return sInstance;
    }

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        int startInt = (Integer) startValue;
        int startA = (startInt &gt;&gt; 24) &amp; 0xff;
        int startR = (startInt &gt;&gt; 16) &amp; 0xff;
        int startG = (startInt &gt;&gt; 8) &amp; 0xff;
        int startB = startInt &amp; 0xff;

        int endInt = (Integer) endValue;
        int endA = (endInt &gt;&gt; 24) &amp; 0xff;
        int endR = (endInt &gt;&gt; 16) &amp; 0xff;
        int endG = (endInt &gt;&gt; 8) &amp; 0xff;
        int endB = endInt &amp; 0xff;

        return (int)((startA + (int)(fraction * (endA - startA))) &lt;&lt; 24) |
                (int)((startR + (int)(fraction * (endR - startR))) &lt;&lt; 16) |
                (int)((startG + (int)(fraction * (endG - startG))) &lt;&lt; 8) |
                (int)((startB + (int)(fraction * (endB - startB))));
    }
}
</code></pre>
</div>

<hr />

<h2 id="section-2">三、小结</h2>
<p>本文主要分两部分，插值器与估值器。通过源码方式概括性分析插值器的代码实现方式；再从数学角度，逐一进行剖析系统自带的9种插值器的插值函数以及其插值曲线。对于3种Evaluators，通过分析源码，其方式较为简单，需要注意的一点是evaluate中的fraction是插值器转换后的值，而不是<code class="highlighter-rouge">elapsed time</code>。</p>
